CからみたGauche

[設計方針]

* Schemeで利用可能な機能は、できるだけCからも直接呼べるようなAPIを提供する。
  これにはSchemeの基本ライブラリ関数や、オブジェクトシステムへのインタフェースを含む。
  但し、Cでは意味をなさないものや、Cに馴染まないインタフェースを持つものは除く。

* Cから呼ぶ時に、面倒な型変換手続きや不要なオーバヘッドは避けたい。

* Cから呼んでCに戻る場合と、VMから呼んでVMに戻る場合とで、最適な呼出し方法が異なる
  場合がある。無理に一つにまとめるのではなく、必要なら両方のAPIを用意して
  ユーザがアプリケーションの要請に応じて選べるようにする。

* Staticに初期化可能なものは出来る限りstaticに初期化したい。コンパイル時に
  わかっている情報を実行時の初期化ルーチンで再計算するのは無駄である。

  
[実装方針]

型検査とAPI
.........

  Gaucheオブジェクトは、CからはScmObj型として扱える。マクロで型をチェックして、
  該当オブジェクトにキャストして使う。こんな感じだ。

    ScmObj obj = ...;
    if (SCM_STRINGP(obj)) {
       return SCM_STRING_SIZE(obj);
    }

  多くのCのAPIは、ScmObj以外の型を引数として取り、ScmObjを返す。すなわち、
  型検査と型変換は呼び出し側の責任である。例えばSchemeのstring-refに対応するAPI、
  Scm_StringRefの型は次のようになっている。

    ScmObj Scm_StringRef(ScmString *str, int k);

  呼び出し側がScmObjのオブジェクトを持っている場合、次のように呼ぶことになる。

    ScmObj str, k, result;

    if (!SCM_STRINGP(str)) Scm_Error(...);
    if (!SCM_INTP(k)) Scm_Error(...);
    result = Scm_StringRef(SCM_STRING(str), SCM_INT_VALUE(k));

  (この例ではkはsmall integerに収まると仮定。現実問題として、32bit addressの
   アーキテクチャでbignumが必要になる文字列をインデックスする必要は無い)。

  Scm_StringRefがふたつのScmObj型を取るようにして、関数内で型検査をする
  ようにすれば、呼び出し側の負担は減る。そうしなかった理由がいくつかある。

   * Cでコードを書く場合、呼び出し側がその型を知っている場合が多い。すなわち、
     呼ばれる側での型検査は無駄が多い。

   * ある程度、Cコンパイラでの静的な型チェックが使える。もちろんキャストしてしまったら
     コンパイラでは間違いを検出できないが、ケアレスミスは結構捕まえてくれるもんである。

   * 小さな整数を渡す場合などに、いちいち呼び出し側でboxして呼ばれる側でunboxするの
     は無駄が多い。

  一方、戻り値はほとんどScmObjで統一してある。但しpredicateについては、Cの
  if文なんかで使う便宜を考えて、intで戻すようになっているものが結構ある。


VMとのインタラクション
..................

  GaucheのAPIには、大別して次の2つのカテゴリがある。

   (1) 通常のCの関数のように呼べるもの。つまり、引数を渡すと結果が返ってくる。
   (2) VMから呼ぶことを想定しているもの。最終的にVMに結果が残るような
       副作用が発生する。関数からの戻り値は計算結果とは限らない。

  大部分のAPIは(1)であり、それだけ知ってても十分使えるが、Gaucheで効率の良い
  コードを書くためには(2)のAPIを使いこなさねばならない。

  (1)のカテゴリは、さらに次の2つに分類される。

   (1a) 内部でScheme式の評価をしない、単純関数。ほとんどはこれ。
        Scm_Cons、Scm_Member等。
   (1b) 内部でScheme式の評価をするもの。Scm_Eval、Scm_Apply、Scm_Load等。

  一方、(2)のカテゴリに属するのは、Scm_VMEval、Scm_VMApply等である。
  問題となるのは、(1b)と(2)の使い分けである。

  (1b)を使う場合に、気をつけなければならないのは次のルールである。

    「call/ccを正しく動作させるためには、SchemeのスタックとCのスタックが
      交差してはならない。」

  ここで、スタックが交差するとは、SchemeからCで書かれたコードを呼び、そこから
  さらにSchemeで書かれたコードを(例えばScm_Eval()等で)呼ぶということを指す。

     Scheme code X ----> C code Y ----> Scheme code Z

  のような呼び出しシーケンスで、Zでcontinuationを捕捉した場合、そのcontinuation
  はZからYに制御が戻った時点で無効になる。
  (但し、Xで捕捉したcontinuationをZ内で起動するのは問題無い。)

  このような呼び出しをしてはいけないということではない。ただ、このような呼び出しを
  する場合は、その制限を知らなければならない。

  これは、GaucheのcontinuationがCのスタック情報を保存しないことからくる
  制限である。YからZをScm_Eval()やScm_Apply()を使って呼ぶと、Cのスタックに
  (Yへの)戻りアドレスやらレジスタやらが積まれる。それらの情報はZの評価が済んで
  Scm_Eval()なりScm_Apply()が戻る時にポップされてしまう。例えZで捕捉した
  continuationをその後で起動しても、もう一度Scm_Eval()からYへ戻るということは
  できない。

  scm, STk, あるいは Guileなどの処理系では、continuationを捕捉した時点で
  Cのスタックをごっそりヒープにコピーして、continuationが呼び出されたらそれを
  スタックエリアに書き戻すということを行っている。

  GaucheでCスタックコピー法をとらなかったのは、次の理由による：

   (1) マルチスレッドになった時に、あるスレッドで捕捉したcontinuationを別の
       スレッドでも起動可能にしたかった。Cスタックはスレッド固有のアドレスが
       入っているためそれが不可能になる。

   (2) Cスタックコピーは重い。軽いcontinuationを実現する論文はいくつも出ている
       ので、それらのアルゴリズムを試してみたかった。

... to be continued ...






