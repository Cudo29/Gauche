@node Library modules - Gauche extensions, Library modules - SRFIs, Library modules - Overview, Top
@chapter Library modules - Gauche extensions
@c NODE ライブラリモジュール - Gauche拡張モジュール

@c ----------------------------------------------------------------------
@menu
* Arrays::                      
* Character code conversion::   
* Collection framework::        
* Configuration parameters::    
* Low-level file operations::   
* Hooks::                       
* Interactive session::         
* Listener::                    
* User-level logging::          
* Singleton::                   
* Slot with validator::         
* Networking::                  
* Parameters::                  
* Parsing command-line options::  
* High Level Process Interface::  
* Regular expression utilities::  
* Reloading modules::           
* Simple dispatcher::           
* Sequence framework::          
* Syslog::                      
* Termios::                     
* Unit testing::                
* Threads::                     
* Measure timings::             
* Uniform vectors::             
* Comparing version numbers::   
* Virtual ports::               
@end menu

@node Arrays, Character code conversion, Library modules - Gauche extensions, Library modules - Gauche extensions
@section @code{gauche.array} - Arrays
@c NODE 配列, @code{gauche.array} - 配列

@deftp {Module} gauche.array
@mdindex gauche.array
@c EN
This module provides multi-dimensional array data type and operations.
The primitive API follows SRFI-25. 
Besides a generic srfi-25 array that can store any Scheme objects,
this module also provides array classes that stores numeric objects
efficiently, backed up by
homogeneous numeric vectors (@xref{Uniform vectors}).
An external representation of arrays, using SRFI-10 mechanism,
is also provided.
@c JP
このモジュールは多次元配列のデータタイプとそれに関する操作を提供します。
プリミティブなAPIはSRFI-25で定義されているものに従います。
任意のSchemeオブジェクトを保持できるSRFI-25の汎用配列の他に、
均一な数値ベクタ(@ref{Uniform vectors}参照)を使って
数値要素を効率良く保持する配列型も提供されます。
また、SRFI-10を使った配列の外部表現も実装されます。
@c COMMON

@c EN
Each element of an @var{N}-dimensional array can be accessed
by @var{N} integer indices,
@code{[ @var{i_0} @var{i_1} @dots{} @var{i_N-1} ]}.
An array has associated @var{shape} that knows lower-bound @var{s_k} and
upper-bound @var{e_k} of index of each dimension, where
@var{s_k} <= @var{e_k}, and the index @var{i_k} must satisfy
@var{s_k} <= @var{i_k} < @var{e_k}.
(Note: it is allowed to have @var{s_k} == @var{e_k}, but such array can't
store any data.  It is also allowed to have zero-dimensional array,
that can store a single data.).
The shape itself is a [ @var{D} x 2 ] array, where @var{D} is the
dimension of the array which the shape represents.
@c JP
@var{N}次元の配列の各エレメントは@code{N}個の整数のインデックス
@code{[ @var{i_0} @var{i_1} @dots{} @var{i_N-1} ]}でアクセスされます。
配列は、各次元のインデックスの下限@var{s_k}および上限@var{e_k}を決める
@var{shape}を持っています。ここで、@var{s_k} <= @var{e_k}であり、
@var{k}次元目のインデックス@var{i_k}は
@var{s_k} <= @var{i_k} < @var{e_k} を満たすものとします。
(@var{s_k} == @var{e_k} であるような配列も作れますが、
その配列にはデータをストアすることはできません。
また、0次元の配列は作れます。それは一つだけデータを保持できます)。
Shapeはそれ自体が [ @var{D} x 2 ] の配列です。
ここで@var{D}はそのshapeが表現する配列の次元数です。
@c COMMON

@c EN
You can pass index(es) to array access primitives in a few ways;
each index can be passed as individual argument,
or can be 'packed' in a vector or one-dimensional array.
In the latter case, such a vector or an array is called an "index object".
Using a vector is efficient in Gauche when you iterate over the elements
by changing the vector elements, for it won't involve memory allocation.
@c JP
配列のプリミティブに対しインデックスを渡すにはいくつか方法があります。
各インデックスをばらばらの引数として渡すこともできますし、
ベクタや1次元の配列にパックして渡すこともできます。
後者においてインデックスがパックされたベクタや配列を「インデックスオブジェクト」
と呼ぶことがあります。Gaucheでは、配列の要素に次々とアクセスするような処理では
ベクタをインデックスオブジェクトとして使うと若干効率が良いでしょう。
@c COMMON

@c EN
Arrays can be compared by the @code{equal?} procedure.
@code{Equal?} returns @code{#t} if two arrays have the same
shape and their corresponding elements are the same
in the sense of @code{equal?}.
@c JP
配列は@code{equal?}手続きで比較することが出来ます。
二つの配列のshapeが等しく、また対応する各要素が@code{equal?}の意味で
等しい場合に二つの配列は@code{equal?}であると見なされます。
@c COMMON

@c EN
Internally, an array consists of a backing storage and a mapping procedure.
A backing storage is an object of aggregate type that can be accessed
by an integer index.  A mapping procedure takes
multi-dimensional indices (or index object) and 
returns a scalar index into the backing storage.
@c JP
内部的には、配列は1次元のインデックスでアクセスされるバッキングストレージと、
多次元のインデックスをバッキングストレージへのインデックスにマップする手続きとから
構成されています。
@c COMMON
@end deftp

@deftp {Class} <array-base>
@clindex array-base
@c EN
An abstract base class of array types, that implements generic operations
on the array.   To create an array instance,
you should use one of the following concrete array classes.
@c JP
配列に関する汎用操作を実装している、抽象ベースクラスです。
実際に配列のインスタンスを作るには、以下のいずれかの具体クラスを使って下さい。
@c COMMON
@end deftp

@deftp {Class} <array>
@deftpx {Class} <u8array>
@deftpx {Class} <s8array>
@deftpx {Class} <u16array>
@deftpx {Class} <s16array>
@deftpx {Class} <u32array>
@deftpx {Class} <s32array>
@deftpx {Class} <u64array>
@deftpx {Class} <s64array>
@deftpx {Class} <f32array>
@deftpx {Class} <f64array>
@clindex array
@clindex u8array
@clindex s8array
@clindex u16array
@clindex s16array
@clindex u32array
@clindex s32array
@clindex u64array
@clindex s64array
@clindex f32array
@clindex f64array
@c EN
Concrete array classes.  The @code{<array>} class implements srfi-25
compatible array, i.e. an array that can store any Scheme objects.
The @code{<u8array>} class through @code{<f64array>} classes uses
a @code{<u8vector} through @code{<f64vector>} as a backing stroage,
and can only store a limited range of integers or inexact real numbers,
but they are space efficient.
@c JP
具体配列クラスです。@code{<array>}クラスはsrfi-25互換の配列、
すなわち、任意のSchemeオブジェクトを格納できる配列を実装します。
@code{<u8array>}から@code{<f64array>}までは、
それぞれ@code{<u8vector>}から@code{<f64vector>}をバッキングストレージとして
用いる配列を実装し、制限された範囲の整数もしくは不正確な実数のみを
効率良く格納することができます。
@c COMMON
@end deftp


@deftp {Reader syntax} @code{#,(<array> @var{shape} @var{obj} @dots{})}
@c EN
An array is written out in this format.  (Substitute @code{<array>} for
@code{<u8array>} if the array is @code{<u8array>}, etc.)
@var{shape} is a list
of even number of integers, and each 2@var{n}-th integer
and 2@var{n}+1-th integer specifies the
inclusive lower-bound and exclusive upper-bound of @var{n}-th dimension,
respectively.  The following @var{obj} @dots{} are the values in the array
listed in row-major order.
@c JP
配列はこの形式で書き出されます。
(配列が例えば@code{<u8array>}であるなら、@code{<array>}の部分は@code{<u8array>}
となります。)
@var{shape}は偶数個の整数のリストで、
2@var{n}番目の整数が@var{n}次元目のインデックスの下限を、2@var{n}+1番目の
整数が@var{n}次元目のインデックスの上限(+1)を表します。
その後に、配列の要素がrow-majorの順で書き出されます。
@c COMMON

@c EN
When read back, this syntax is read as an array with the same shape
and content, so it is @code{equal?} to the original array.
@c JP
この構文が読み込まれると、もとの配列と@code{equal?}である配列が作成されます。
@c COMMON

@example
@c EN
; an array such that:
@c JP
; 次のような配列：
@c COMMON
;   8 3 4
;   1 5 9
;   6 7 2
#,(<array> (0 3 0 3) 8 3 4 1 5 9 6 7 2)

@c EN
; a 4x4 identity matrix
@c JP
; 4x4の単位行列
@c COMMON
#,(<array> (0 4 0 4) 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1)
@end example
@end deftp

@defun array? obj
[SRFI-25]
@c EN
Returns @code{#t} if @var{obj} is an array, @var{#f} otherwise.
It is equivalent to @code{(is-a? obj <array-base>)}.
@c JP
@var{obj}が配列であれば@var{#t}が、そうでなければ@var{#f}が返されます。
@code{(is-a? obj <array-base>)}と等価です。
@c COMMON
@end defun

@defun make-array shape &optional init
[SRFI-25]
@c EN
Creates an array of shape @var{shape}.
@var{Shape} must be a [ @var{D} x 2 ] array, and for each @var{k}
(0 <= @var{k} < @var{D}), the [ @var{k} 0 ] element must be less than or
equal to the [ @var{k} 1] element.
If @var{init} is given, all the elements are initialized by it.
Otherwise, the initial value of the elements are undefined.
@c JP
Shapeが@var{shape}である配列を作成します。
@var{Shape}は [ @var{D} x 2 ] の配列で、
0 <= @var{k} < @var{D} なる各@var{k}に対して要素 [ @var{k} 0 ] は
要素[ @var{k} 1 ]以下でなければなりません。
@var{init}が与えられた場合は、配列の各要素が@var{init}で初期化されます。
@var{init}が与えられなかった場合の配列の要素の初期値は不定です。
@c COMMON

@example
(make-array (shape 0 2 0 2 0 2) 5)
 @result{} #,(<array> (0 2 0 2 0 2) 5 5 5 5 5 5 5 5)
@end example
@end defun

@defun make-u8array shape &optional init
@defunx make-s8array shape &optional init
@findex make-u16array
@findex make-s16array
@findex make-u32array
@findex make-s32array
@findex make-u64array
@findex make-s64array
@dots{}
@end defun
@defun make-f32array shape &optional init
@defunx make-f64array shape &optional init
@c EN
Like @code{make-array}, but creates and returns an uniform numeric array.
@c JP
@code{make-array}と似ていますが、均一な数値配列を返します。
@c COMMON
@end defun

@defun shape bound @dots{}
[SRFI-25]
@c EN
Takes even number of exact integer arguments, and returns
a two-dimensional array that is suitable for representing the shape
of an array.
@c JP
偶数個の正確な整数を引数に取り、配列のshapeとして使える2次元の配列を返します。
@c COMMON

@example
(shape 0 2 1 3 3 5)
 @result{} #,(<array> (0 3 0 2) 0 2 1 3 3 5)

(shape)
 @result{} #,(<array> (0 0 0 2))
@end example
@end defun

@defun array shape init @dots{}
[SRFI-25]
@c EN
Creates an array of shape @var{shape}, initializing its elements by
@var{init} @dots{}.
@c JP
Shapeが@var{shape}であるような配列を作成し、
その要素を@var{init} @dots{}で初期化します。
@c COMMON

@example
(array (shape 0 2 1 3) 'a 'b 'c 'd)
 @result{} #,(<array> (0 2 1 3) a b c d)
@end example
@end defun

@defun array-rank array
[SRFI-25]
@c EN
Returns the number of dimensions of an array @var{array}.
@c JP
配列@var{array}の次元数を返します。
@c COMMON

@example
(array-rank (make-array (shape 0 2 0 2 0 2))) @result{} 3
(array-rank (make-array (shape))) @result{} 0
@end example
@end defun

@defun array-shape array
@c EN
Returns a shape array of @var{array}.
@c JP
配列@var{array}のshapeを表す配列を返します。
@c COMMON
@end defun

@defun array-start array dim
@defunx array-end array dim
@defunx array-length array dim
[SRFI-25+]
@c EN
@code{Array-start} returns the inclusive lower bound of index of
@var{dim}-th dimension of an array @var{array}.
@code{Array-end} returns the exclusive upper bound.
And @code{array-length} returns the difference between two.
@code{Array-start} and @code{array-end} are defined in SRFI-25.
@c JP
@code{array-start}は配列@var{array}の@var{dim}番目の次元の
インデックスの下限を返します。
@code{array-end}は上限+1を、そして@code{array-start}は両者の差を返します。
@code{array-start}と@code{array-end}はSRFI-25で定義されています。
@c COMMON

@example
(define a (make-array (shape 1 5 0 2)))

(array-start a 0)  @result{} 1
(array-end a 0)    @result{} 5
(array-length a 0) @result{} 4
(array-start a 1)  @result{} 0
(array-end a 1)    @result{} 2
(array-length a 1) @result{} 2
@end example
@end defun

@defun array-size array
@c EN
Returns the total number of elements in the array @var{array}.
@c JP
配列@var{array}の全要素数を返します。
@c COMMON

@example
(array-size (make-array (shape 5 9 1 3))) @result{} 8
(array-size (make-array (shape))) @result{} 1
(array-size (make-array (shape 0 0 0 2))) @result{} 0
@end example
@end defun

@defun array-ref array k @dots{}
@defunx array-ref array index
[SRFI-25]
@c EN
Gets the element of array @code{array}.  In the first form,
the element is specified by indices @var{k} @dots{}.
In the second form, the element is specified by an index object
@var{index}, which must be a vector or an one-dimensional array.
@c JP
配列@var{array}の要素を取り出します。最初の形式では、
要素は整数のインデックス@var{k} @dots{}で指定されます。
2番目の形式では、要素はベクタまたは1次元配列のインデックスオブジェクト@var{index}
で指定されます。
@c COMMON
@end defun

@defun array-set! array k @dots{} value
@defunx array-set! array index value
[SRFI-25]
@c EN
Sets the element of array @var{array} to @var{value}.  In the first form,
the element is specified by indices @var{k} @dots{}.
In the second form, the element is specified by an index object
@var{index}, which must be a vector or an one-dimensional array.
@c JP
配列@var{array}の要素に@var{value}をセットします。
最初の形式では、
要素は整数のインデックス@var{k} @dots{}で指定されます。
2番目の形式では、要素はベクタまたは1次元配列のインデックスオブジェクト@var{index}
で指定されます。
@c COMMON
@end defun

@defun share-array array shape proc
[SRFI-25]
@c EN
Creates and returns a new array of shape @var{shape}, that shares
the backing storage with the given array @var{array}.
The procedure @var{proc} maps the indices of the new array to
the indices to the original array, i.e. @var{proc} must be a @var{n}-ary
procedure that returns @var{m} values, where @var{n} is the dimension
of the new array and @var{m} is the one of the original array.
Furthermore, @var{proc} must be an affine function; each mapping
has to be a linear combination of input arguments plus optional constant.
(@code{Share-array} optimizes the mapping function based on the affinity
assumption, so @var{proc} won't be called every time the new array
is accessed).
@c JP
Shapeが@var{shape}であり、与えられた配列@var{array}とバッキングストレージを
共有する新しい配列を作成して返します。
@var{proc}は、新しい配列へのインデックスを古い配列へのインデックスへ
マップする手続きです。新しい配列の次元数を@var{n}、古い配列の次元数を@var{m}と
した時、@var{proc}は@var{n}個の引数を取り@var{m}個の値を返す手続きでなければ
なりません。さらに、各マッピングはaffineマッピング、すなわち、
出力は入力の線形合成(プラス定数)でなければなりません。
(@code{share-array}は@var{proc}がaffineマッピングであるという事実に基づいた
最適化を行います。新しい配列にアクセスする度に@var{proc}が呼ばれるというわけでは
ありません)。
@c COMMON
@end defun

@defun array-for-each-index array proc &optional index
@end defun

@defun shape-for-each shape proc &optional index
@end defun

@defun tabulate-array shape proc &optional index
@end defun

@defun array-retabulate! array shape proc &optional index
@defunx array-retabulate! array proc &optional index
@end defun

@defun array-map! array shape proc array0 array1 @dots{}
@defunx array-map! array proc array0 array1 @dots{}
@end defun

@defun array-map shape proc array0 array1 @dots{}
@defunx array-map proc array0 array1 @dots{}
@end defun

@defun array->vector array
@defunx array->list array
@end defun

@defun array-concatenate a b &optional dimension
@end defun

@defun array-transpose array &optional dim1 dim2
@end defun

@defun array-rotate-90 array &optional dim1 dim2
@end defun

@defun array-flip array &optional dimension
@defunx array-flip! array &optional dimension
@end defun

@defun identity-array dimension &optional class
@end defun

@defun array-inverse array
@end defun

@defun determinant array
@defunx determinant! array
@end defun

@defun array-mul a b
@end defun

@defun array-expt array pow
@end defun

@defun array-div-left a b
@defunx array-div-right a b
@end defun

@defun array-add-elements array array-or-scalar @dots{}
@defunx array-add-elements! array array-or-scalar @dots{}
@end defun

@defun array-sub-elements array array-or-scalar @dots{}
@defunx array-sub-elements! array array-or-scalar @dots{}
@defunx array-mul-elements array array-or-scalar @dots{}
@defunx array-mul-elements! array array-or-scalar @dots{}
@defunx array-div-elements array array-or-scalar @dots{}
@defunx array-div-elements! array array-or-scalar @dots{}
@end defun

@c ----------------------------------------------------------------------
@node Character code conversion, Collection framework, Arrays, Library modules - Gauche extensions
@section @code{gauche.charconv} - Character Code Conversion
@c NODE 文字コード変換, @code{gauche.charconv} - 文字コード変換

@deftp {Module} gauche.charconv
@mdindex gauche.charconv
@c EN
This module defines a set of functions that converts character encoding
schemes (CES) of the given data stream.
This module also overloads Gauche's file stream creating functions
(such as @code{open-input-file} and @code{call-with-output-file})
so that they accept @code{:encoding} keyword argument.
@c JP
与えられたデータストリームの文字エンコーディングを変換するための手続き群を提供する
モジュールです。また、このモジュールは@code{open-input-file}や
@code{call-with-output-file}等のファイルストリームを作成する手続きを
置き換え、@code{:encoding} キーワード引数を認識するようにします。
@c COMMON

@c EN
As of release 0.5.6, Gauche natively supports conversions between
typical Japanese character encodings: ISO2022JP, ISO2022JP-3,
EUC-JP (EUC-JISX0213), Shift_JISX0213, UTF-8 (Unicode 3.2).
Conversions between other encodings are handled by @code{iconv(3)}.
@xref{Supported character encoding schemes}, for details.
@c JP
リリース0.5.6より、Gaucheは日本語の主要エンコーディング
(ISO2022JP, ISO2022JP-3, EUC-JP (EUC-JISX0213), Shift_JIS (Shift_JISX0213), 
UTF-8 (Unicode 3.2))間の変換を自前で持つようになりました。
上記以外のコードとの変換は@code{iconv(3)}を利用します。
サポートされるコーディングシステムに関する詳細は
@ref{Supported character encoding schemes}を参照して下さい。
@c COMMON
@end deftp

@menu
* Supported character encoding schemes::  
* Autodetecting the encoding scheme::  
* Conversion ports::            
* Extended port procedures::    
@end menu

@node Supported character encoding schemes, Autodetecting the encoding scheme, Character code conversion, Character code conversion
@subsection Supported character encoding schemes
@c NODE サポートされる文字エンコーディング

@c EN
A CES is represented by its name as a string or a symbol.
Case is ignored.  There may be several aliases defined for a single encoding.
@c JP
CESの名前は文字列またはシンボルで指定します。大文字小文字の違いは無視されます。
同じCESにいくつかの別名がついていることがあります。
@c COMMON

@c EN
A CES name "none" is special.  When Gauche's native encoding is @code{none},
Gauche just treats a string as a byte sequence, and it's up to the application
to interpret the sequence in an appropriate encoding.  So, conversion
to and from CES "none" does nothing.
@c JP
CES名 "none" は特殊です。Gaucheのネイティブエンコーディングが@code{none}の
場合、Gaucheは文字列を単なるバイト列として扱い、そのエンコーディングの解釈は
アプリケーションに任されます。したがって、CES "none" への変換、および "none"
からの変換は「何もしない」変換として扱われます。
@c COMMON

@c EN
You can check whether the specific conversion is supported on
your system or not, by the following function.
@c JP
特定の変換がシステムでサポートされているかどうかは次の手続きで調べることができます。
@c COMMON

@defun ces-conversion-supported? from-ces to-ces
@c EN
Returns @code{#t} if conversion from the character encoding scheme
(CES) @var{from-ces} to @var{to-ces} is supported in this system.

Note that this procedure may return true even if system only supports
partial conversion between @var{from-ces} and @var{to-ces}.
In such case, actual conversion might lose information by coercing
characters in @var{from-ces} which are not supported in @var{to-ces}.
(For example, conversion from Unicode to EUC-JP is "supported",
although Unicode has characters that are not in EUC-JP).

Also note that this procedure always returns @code{#t} 
if @var{from-ces} and/or @var{to-ces} is "none",
for conversion to/from CES "none" always succeeds (in fact, it does nothing).

@example
;; see if you can convert the internal encoding to EUC-JP
(ces-conversion-supported? (gauche-character-encoding) "euc-jp")
@end example
@c JP
CES @var{from-ces}から@var{to-ces}への変換がサポートされていれば@code{#t}を、
そうでなければ@code{#f}を返します。

システムが@var{from-ces}から@var{to-ces}への変換を部分的にしか
サポートしていない場合でもこの手続きは@code{#t}を返すことに注意して下さい。
そのような場合、実際の変換作業は@var{from-ces}にあって@var{to-ces}にない
コードを置換文字に置き換える等で情報を失うかもしれません
(例えば、UnicodeからEUC-JPへの変換はサポートされていますが、
UnicodeにはEUC-JPにない文字も含まれています)。

@var{from-ces}か@var{to-ces}が "none" ならばこの手続きは常に@code{#t}を
返します。なぜならそのような変換は常に成功するからです(何も変換しないわけですが)。

@example
;; 内部エンコーディングからEUC-JPに変換できるか?
(ces-conversion-supported? (gauche-character-encoding) "euc-jp")
@end example
@c COMMON
@end defun

@c EN
Also there are two useful procedures to deal with CES names.
@c JP
また、CESを扱う二つの便利な手続きが用意されています。
@c COMMON

@defun ces-equivalent? ces-a ces-b &optional unknown-value
@c EN
Returns true if two CESes @var{ces-a} and @var{ces-b} are equivalent
to the knowledge of the system.  Returns false if they are not.
If the system doesn't know about equivalency, @var{unknown-value}
is returned, whose default is @code{#f}.

CES "none" works like a wild card; it is "equivalent" to any CES.
(Thus, @code{ces-equivalent?} is not transitive.  
The intended use of @code{ces-equivalent?}
is to compare two given CES names and see if conversion is required or not).
@c JP
CES @var{ces-a}と@var{ces-b}がシステムの知る限りで等価だった場合に
@code{#t}を、等価でない場合に@code{#f}を返します。
システムがその等価性を判断出来ない場合は@var{unknown-value}に与えられた
値を返します。そのデフォルトは@code{#f}です。

CES名 "none" はワイルドカードのように動作します。それはどんなCESとも
等価と見倣されます。(従って、@code{ces-equivalent?} は遷移的ではありません。
この手続きは、二つのCESを知った時に相互の変換が
必要かどうかを判断するためのものです)。
@c COMMON

@example
(ces-equivalent? 'eucjp "EUC-JP")            @result{} #t
(ces-equivalent? 'shift_jis "EUC-JP")        @result{} #f
(ces-equivalent? "NoSuchEncoding" 'utf-8 '?) @result{} ?
@end example
@end defun

@defun ces-upper-compatible? ces-a ces-b &optional unknown-value
@c EN
Returns true if a string encoded in CES @var{ces-b} can also
be regarded as a string encoded in @var{ces-a} without conversion,
to the knowledge of the system.  
Returns false if not.  Returns @var{unknown-value}
if the system can't determine which is the case.

Like @code{ces-equivalent?}, CES "none" works like a wildcard.
It is upper-compatible to any CES, and any CES is upper-compatible to
"none".
@c JP
CES @var{ces-b}でエンコードされた文字列が、システムの知る限りで
変換無しに@var{ces-a}でエンコードされたものと見倣せる場合に@code{#t}を
返します。見倣せない場合は@var{#f}を返します。
システムが判断できない場合は@var{unknown-value}に与えられた
値を返します。そのデフォルトは@code{#f}です。

@code{ces-equivalent?}と同様に、CES名 "none" はワイルドカードとして
働きます。@var{ces-a} か @var{ces-b} が "none" であれば、
常に@code{#t}が返されます。
@c COMMON

@example
(ces-upper-compatible? "eucjp" "ASCII")             @result{} #t
(ces-upper-compatible? "eucjp" "utf-8")             @result{} #f
(ces-upper-compatible? "utf-8" "NoSuchEncoding" '?) @result{} ?
@end example
@end defun

@c EN
Conversion between common japanese CESes (EUC_JP, Shift JIS, UTF-8
and ISO2022-JP) of the character set JIS X 0201 and JIS X 0213
is handled by Gauche's built-in algorithm (see below for details).
When other CES name is given, Gauche uses
@code{iconv(3)} if it is linked.
@c JP
日本語の文字セットJIS X 0201及びJIS X 0213のエンコーディング
(EUC_JP、Shift JIS、UTF-8及びISO2022-JP) 間の変換に関しては、
Gaucheが内部に変換アルゴリズムを持っています (詳細は下の注記を参照)。
それ以外のCESに関しては、リンクされていればGaucheは@code{iconv(3)}を用いて
変換を行います。
@c COMMON

@c EN
When Gauche's conversion routine encounters a character that can't
be mapped, it replaces the character for "geta mark" (U+3013)
if it's a multibyte character in the input encoding, or for '?' if it's
a singlebyte character in the input encoding.
If that happens in iconv, handling of such character depends
on iconv implementation (glibc implementation returns an error).
@c JP
出力CESへマップ不可能な入力文字に出会った場合、Gaucheの変換ルーチンは
その文字が入力CESでマルチバイトである場合はgeta mark '〓' (U+3013) に、
入力CESでシングルバイトである場合は '?' に置換します。
iconvによる変換でマップ不可能な文字に出会った場合の処理はiconvの実装に
依存します(例えばglibcではエラーとなります)。
@c COMMON

@c EN
If the conversion routine encounters an input sequence that
is illegal in the input CES, an error is signalled.
@c JP
変換ルーチンが、入力CESとして不正な入力文字列に出会った場合は
エラーが報告されます。
@c COMMON

@c EN
@strong{Details of Gauche's native conversion algorithm:}
Between EUC_JP, Shift JIS and ISO2022JP, Gauche uses arithmetic
conversion whenever possible.  This even maps the undefined codepoint
properly.  Between Unicode (UTF-8) and EUC_JP, Gauche uses lookup tables.
Between Unicode and Shift JIS or ISO2022JP, Gauche converts the
input CES to EUC_JP, then convert it to the output CES.
If the same CES is specified for input and output, Gauche's conversion
routine just copies input characters to output characters, without 
checking the validity of the encodings.
@c JP
@strong{Gaucheの内部変換アルゴリズムの詳細:}
EUC_JP、Shift JIS、及びISO2022JP間の変換は可能な限り計算で行います。
文字が未定義のコードポイントも計算式に従って変換されます。
Unicode(UTF-8)とEUC_JP間の変換はテーブルルックアップによって行われます。
UnicodeとShift JISまたはISO2022JP間の変換は、入力CESを一度EUC_JPに
変換し、それを出力CESに変換することによって行います。
入力と出力のCESがGaucheの内部アルゴリズムがサポートする範囲で等しかった場合、
Gaucheの変換ルーチンはエンコーディングの正当性はチェックせず、
単に入力を出力にコピーします。
@c COMMON

@table @code
@item EUC_JP, EUCJP, EUCJ, EUC_JISX0213
@c EN
Covers ASCII, JIS X 0201 kana, JIS X 0212 and JIS X 0213 character sets.
JIS X 0212 character set is supported merely because it uses
the code region JIS X 0213 doesn't use, and JIS X 0212 characters
are not converted properly to Shift JIS and UTF-8.
Use JIS X 0213.
@c JP
ASCII, JIS X 0201カナ、JIS X 0212、及びJIS X 0213文字セットをカバーします。
JIS X 0212は、単にJIS X 0213と重ならないコードを使っているためにサポート
されていますが、他のCESへの変換は行われないので注意して下さい。
なるべくJIS X 0213の使用をおすすめします。
@c COMMON

@item SHIFT_JIS, SHIFTJIS, SJIS
@c EN
Covers Shift_JISX0213, except that 0x5c and 0x7e is mapped to ASCII
character set (REVERSE SOLIDUS and TILDE),
instead of JIS X 0201 Roman (YEN SIGN and OVERLINE).
@c JP
Shift_JISX0213をカバーします。但し、0x5cと0x7eに関しては
JIS X 0201 Roman (YEN SIGNとOVERLINE) ではなく
ASCII (REVERSE SOLIDUSとTILDE) にマップされます。
@c COMMON

@item UTF-8, UTF8
@c EN
Unicode 3.2.  Note that some JIS X 0213 characters are mapped to Extension B
(U+20000 and up).
Some JIS X 0213 characters are mapped to two
unicode characters (one base character plus a combining character).
@c JP
Unicode 3.2です。JIS X 0213中の文字のいくつかはExtension B (U+20000〜)
にマップされます。JIS X 0213中の他の文字のいくつかは2つのUnicode文字
(base character + combining character)にマップされます。
@c COMMON

@item ISO2022JP, CSISO2022JP, ISO2022JP-1, ISO2022JP-2, ISO2022JP-3
@c EN
These encodings differ a bit
(except ISO2022JP and CSISO2022JP, which are synonyms), but
Gauche handles them same.  If one of these CES is specified as input,
Gauche recognizes escape sequences of any of CES.
ISO2022JP-2 defines several non-Japanese escape sequences, and
they are recognized by Gauche, but mapped to substitution character
('?' or geta mark).
@c JP
これらのエンコーディングは、CSISO2022JPがISO2022JPのエイリアスであることを除き
異なるエスケープシーケンスを使いますが、Gaucheの中では同じルーチンで処理されます。
これらのエンコーディングのいずれかが入力CESに指定された場合、
Gaucheは全てのバリエーションのエスケープシーケンスを認識します。
但し、ISO2022JP-2に定義された日本語以外の言語のエスケープシーケンスに関しては、
Gaucheはエスケープシーケンスの認識だけを行い、
文字は'?'あるいは'〓' に置換します。
@c COMMON

@c EN
For output, Gauche assumes ISO2022JP first, and uses ISO2022JP-1
escape sequence to put JIS X 0212 character, or uses ISO2022JP-3
escape sequence to put JIS X 0213 plane 2 character.
Thus, if the string contains only JIS X 0208 characters, 
the output is compatible to ISO2022JP.
Precisely speaking, JIS X 0213 specifies some characters in JIS X 0208
codepoint that shouldn't be mixed with JIS X 0208 characters;
Gauche output those characters as JIS X 0208 for compatibility.
(This is the same policy as Emacs-Mule's iso2022jp-3-compatible mode).
@c JP
出力に関してはGaucheは出来る限りISO2022JPでエンコードし、
JIS X 0212文字に出会ったらISO2022JP-1のエスケープシーケンスを、
JIS X 0213の第2面の文字に出会ったらISO2022JP-3のエスケープシーケンスを
用います。したがって、文字列がJIS X 0208の範囲だけで構成されていた場合は
出力はISO2022JP互換となります。
厳密には、JIS X 0213では包摂基準の変更により、
「JIS X 0208と同じコードポイントを用いるがJIS X 0208のエスケープシーケンスを
使ってはいけない文字」というのが定義されています。
Gaucheでは互換性のため、これらの文字もJIS X 0208のエスケープシーケンスを
用いてエンコードします (これは、Emacs-Muleにおけるiso2022jp-3-compatible
モードと同じ方針です)。
@c COMMON
@end table

@node Autodetecting the encoding scheme, Conversion ports, Supported character encoding schemes, Character code conversion
@subsection Autodetecting the encoding scheme
@c NODE 文字エンコーディングの自動判定

@c EN
There are cases that you don't know the CES of the input, but
you know it is one of several possible encodings.
The charconv module has a mechanism
to guess the input encoding.  There can be multiple algorithms,
and each algorithm has the name.  Right now, there's only one
algorithm implemented:
@c JP
しばしば、入力のCESが未知であり、可能性のあるいくつかの候補から入力のCESを
推測しなければならない場合があります。推測するアルゴリズムはいくつも考えられるので、
それぞれに名前がついています。今のところ、一つのアルゴリズムしか実装されていません。
@c COMMON
@table @code
@item "*JP"
@c EN
To guess the character encoding from japanese text, among either
ISO2022-JP(-1,2,3), EUCJP, SHIFT_JIS or UTF-8.
@c JP
日本語のテキストのCESを、ISO2022-JP(-1,2,3), EUCJP, SHIFT_JIS または UTF-8の
いずれかであるとして推測する。
@c COMMON
@end table

@c EN
This name can be used in place of CES name for some conversion functions.
@c JP
このアルゴリズム名は、いくつかの変換関数においてCES名の代わりに使うことができます。
@c COMMON


@defun ces-guess-from-string string scheme
@c EN
Guesses the CES of @var{string} by the character guessing scheme
@var{scheme} (e.g. "*JP").  Returns CES name that can be used
by other charconv functions.   It may return @code{#f} if the
guessing scheme finds no possible encoding in @var{string}.
Note that if there may be more than one possible encoding in
@var{string}, the guessing scheme returns one of them,
usually in favor of the native CES.
@c JP
文字列@var{string}のCESを、CES推測アルゴリズム@var{scheme} ("*JP"など)
を使って推測し、結果のCES名を返します。もしどのCESにも該当しないデータが
含まれていれば@code{#f}が返されます。複数のCESが可能である場合、
ネイティブエンコーディングが含まれていればそれを、
そうでなければ可能なCESからどれかひとつが選んで返されます。
@c COMMON
@end defun


@node Conversion ports, Extended port procedures, Autodetecting the encoding scheme, Character code conversion
@subsection Conversion ports
@c NODE 変換ポート

@defun open-input-conversion-port source from-code &keyword to-code buffer-size owner?
@c EN
Takes an input port @var{source}, which feeds characters
encoded in @var{from-code}, and returns another input port,
from which you can read characters encoded in @var{to-code}.
@c JP
文字が符号化方法@var{from-code}で符号化されているデータを読み出せる
入力ポート@var{source}を取り、符号化方法@var{to-code}で符号化されたデータを
読み出せるポートを作成して返します。
@c COMMON

@c EN
If @var{to-code} is omitted, the native CES is assumed.
@c JP
@var{to-code}が省略された場合はネイティブのCESと見なされます。
@c COMMON

@c EN
@var{buffer-size} is used to allocate internal buffer size for
conversion.  The default size is about 1 kilobytes and it's suitable
for typical cases.
@c JP
@var{buffer-size}は変換のための内部バッファのサイズを指定します。
省略時のサイズは1Kバイト程で、通常の使用には問題ないサイズです。
@c COMMON

@c EN
If you don't know the @var{source}'s CES, you can specify
CES guessing scheme, such as @code{"*JP"}, in place of @var{from-code}.
The conversion port tries to guess the encoding, by prefetching
the data from @var{source} up to the buffer size.  It signals an error
if the code guessing routine finds no appropriate CES.
If the guessing routine finds ambiguous input, however, it silently
assume one of possible CES's, in favor of the native CES.
Hence it is possible that the guessing is wrong if the buffer
size is too small.  The default size is usually enough for most
text documents, but it may fail if the large text contains mostly ASCII
characters and multibyte characters appear only at the very end of
the document.
To be sure for the worst case,
you have to specify the buffer size large enough to
hold entire text.
@c JP
入力のCESが不明な場合、@code{"*JP"}などのCES推測アルゴリズム名を@var{from-code}
として指定することができます。変換ポートは最高でバッファサイズまでのデータを先読みし、
CESを推測しようとします。そのアルゴリズムで推測されるどのCESにも該当しないデータが
検出された場合はエラーが報告されます。もし複数のCESが可能であるようなデータであった
場合は、Gaucheのネイティブエンコーディングが可能なCESに含まれていればそれが選ばれ、
そうでなければいずれかのCESが適当に選ばれます。従って、バッファサイズが小さすぎると
誤った判定をする可能性が高くなります。大抵のテキストドキュメントに対して、
既定のバッファサイズは十分ですが、大きなテキストのほとんどがASCII文字で最後だけ
マルチバイト文字が現われるようなテキストでは誤判定の可能性があります。
最悪の場合でも結果を保証するには、テキスト全体が格納できるバッファサイズを指定すると
良いでしょう。
@c COMMON

@c EN
By default, @code{open-input-conversion-port} leaves @var{source} open.
If you specify true value to @var{owner?}, the function closes
@var{source} after it reads EOF from the port.
@c JP
通常、@code{open-input-conversion-port}は変換が全て終了した後でも@var{source}
はオープンしたままにします。キーワード引数@var{owner?}に真の値を指定すると、
EOFが読まれた後で@var{source}はクローズされます。
@c COMMON

@c EN
For example, the following code copies a file @file{unknown.txt} to a file
@file{eucjp.txt}, converting unknown japanese CES to EUC-JP.
@c JP
例を示しましょう。以下のコードは未知のCES(但しEUC-JP, SJIS, ISO2022-JP, UTF8の
いずれかであることは分かっている)で書かれたテキストファイル@file{unknown.txt}を
読みだし、文字エンコーディングをEUC-JPに変換して@file{eucjp.txt}に書き出します。
@c COMMON
@example
(call-with-output-file "eucjp.txt"
  (lambda (out)
    (copy-port (open-input-conversion-port
                 (open-input-file "unknown.txt")
                 "*jp"             ;@r{guess code}
                 :to-code "eucjp"
                 :owner? #t)       ;@r{close unknown.txt afterwards}
               out)))
@end example
@end defun


@defun open-output-conversion-port sink to-code &keyword from-code buffer-size owner?
@c EN
Creates and returns an output port that converts
given characters from @var{from-code} to @var{to-code}
and feed to an output port @var{sink}.
If @var{from-code} is omitted, the native CES is assumed.
You can't specify a character guessing scheme (such as "*JP") to
neither @var{from-code} nor @var{to-code}.
@c JP
文字のエンコーディングを@var{from-code}から@code{to-code}に変換して
出力ポート@var{sink}に書き出すような出力変換ポートを作成して返します。
@var{to-code}が省略された場合はネイティブのCESと見なされます。
@var{from-code}にも@var{to-code}にも、CES推測アルゴリズム名を
使用することはできません。
@c COMMON

@c EN
@var{buffer-size} specifies the size of internal conversion buffer.
The characters put to the returned port may stay in the buffer,
until the port is explicity flushed (by @code{flush}) or
the port is closed.
@c JP
@var{buffer-size}は内部で変換に使われるバッファサイズを指定します。
出力変換ポートに書き出された文字は、@code{flush}を使って明示的に
フラッシュするか出力変換ポートが閉じられるまで、バッファ内に残っている可能性があります。
@c COMMON

@c EN
By default, the returned port doesn't closes @var{sink} when
itself is closed.  If a keyword argument @var{owner?} is provided
and true, however, it closes @var{sink} when it is closed.
@c JP
通常、出力変換ポートがクローズされても@var{sink}はクローズされません。
@var{owner?}に真の値を与えれば、出力変換ポートのクローズ時に@var{sink}を
クローズするようにできます。
@c COMMON
@end defun

@defun ces-convert string from-code &optional to-code
@c EN
Convert @var{string}'s character encoding from @var{from-code}
to @var{to-code}, and returns the converted string.
The returned string may be a byte-string if @var{to-code}
is different from the native CES.
@c JP
@var{from-code}でエンコーディングされた文字列@var{string}を
@var{to-code}でエンコーディングされた文字列に変換します。
@var{to-code}がネイティブエンコーディングで無い場合、返される文字列は
バイト文字列(不完全な文字列)であるかもしれません。
@c COMMON

@c EN
@var{from-code} can be a name of character guessing scheme
(e.g. "*JP").  when @var{to-code} is omitted, the native CES is
assumed.
@c JP
@var{from-code}にはCES推測アルゴリズム名("*JP"など)を与えることができます。
@var{to-code}が省略された場合はネイティブエンコーディングと見なされます。
@c COMMON
@end defun

@defun call-with-input-conversion iport proc &keyword encoding conversion-buffer-size
@defunx call-with-output-conversion oport proc &keyword encoding conversion-buffer-size
@c EN
These procedures can be used to perform character I/O with
different encoding temporary from the original port's encoding.

@code{call-with-input-conversion} takes an input port @var{iport}
which uses the character encoding @var{encoding}, and
calls @var{proc} with one argument, a conversion input port. 
From the port, @var{proc} can read characters in
Gauche's internal encoding. 
Note that once @var{proc} is called, it has to read all the 
characters until EOF; see the note below.

@code{call-with-output-conversion} takes an output port @var{oport}
which expects the character encoding @var{encoding}, and
calls @var{proc} with one argument,
a temporary conversion output port.  
To the port, @var{proc} can write characters in
Gauche's internal encoding.  
When @var{proc} returns, or it exits with an error, 
the temporary conversion output port is flushed and closed.  
The caller of @code{call-with-output-conversion}
can continue to use @var{oport} with original encoding afterwards.

Both procedure returns the value(s) that @var{proc} returns.
The default value of @var{encoding} is Gauche's internal
encoding.  Those procedures don't create a conversion port
when it is not necessary.   If @var{conversion-buffer-size} is given, 
it is used as the @var{buffer-size} argument when the conversion
port is open.

You shouldn't use @var{iport}/@var{oport} directly
while @var{proc} is active---character encoding is a
stateful process, and mixing I/O from/to the conversion port and
the underlying port will screw up the state.

@emph{Note:} for the @code{call-with-input-conversion}, you can't
use @var{iport} again unless @var{proc} reads EOF from it.
It's because a conversion port needs to buffer the input, and
there's no way to undo the buffered input to @var{iport}
when @var{proc} returns.
@c JP
この2つの手続きを使うと、元のポートのエンコーディングとは異る一時的な
エンコーディングをもつ文字I/Oを行うことが可能です。

@code{call-with-input-conversion} は、文字エンコード@var{encoding} を
もつ入力ポート @var{iport} をとり、@var{proc}を一つの引数、すなわち、
変換入力ポートとともに呼びだします。このポートから、@var{proc} は文字を
Gauche の内部エンコーディングで読み込むことができます。いったん、
@var{proc}が呼ばれたら、EOFまでのすべての文字を読み込まなくてはなりません。
後述の注意を参照してください。

@code{call-with-output-conversion} は、文字エンコーディング @var{encoding}
を期待する出力ポート @var{oport} をとり、@var{proc}を一つの引数、すなわち、
一時的な変換出力ポートとともに呼びだします。このポートへ、@var{proc}は
Gauche の内部エンコーディングをもつ文字を書き込むことができます。
@var{proc} が戻るか、エラーで抜けると、この一時的な変換出力ポートは
フラッシュされて、クローズされます。@code{call-with-output-conversion}
の呼出し側は、その後、元のエンコーディングのポート@var{oport}を使い
続けること可能です。

どちらの手続きも @var{proc} が返す値を返します。@var{encoding}
のデフォルト値は Gauche の内部エンコーディングです。この2つの手続きは
必要がなければ、変換ポートを作成しません。もし
@var{conversion-buffer-size} が与えられていれば、変換ポートがオープン
されるときに、@var{buffer-size} 引数として使われます。

@var{proc} がアクティブであるあいだは、@var{iport}/@var{oport} を直接
使うべきではありません。文字のエンコーディングはステートフルなプロセスで
変換ポート(から/へ)の入出力を混在させると元にあるポートの状態がおかしく
なってしまいます。

@emph{注意:} @code{call-with-input-conversion} については、
@var{proc} が EOF を読むまでは、@var{iport} を再度利用することはできません。
これは、変換ポートがバッファを必要とし、@var{proc} がもどったときに
@var{iport}へのバッファ付き入力をアンドゥする方法がないからです。
@c COMMON
@end defun

@defun with-input-conversion iport thunk &keyword encoding conversion-buffer-size
@defunx with-output-conversion oport thunk &keyword encoding conversion-buffer-size
@c EN
Similar to @code{call-with-*-conversion},
but these procedures call @var{thunk} without arguments,
while the conversion port is set as the current input or output port,
respectively.
The meaning of keyword arguments are the same as @code{call-with-*-conversion}.
@c JP
@code{call-with-*-conversion} と似ていますが、この2つの手続きは、
@var{thunk} を引数なしで呼びます、また、変換ポートはそれぞれ標準入力、標準
出力のポートにセットされます。
キーワード引数の意味は @code{call-with-*-conversion} と同じです。
@c COMMON
@end defun

@defun wrap-with-input-conversion port from-code &keyword to-code owner? buffer-size
@defunx wrap-with-output-conversion port to-code &keyword from-code owner? buffer-size
@c EN
Convenient procedures to avoid adding unnecessary conversion port.
Each procedure works like @code{open-input-conversion-port}
and @code{open-output-conversion-port}, respectively,
except if system knows no conversoin is needed,
no conversion port is created and @var{port} is returned as is.

When a conversion port is created, @var{port} is always owned by the port.
When you want to close the port, always close the port returned
by @code{wrap-with-*-conversion}, instead the original @var{port}.
If you close the original @var{port} first, the pending conversion
won't be flushed.  (Some conversion requires trailing sequence that
is generated only when the conversion port is closing, so simply
calling @code{flush} isn't enough.)

The @var{buffer-size} argument is passed to 
the @code{open-*-conversion-port}.
@c JP
不要な変換ポートを作らないようにする便利な手続きです。
各手続きはそれぞれ@code{open-input-conversion-port}と
@code{open-output-conversion-port}のように動作します。
但し、指定されたCES間の変換が必要でないとシステムが知っている場合は、
変換ポートは作られず、@var{port}がそのまま返されます。

変換ポートが作られた場合、@var{port}は常に変換ポートに所有されます
(@code{:owner #t}となる)。ポートを閉じる場合は@var{port}ではなく
常に@code{wrap-with-*-conversion}が返したポートを閉じるようにして下さい。
元の@var{port}が先に閉じられた場合、変換中の結果が書き出されない可能性があります。
(変換によっては、ポートが閉じられる時点で終了シーケンスを書き出すものがあるので、
単にポートを@code{flush}するだけでは不十分です)。

@code{:buffer-size} 引数はそのまま
変換ポート作成手続きに渡されます。
@c COMMON
@end defun

@node Extended port procedures,  , Conversion ports, Character code conversion
@subsection Extended port procedures
@c NODE 拡張されたポート手続き


@defun open-input-file filename &keyword encoding conversion-buffer-size @dots{}
@defunx call-with-input-file filename proc &keyword encoding conversion-buffer-size @dots{}
@defunx with-input-from-file filename thunk &keyword encoding conversion-buffer-size @dots{}
@defunx open-output-file filename &keyword encoding conversion-buffer-size @dots{}
@defunx call-with-output-file filename proc &keyword encoding conversion-buffer-size @dots{}
@defunx with-output-to-file filename thunk &keyword encoding conversion-buffer-size @dots{}
@c EN
These Gauche built-in procedures are extended to accept two extra
keyword arguments, @var{encoding} and @var{conversion-buffer-size}.
(@xref{File ports}, for their default behavior).

You can give a CES of the file @var{filename} to @var{encoding},
and the port automatically converts the file CES to the Gauche's
native CES.  You can use a CES guessing algorithm name for
input file port.

The keyword argument @var{conversion-buffer-size} has the same
meaning as @var{buffer-size} of @code{open-input-conversion-port}.
@c JP
これらのGauche組み込みの手続きは、@var{encoding}と@var{conversion-buffer-size}
という二つの追加のキーワード引数を取るように拡張されます。
(これらの手続きの元の動作については@ref{File ports}を参照して下さい)。

@var{filename}の文字エンコーディング名を@var{encoding}に渡すと、
ファイルを読む際に@var{encoding}からGaucheの内部エンコーディングへの変換が
行われます。入力の場合は@var{encoding}にCES推測アルゴリズム名を渡すこともできます。

@var{conversion-buffer-size}は@code{open-input-conversion-port}
における@var{buffer-size}と同じ意味を持ちます。
@c COMMON
@end defun



@c ----------------------------------------------------------------------
@node Collection framework, Configuration parameters, Character code conversion, Library modules - Gauche extensions
@section @code{gauche.collection} - Collection framework
@c NODE コレクションフレームワーク, @code{gauche.collection} - コレクションフレームワーク

@deftp {Module} gauche.collection
@mdindex gauche.collection
@c EN
This module provides a set of generic functions (GFs) that iterate over
various collections.   The Scheme standard [R5RS] has some iterative
primitives such as @code{map} and @code{for-each},
and SRFI-1 (@xref{List library} adds a rich set of such functions,
but they work only on lists.

Using the method dispatch of the object system, this module
efficiently extends those
functions for other collection classes such as vectors and hash tables.
It also provides a simple way for user-defined class to adapt
those opertaions.
So far, the following operations are defined.
@c JP
このモジュールは、様々なコレクションに対して繰り返し処理を行う総称関数を提供します。
Schemeの規格は@code{map}や@code{for-each}などの繰り返し手続きを定義しており、
またSRFI-1(@ref{List library}参照)は更に数多くの繰り返し手続きを提供しますが、
それらはリストに対してしか動作しません。

このモジュールはオブジェクトシステムのメソッドディスパッチを利用して、
これらの手続きをベクタやハッシュテーブルのような一般のコレクションタイプに対しても
効率良く動作するように拡張します。また、ユーザ定義のクラスにこれらの操作を実装するための
簡単な方法も提供します。今のところ、次のような総称関数が提供されています。
@c COMMON

@table @asis
@c EN
@item Mapping
@c JP
@item マッピング
@c COMMON
@code{fold}, @code{fold2}, @code{fold3}, 
@code{map}, @code{map-to}, @code{map-accumf, }@code{for-each}
@c EN
@item Selection and searching
@c JP
@item 選択と探索
@c COMMON
@code{find}, @code{filter}, @code{filter-to},
@code{remove}, @code{remove-to}, @code{partition}, @code{partition-to}
@code{group-collection}
@c EN
@item Conversion
@c JP
@item 変換
@c COMMON
@code{coerce-to}
@c EN
@item Miscellaneous
@c JP
@item その他
@c COMMON
@code{size-of}, @code{lazy-size-of}
@c EN
@item Fundamental iterator creator
@c JP
@item 基礎的なイテレータ構築メソッド
@c COMMON
@code{call-with-iterator}, @code{call-with-builder},
@code{with-iterator}, @code{with-builder}, @code{call-with-iterators}.
@end table

@c EN
Those operations work on @emph{collections} and its subclass,
@emph{sequences}.  A collection is a certain form of a set
of objects that you can traverse all the object in it in a certain way.
A sequence is a collection that all its elements are ordered, so that
you can retrieve its element by index.
@c JP
これらの操作は、@emph{コレクション}とそのサブクラスである
@emph{シーケンス}に対して動作します。コレクションは、その要素を全て
訪れる方法が用意されているようなオブジェクトの集合です。
シーケンスは、要素間に全順序関係が定義されておりインデックスで要素を取り出すことが
できるようなコレクションです。
@c COMMON

@c EN
The following Gauche built-in objects are treated as collections and/or
sequences.
@c JP
次にあげるGaucheの組み込みオブジェクトはシーケンスあるいはコレクションとして動作します。
@c COMMON
@table @code
@item <list>
@c EN
A sequence.
@c JP
シーケンス
@c COMMON
@item <vector>
@c EN
A sequence.
@c JP
シーケンス
@c COMMON
@item <string>
@c EN
A sequence (of characters)
@c JP
文字のシーケンス
@c COMMON
@item <hash-table>
@c EN
A collection.  Each element is a pair of a key and a value.
@c JP
コレクション。各要素はキーと値のペア。
@c COMMON
@item <s8vector>, <u8vector>, @dots{} <f64vector>
@c EN
A sequence (methods defined in @code{srfi-4} module,
@xref{Homogeneous vectors}).
@c JP
シーケンス。メソッドは@code{srfi-4}モジュール内で定義されます。
@ref{Homogeneous vectors}参照。
@c COMMON
@end table

@c EN
@xref{Sequence framework}, for it adds more sequence specific
methods.
@c JP
@ref{Sequence framework}も参照してください。シーケンス特有のメソッドが
追加されます。
@c COMMON

@c EN
The methods that needs to return a set of objects, i.e. 
@code{map}, @code{filter}, @code{remove} and @code{partition}.
returns a list (or lists).  The corresponding ``-to'' variant
(@code{map-to}, @code{filter-to}, @code{remove-to} and @code{partition-to}.
takes a collection class argument and returns the collection of the class.
@c JP
オブジェクトの集合を返すようなメソッド、すなわち
@code{map}、@code{filter}、@code{remove}および@code{partition}は、
リストを返します。対応する``-to''がつくメソッド
(@code{map-to}、@code{filter-to}、@code{remove-to}、@code{partition-to})
はコレクションクラスも引数に取り、そのクラスのコレクションを返します。
@c COMMON
@end deftp

@menu
* Mapping over collection::     
* Selection and searching in collection::  
* Miscellaneous operations on collection::  
* Fundamental iterator creators::  
* Implementing collections::    
@end menu

@node Mapping over collection, Selection and searching in collection, Collection framework, Collection framework
@subsection Mapping over collection
@c NODE コレクションに対するマッピング

@c EN
These generic functions extends the standard mapping procedures.
See also @ref{Mapping over sequences}, if you care the index
as well as elements.
@c JP
これらのジェネリックファンクションは標準のマッピング手続きを拡張します。
要素だけでなくそのインデックスも必要な場合は@ref{Mapping over sequences}を
参照して下さい。
@c COMMON

@deffn {Generic function} fold proc knil coll coll2 @dots{}
@c EN
This is a natural extension of @var{fold} in SRFI-1 (@xref{SRFI-1 Fold}).
@c JP
SRFI-1で定義される@var{fold} (@ref{SRFI-1 Fold}参照) の自然な拡張です。
@c COMMON

@c EN
For each element @var{Ei} in the collection @var{coll}, @var{proc} is
called as (@var{proc} @var{Ei} @var{Ri-1}), where @var{Ri-1} is the 
result of (@var{i}-1)-th invocation of @var{proc} for @var{i} > 0, 
and @var{R0} is @var{knil}.  Returns the last invocation of @var{proc}.
@c JP
コレクション@var{coll}の各要素@var{Ei}に対して、手続き@var{proc}が
(@var{proc} @var{Ei} @var{Ri-1}) のように呼ばれます。ここで、
@var{Ri-1} は @var{i} > 0 に対しては (@var{i}-1)番目の@var{proc}の呼び出しの
結果であり、@var{R0}は@var{knil}です。最後の@var{proc}の戻り値を返します。
@c COMMON
@example
(fold + 0 '#(1 2 3 4)) @result{} 10
(fold cons '() "abc")  @result{} (#\c #\b #\a)
@end example

@c EN
If the @var{coll} is a sequence, it is guaranteed that
the elements are traversed in order.  Otherwise, the order
of iteration is undefined.
@c JP
@var{coll}がシーケンスでもある場合、要素はシーケンスの順に@var{proc}に渡されます。
そうでなければ繰り返しの順序は未定義です。
@c COMMON

@c EN
You can fold more than one collection, although it doesn't make
much sense unless all of the collections are sequences.
Suppose @var{E(k, i)} for @var{i}-th element
of @var{k}-th collection.  @var{proc} is called as
@c JP
複数のコレクションを@code{fold}に渡すこともできます (但し、その全てがシーケンスで
なければあまり意味のある操作では無いでしょう)。
@var{k}番目のコレクションの@var{i}番目の要素を@var{E(k, i)}とするとき、
@var{proc}は以下のように呼ばれます。
@c COMMON
@example
(@var{proc} @var{E(0,i)} @var{E(1,i)} @dots{} @var{E(K-1,i)} @var{Ri-1})
@end example

@c EN
Different types of collections can be mixed together.
@c JP
異なる型のコレクションを混ぜて扱うことができます。
@c COMMON

@example
(fold acons '() "abc" '#(1 2 3))
  @result{} ((#\c 3) (#\b 2) (#\a 1))

@c EN
;; @r{calculates dot product of two vectors}
@c JP
;; @r{二つのベクタの内積を計算}
@c COMMON
(fold (lambda (a b r) (+ (* a b) r)) 0
      '#(3 5 7) '#(2 4 6))
  @result{} 68
@end example

@c EN
When more than one collection is given, @code{fold} terminates
as soon as at least one of the collections exhausted.
@c JP
複数のコレクションが与えられた場合、@code{fold}は少なくともひとつのコレクションが
終了した時点で終了します。
@c COMMON
@end deffn

@deffn {Generic function} fold2 proc knil1 knil2 coll coll2 @dots{}
@deffnx {Generic function} fold3 proc knil1 knil2 knil3 coll coll2 @dots{}
@c EN
Like @code{fold}, but they can carry two and three state values
instead of one, respectively.  The state values are
initialized by @var{knilN}.  The procedure @var{proc} is called
with each element of @var{collN}, and the state values.  It must return
two (@code{fold2}) or three (@code{fold3}) values, which will be used
as the state values of next iteration.  The values returned in the
last iteration will be the return values of @code{fold2} and @code{fold3}.
@c JP
@code{fold}と似ていますが、1つではなくそれぞれ2, 3個の状態値を
持ち回ります。状態値は@var{knilN}によって初期化されます。
手続き@var{proc}はコレクション@var{collN}の各要素値と状態値を
引数として取り、@code{fold2}の場合は2個、@code{fold3}の場合は3個の
値を返さねばなりません。返された値が次の繰り返しでの状態値として
使われます。最後に返された値が@code{fold2}, @code{fold3}の戻り値と
なります。
@c COMMON

@example
(fold2 (lambda (elt a b) (values (min elt a) (max elt b)))
       256 0 '#u8(33 12 142 1 74 98 12 5 99))
 @result{} 1 and 142  ;; find minimum and maximum values
@end example

@c EN
See also @code{map-accum} below.
@c JP
下の@code{map-accum}も参照。
@c COMMON
@end deffn


@deffn {Generic function} map proc coll coll2 @dots{}
@c EN
This extends the built-in @code{map} (@xref{Procedures}).
Apply @var{proc} for each element in the collection @var{coll}, and
returns a list of the results.
@c JP
組み込み手続き@code{map} (@ref{Procedures}参照) を拡張します。
コレクション@var{coll}の各要素に手続き@var{proc}を適用し、その結果をリストにして
返します。
@c COMMON

@c EN
If the @var{coll} is a sequence, it is guaranteed that
the elements are traversed in order.  Otherwise, the order
of iteration is undefined.
@c JP
@var{coll}がシーケンスでもある場合、要素はシーケンスの順に@var{proc}に渡されます。
そうでなければ繰り返しの順序は未定義です。
@c COMMON

@c EN
If more than one collection is passed, @var{proc} is called with
elements for each collection.  In such case, @code{map} terminates
as soon as at least one of the collection is exhausted.  Note that passing
more than one collection doesn't make much sense unless
all the collections are sequences.
@c JP
複数のコレクションが与えられた場合、@var{proc}は各コレクションからの要素を引数として
呼び出されます。@code{map}はひとつでもコレクションの最後に到達したら終了します。
複数のコレクションを渡すのは、コレクションの全てがシーケンスでないとあまり意味がないでしょう。
@c COMMON

@example
(map (lambda (x) (* x 2)) '#(1 2 3))
  @result{} #(2 4 6)

(map char-upcase "abc")
  @result{} (#\A #\B #\C)

(map + '#(1 2 3) '#(4 5 6))
  @result{} (5 7 9)
@end example

@c EN
@code{map} @emph{always} returns a list.  If you want to get the result
in a different type of collection, use @code{map-to} described below.
If you wonder why @code{(map char-upcase "abc")} doesn't return
@code{"ABC"}, read the discussion in the bottom of this subsection.
@c JP
@code{map}は常にリストを返します。別のコレクション型で結果を得たい場合は、
次に示す@code{map-to}を使って下さい。何故@code{(map char-upcase "abc")}が
@code{"ABC"}を返さないのか疑問なら、この最後にあるディスカッションを参照してください。
@c COMMON
@end deffn

@deffn {Generic function} map-to class proc coll coll2 @dots{}
@c EN
This works the same as @code{map}, except the result is returned
in a collection of class @var{class}.   @code{Class} must be a
collection class and have a builder interface
(@xref{Fundamental iterator creators}).
@c JP
@code{map}と同じように動作しますが、結果はクラス@var{class}のインスタンスとして返されます。
@var{class}はコレクションクラスでなければなりません。
また、ビルダーインタフェースを持っている必要があります
(@ref{Fundamental iterator creators}参照).
@c COMMON

@example
(map-to <vector> + '#(1 2 3) '#(4 5 6))
  @result{} #(5 7 9)

(map-to <string> char-upcase "def")
  @result{} "DEF"

(map-to <vector> char=? "bed" "pet")
  @result{} #(#f #t #f)
@end example
@end deffn

@deffn {Generic function} map-accum proc seed coll1 coll2 @dots{}
@c EN
Collects results of @var{proc} over collections, while passing
a state value.  @var{proc} is called like this:
@c JP
状態値を持ち回りながら@var{proc}のコレクションの各要素への呼び出しを集めます。
@var{proc}は次のように呼ばれます。
@c COMMON
@example
(@var{proc} @var{elt1} @var{elt2} @dots{} @var{seed})
@end example
@c EN
Where @var{elt1} @var{elt2} @dots{} are the elements of 
@var{coll1} @var{coll2} @dots{}.
It must return two values; the first value is collected into
a list (like @code{map}), while the second value is passed as
@var{seed} to the next call of @var{proc}.  
@c JP
ここで@var{elt1} @var{elt2} @dots{}は
@var{coll1} @var{coll2} @dots{}の各要素です。
@var{proc}は2つの値を返さねばなりません。最初の値が@code{map}のように
リストへと集められます。2つ目の値は次の@var{proc}の呼び出しの@var{seed}
として使われます。
@c COMMON

@c EN
When one of the collections is exhausted, @code{map-accum} returns
two values, the list of the first return values from @var{proc},
and the second return value of the last call of @var{proc}.
@c JP
いずれかのコレクションの要素を使い切った時点で、@code{map-accum}は
2つの値を返します。最初の値は@var{proc}の最初の戻り値をリストにしたもの、
2番目の値は@var{proc}の最後の呼び出しの2番目の戻り値です。
@c COMMON

@c EN
If the given collections are sequences, it is guaranteed that
@var{proc} is applied in order of the sequence.
@c JP
もし与えられたコレクションがシーケンスであった場合は、
@var{proc}はシーケンスの順序通りに適用されます。
@c COMMON

@c EN
This is similar to Haskell's @code{mapAccumL}, but note that
the order of @code{proc}'s argument and return values are
reversed.
@c JP
この手続きはHaskellの@code{mapAccumL}と似ています。但し、
@code{proc}の引数と戻り値の順が逆転していることに注意して下さい。
@c COMMON
@end deffn


@deffn {Generic function} for-each proc coll coll2 @dots{}
@c EN
Extension of built-in @code{for-each} (@xref{Procedures}).
Applies @var{proc} for each elements in the collection(s).
The result of @var{proc} is discarded.  The return value of
@code{for-each} is undefined.
@c JP
組み込み手続き@code{for-each} (@ref{Procedures}参照) を拡張します。
コレクション@var{coll}の各要素に手続き@var{proc}を適用します。
@var{proc}の結果は捨てられます。@code{for-each}の結果は未定義です。
@c COMMON

@c EN
If the @var{coll} is a sequence, it is guaranteed that
the elements are traversed in order.  Otherwise, the order
of iteration is undefined.
@c JP
@var{coll}がシーケンスでもある場合、要素はシーケンスの順に@var{proc}に渡されます。
そうでなければ繰り返しの順序は未定義です。
@c COMMON

@c EN
If more than one collection is passed, @var{proc} is called with
elements for each collection.  In such case, @code{for-each} terminates
as soon as one of the collection is exhausted.  Note that passing
more than one collection doesn't make much sense unless
all the collections are sequences.
@c JP
複数のコレクションが与えられた場合、@var{proc}は各コレクションからの要素を引数として
呼び出されます。@code{for-each}はひとつでもコレクションの最後に到達したら終了します。
複数のコレクションを渡すのは、コレクションの全てがシーケンスでないとあまり意味がないでしょう。
@c COMMON
@end deffn


@deffn {Generic Function} fold$ proc
@deffnx {Generic Function} fold$ proc knil
@deffnx {Generic Function} map$ proc
@deffnx {Generic Function} for-each$ proc
@c EN
Partial-application version of @code{fold}, @code{map} and @code{for-each}.
@c JP
@code{fold}、@code{map}、@code{for-each}の部分評価版です。
@c COMMON
@end deffn


@c EN
@emph{Discussion:}  It is debatable what type of collection @code{map}
should return when it operates on the collections other than lists.
It may seem more ``natural'' if @code{(map * '#(1 2) '#(3 4))}
returns a vector, and @code{(map char-upcase "abc")} returns a string.
@c JP
@emph{Discussion:}  @code{map}がリスト以外に対して適用されたとき、どういう
コレクション型を返すべきでしょう。
@code{(map * '#(1 2) '#(3 4))} がベクタを返し、
@code{(map char-upcase "abc")} が文字列を返すようにするほうが「自然」でしょうか。
@c COMMON

@c EN
Although such interface seems work for simple cases, it'll become
problematic for more general cases.  What type of collection should
be returned if a string and a vector are passed?  Furthermore,
some collection may only have iterator interface but no builder
interface, so that the result can't be coerced to the argument type
(suppose you're mapping over database records, for example).
And Scheme programmers are used to think @code{map} returns a list,
and the result of @code{map} are applied to the procedures that
takes list everywhere.
@c JP
そのようなインタフェースは単純な場合には動作するように思えますが、
一般的な拡張は困難です。文字列とベクタが同時に渡されたらどうします?
更に、コレクションクラスによっては繰り返しインタフェースは持っていても
ビルダーインタフェースを持っていない場合があり、結果をそのコレクションクラスとして
返せない場合もあります (データベースレコードのコレクションに対してマップする、
といった用法を考えてみて下さい)。また、Schemeプログラマは@code{map}が
リストを返すという事実に慣れ親しんでおり、既存のコードも@var{map}の戻り値を
リストを受け取る手続きに渡すことがよく行われています。
@c COMMON

@c EN
So I decided to add another method, @code{map-to}, to specify
the return type explicitly
The idea of passing the return type is taken from CommonLisp's @code{map}
function, but taking a class metaobject, @code{map-to} is much flexible
to extend using method dispatch.
This protocol (``-to'' variant takes a class metaobject
for the result collection) is used thoughout the collection framework.
@c JP
そこで、結果の型を明示的に指定する@code{map-to}という別のメソッドを定義しました。
結果の型を渡すのは、CommonLispの@code{map}関数にならっていますが、
Gaucheではクラスメタオブジェクトを渡すようにしたため、メソッドディスパッチを使って
拡張することが容易です。``-to'' のつくメソッドは結果のコレクションのクラスを
取るというインタフェースはコレクションフレームワーク中で統一的に使われています。
@c COMMON

@node Selection and searching in collection, Miscellaneous operations on collection, Mapping over collection, Collection framework
@subsection Selection and searching in collection
@c NODE コレクションからの選択と探索

@deffn {Generic function} find pred coll
@c EN
Applies @var{pred} for each element of a collection @var{coll} until
@var{pred} returns a true value.  Returns the element on which @var{pred}
returned a true value, or @code{#f} if no element satisfies @var{pred}.
@c JP
@var{pred}をコレクション@var{coll}の要素に適用してゆきます。@var{pred}が
真の値を返したらそこで打ち切り、その要素を返します。@var{pred}が真の値を返す
要素が無かった場合は@code{#f}を返します。
@c COMMON

@c EN
If @var{coll} is a sequence, it is guaranteed that @var{pred} is
applied in order.  Otherwise the order of application is undefined.
@c JP
@var{coll}がシーケンスでもある場合、要素はシーケンスの順に@var{proc}に渡されます。
そうでなければ繰り返しの順序は未定義です。
@c cOMMON

@example
(find char-upper-case? "abcDe") @result{} #\D
(find even? '#(1 3 4 6)) @result{} 4
(find even? '(1 3 5 7))  @result{} #F
@end example
@end deffn

@deffn {Generic function} filter pred coll
@c EN
Returns a list of elements of collection @var{coll} that satisfies
the predicate @var{pred}.   If the collection is a sequence,
the order is preserved in the result.
@c JP
コレクション@var{coll}中の要素のうち、述語手続き@var{pred}が真の値を返したものの
リストを返します。コレクションがシーケンスであれば、結果の要素の順序は元のシーケンスの
順序と同じになります。
@c COMMON

@example
(filter char-upper-case? "Hello, World")
  @result{} (#\H #\W)
(filter even? '#(1 2 3 4)) @result{} (2 4)
@end example
@end deffn

@deffn {Generic function} filter-to class pred coll
@c EN
Same as @code{filter}, but the result is returned 
as a collection of class @var{class}.
@c JP
@code{filter}と同じですが、結果のコレクションが@var{class}のインスタンスで
返されます。
@c COMMON

@example
(filter-to <vector> even? '#(1 2 3 4)) @result{} #(2 4)
(filter-to <string> char-upper-case? "Hello, World") 
  @result{} "HW"
@end example
@end deffn

@deffn {Generic function} remove pred coll
@c EN
Returns a list of elements of collection @var{coll} that does not
satisfy the predicate @var{pred}.   If the collection is a sequence,
the order is preserved in the result.
@c JP
コレクション@var{coll}中の要素のうち、述語手続き@var{pred}が偽の値を返したものの
リストを返します。コレクションがシーケンスであれば、結果の要素の順序は元のシーケンスの
順序と同じになります。
@c COMMON

@example
(remove char-upper-case? "Hello, World")
  @result{} (#\e #\l #\l #\o #\, #\space #\o #\r #\l #\d)
(remove even? '#(1 2 3 4)) @result{} (1 3)
@end example
@end deffn

@deffn {Generic function} remove-to class pred coll
@c EN
Same as @code{remove}, but the result is returned 
as a collection of class @var{class}.
@c JP
@code{remove}と同じですが、結果のコレクションが@var{class}のインスタンスで
返されます。
@c COMMON

@example
(remove-to <vector> even? '#(1 2 3 4)) @result{} #(1 3)
(remove-to <string> char-upper-case? "Hello, World") 
  @result{} "ello, orld"
@end example
@end deffn

@deffn {Generic function} partition pred coll
@c EN
Does @code{filter} and @code{remove} the same time.
Returns two lists, the first consists of elements of the collection
@var{coll} that satisfies the predicate @var{pred}, and the second
consists of elements that doesn't.
@c JP
@code{filter}と@code{remove}を同時に行います。
二つのリストを返します。最初のリストはコレクション@var{coll}の要素のうち
述語手続き@var{pred}が真の値を返したものから構成され、二つ目のリストは
そうでない要素から構成されます。
@c COMMON

@example
(partition char-upper-case? "PuPu")
  @result{} (#\P #\P) @r{and} (#\u #\u)
(partition even? '#(1 2 3 4))
  @result{} (2 4) @r{and} (1 3)
@end example
@end deffn

@deffn {Generic function} partition-to class pred coll
@c EN
Same as @code{partition}, except the results are returned
in the collections of class @var{class}.
@c JP
@code{partition}と同じですが、結果がクラス@var{class}のコレクションとして
返されます。
@c COMMON

@example
(partition-to <string> char-upper-case? "PuPu")
  @result{} "PP" @r{and} "uu"
(partition-to <vector> even? '#(1 2 3 4))
  @result{} #(2 4) @r{and} #(1 3)
@end example
@end deffn

@deffn {Generic function} group-collection coll &keyword key test
@c EN
Generalized @code{partition}.  Groups elements in @var{coll}
into those who has the same key value, and returns the groups as
of lists.  Key values are calculated by applying the procedure @var{key}
to each element of @var{coll}.  The default value of @var{key} is
@code{identity}.   For each element of @var{coll}, @var{key} is applied
exactly once.
The equal-ness of keys are compared by
@var{test} procedure, whose default is @code{eqv?}.
@c JP
@code{partition}を汎化したものです。@var{coll}内の要素を同じキーを
持つ値同士でグループ化し、リストのリストにして返します。
キーの値は要素に手続き@var{key}を適用することで得られます。@var{key}の
デフォルト値は@code{identity}です。@var{coll}の各要素に対して、
@var{key}は正確に一回だけ呼ばれます。
キーの等価性判定には手続き@var{test}が使われます。デフォルト値は@code{eqv?}です。
@c COMMON

@c EN
If @var{coll} is a sequence, then the order of elements in each group
of the result is the same order in @var{coll}.
@c JP
@var{coll}がシーケンスである場合、結果の各グループに含まれる要素の順は
もとのシーケンス内での順と同じになります。
@c COMMON

@example
(group-collection '(1 2 3 2 3 1 2 1 2 3 2 3))
  @result{} ((1 1 1) (2 2 2 2 2) (3 3 3 3))

(group-collection '(1 2 3 2 3 1 2 1 2 3 2 3) :key odd?)
  @result{} ((1 3 3 1 1 3 3) (2 2 2 2 2))

(group-collection '(("a" 2) ("b" 5) ("c" 1) ("b" 3) ("a" 6))
  :key car :test string=?)
  @result{} ((("a" 2) ("a" 6)) (("b" 5) ("b" 3)) (("c" 1)))
@end example

@c EN
See also @code{group-sequence} in @code{gauche.sequence}
(@xref{Selection and searching in sequence}),
which only groups adjacent elements.
@c JP
@code{gauche.sequence}の@code{group-sequence}も参照して下さい
(@ref{Selection and searching in sequence})。
隣り合う要素同士でグループ化するものです。
@c COMMON
@end deffn


@node Miscellaneous operations on collection, Fundamental iterator creators, Selection and searching in collection, Collection framework
@subsection Miscellaneous operations on collection
@c NODE コレクションに対する様々な操作

@deffn {Generic function} size-of coll
@c EN
Returns the number of elements in the collection.  Default method iterates over
the collection to calculate the size, which is not very efficient
and may diverge if the collection is infinite.
Some collection classes overload the method for faster calculation.
@c JP
コレクションの要素数を返します。
デフォルトのメソッドは、コレクション中の要素をすべて数え上げるものですが、
あまり効率は良くないでしょう。また、無限個の要素を持つコレクションでは
帰ってきません。多くのコレクションクラスはより効率の良い方法でこのメソッドを定義しています。
@c COMMON
@end deffn

@deffn {Generic function} lazy-size-of coll
@c EN
Returns either the size of the collection, or a promise to
calculate it.  The intent of this method is to avoid
size calculation if it is expensive.  In some cases, the caller
wants to have size just for optimization, and it is not desirable
to spend time to calculate the size.  Such caller uses this method
and just discards the information if it is a promise.
@c JP
コレクションの要素数か、もしくはそれを計算するプロミスを返します。
このメソッドの目的は、要素数の計算が高価な場合にそれを避けることにあります。
しばしば、呼び出し側では最適化のための参考値として要素数が欲しい場合があり、
そういった場合は要素数を計算するために時間を費すのは望ましくありません。
このメソッドを代わりに呼び出して、結果がプロミスであればそれを使わない、
という選択ができます。
@c COMMON
@end deffn

@deffn {Generic function} coerce-to class coll
@c EN
Convert a collection @var{coll} to another collection
which is an instance of @var{class}.
If @var{coll} is a sequence and @var{class} is a sequence class,
the order is preserved.
@c JP
コレクション@var{coll}を、クラス@var{class}のインスタンスである
別のコレクションへと変換します。@var{coll}がシーケンスであり、
@var{class}がシーケンスクラスであれば、元のシーケンスの順序は保存されます。
@c COMMON

@example
(coerce-to <vector> '(1 2 3 4))
  @result{} #(1 2 3 4)

(coerce-to <string> '#(#\a #\b #\c))
  @result{} "abc"
@end example
@end deffn

@node Fundamental iterator creators, Implementing collections, Miscellaneous operations on collection, Collection framework
@subsection Fundamental iterator creators
@c NODE 基礎的なイテレータ構築メソッド

@c EN
These are fundamental methods on which all the rest of
iterative method are built.  The method interface is not intended
to be called from general code, but suitable for building
other iterator construct.   The reason why I chose this interface
as fundamental methods are explained at the bottom of this subsection.
@c JP
ここに挙げるメソッドは、他のコレクションメソッドの基礎となるものです。
メソッドのインタフェースは一般のコードで使われることよりも、
効率良く他の繰り返しメソッドを記述するのに便利なように設計されています。
何故このインタフェースを基礎のメソッドとして選んだかについてはこの章の最後に説明します。
@c COMMON

@deffn {Generic function} call-with-iterator collection proc &keyword start
@c EN
A fundamental iterator creator.   This creates two procedures
from @var{collection}, both take no argument, and then call
@var{proc} with those two procedures.   The first procedure is
terminate predicate, which returns @code{#t} if the iteration
is exhausted, or @code{#f} if there are still elements to be visited.
The second procedure is an incrementer,
which returns one element from the collection and sets the
internal pointer to the next element.
The behavior is undefined if you call the incrementer after
the terminate predicate returns @code{#t}.
@c JP
基礎となるイテレータ構築メソッドです。このメソッドはコレクション@var{collection}
から繰り返しのための二つの手続きを作成し、それらを引数として手続き@var{proc}を
呼びます。作られる最初の手続きは終了判定手続きで、引数無しで呼び出され、繰り返しが
終了していれば@code{#t}を、まだ要素が残っていれば@code{#f}を返します。
作られる二番目の手続きはインクリメント手続きで、呼ばれる度に現在の要素を返し、
内部のポインタを次の要素へと進めます。終了判定手続きが@code{#t}を返した後に
インクリメント手続きを呼んだ場合の動作は未定義です。
@c COMMON

@c EN
If the collection is actually a sequence, the incrementer is guaranteed
to return elements in order, from 0-th element to the last element.
If a keyword argument @var{start} is given, however, the iteration
begins from @var{start}-th element and ends at the last element.
If the collection is not a sequence, the iteration order is
arbtrary, and @var{start} argument has no effect.
@c JP
コレクションがシーケンスでもある場合、インクリメント手続きはシーケンスの順番に要素を取り出します。
キーワード引数@var{start}が与えられていればイテレーションの範囲は
@var{start}番目の要素から最後の要素までとなります。シーケンスでないコレクションに
対しては@var{start}引数は意味を持ちません。
@c COMMON

@c EN
An implementation of @var{call-with-iterator} method may
limit the extent of the iterator inside the dynamic scope of the method.
For example, it allocates some resource (e.g. connect to a database)
before calling @var{proc}, and deallocates it (e.g. disconnect from a database)
after @var{proc} returns.
@c JP
@var{call-with-iterator}のメソッド実装は、イテレータのエクステントを
そのメソッドのダイナミックスコープ内に限ることを許されます。例えば、
メソッドは@var{proc}を呼ぶ前に何らかのリソースを確保し(データベースへのコネクションなど)、
@var{proc}から戻った後でそれを解放するということができます。
@c COMMON

@c EN
This method returns the value(s) @var{proc} returns.
@c JP
このメソッドは @var{proc} が返した値をそのまま返します。
@c COMMON

@example
(call-with-iterator '(1 2 3 4 5)
  (lambda (end? next)
    (do ((odd-nums 0))
        ((end?) odd-nums)
      (when (odd? (next)) (inc! odd-nums)))))
 @result{} 3
@end example

@c EN
See also @code{with-iterator} macro below, for it is easier to use.
@c JP
下に示す@code{with-iterator}マクロも参照してください。
@c COMMON
@end deffn

@deffn {Macro} with-iterator (collection end? next args @dots{}) body @dots{}
@c EN
A convenience macro to call @code{call-with-iterator}.
@c JP
@code{call-with-iterator}を簡潔に呼び出すマクロです。
@c COMMON
@example
(with-iterator (coll end? next args @dots{}) body @dots{})
 @equiv{}
(call-with-iterator coll
  (lambda (end? next) body @dots{})
   args @dots{})
@end example
@end deffn

@defun call-with-iterators collections proc
@c EN
A helper function to write n-ary iterator method.
This function applies @code{call-with-iterator} for each @var{collection}s,
and makes two lists, the first consists of terminate predicates
and the second of incrementers.  Then @var{proc} is called
with those two lists.  Returns whatever @var{proc} returns.
@c JP
N-aryのイテレータメソッドを書くのに便利な手続きです。
この手続きはコレクションのリスト@var{collections}の各コレクションに対して
@code{call-with-iterator}を呼び、二つのリストを作ります。最初のリストには
終了判定手続きが順に集められており、二つ目のリストにはインクリメント手続きが
順に集められています。そして、これらのリストを引数として@var{proc}を呼び出します。
@var{proc}が返した値を返します。
@c COMMON
@end defun

@deffn {Generic function} call-with-builder collection-class proc &keyword size
@c EN
A fundamental builder creator.  Builder is a way to construct
a collection incrementally.  Not all collection classes provide
this method.
@c JP
基礎的なビルダー構築メソッドです。ビルダーはコレクションをインクリメンタルに
作成する方法です。コレクションクラスによってはこの手続きを提供しないものもあります。
@c COMMON

@c EN
@var{Collection-class} is a class of the collection to be built.
This method creates two procedures, adder and getter, then calls
@var{proc} with those procedures.
Adder procedure takes one argument and adds it to the collection
being built.  Getter takes no argument and returns a built collection object.
The effect is undefined if adder is called after getter is called.
@c JP
@var{Collection-class}は作成されるコレクションのクラスです。
このメソッドは、追加手続きと結果手続きの二つの手続きを作成し、それらを
引数として@var{proc}を呼びます。追加手続きは一つ引数を取り、それを作成中の
コレクションに追加します。結果手続きは引数を取らず、作成されたコレクションを返します。
結果手続きが呼ばれた後で追加手続きを呼んだ場合の動作は未定義です。
@c COMMON

@c EN
A keyword argument @var{size} may be specified if the size of
the result collection is known.  Certain collections may be
built much more efficiently if the size is known; other collections
may just ignore it.   The behavior is undefined if more than
@var{size} elements are added, or the collection is retrieved before
@var{size} elements are accumulated.
@c JP
作られるコレクションのサイズが分かっている場合、キーワード引数@var{size}を与える
ことができます。コレクションクラスによってはその情報を使って効率的にコレクションを
作成することができます。その情報を単に無視するコレクションクラスもあります。
@var{size}個より多くの要素が追加されたり、@var{size}個の要素が追加される前に
結果手続きが呼ばれたりした場合の動作は未定義です。
@c COMMON

@c EN
If the collection class is actually a sequence class,
adder is guaranteed to add elements in order.  Otherwise,
the order of elements are insignificant.
@c JP
コレクションクラスがシーケンスクラスであった場合、追加手続きは要素を
シーケンスの順に追加してゆきます。
@c COMMON

@c EN
Some collection class may take more keyword arguments to
initialize the collection.
@c JP
コレクションクラスによっては、コレクションオブジェクトの初期化のために
他のキーワード引数を取るかもしれません。
@c COMMON

@c EN
This method returns the value(s) @var{proc} returned.
@c JP
このメソッドは@var{proc}が返す値を返します。
@c COMMON

@example
(call-with-builder <list>
  (lambda (add! get)
    (add! 'a) (add! 'b) (add! 'c) (get)))
 @result{} (a b c)

(call-with-builder <vector>
  (lambda (add! get)
    (add! 'a) (add! 'b) (add! 'c) (get)))
 @result{} #(a b c)
@end example

@c EN
See also @code{with-builder} macro below, for it is much easier to use.
@c JP
下に示す@code{with-builder}マクロも参照してください。
@c COMMON
@end deffn

@deffn {Macro} with-builder (collection add! get args @dots{}) body @dots{}
@c EN
A convenience macro to call @code{call-with-builder}.
@c JP
@code{call-with-builder}を簡潔に呼び出すマクロです。
@c COMMON
@example
(with-builder (coll add! get args @dots{}) body @dots{})
 @equiv{}
(call-with-builder coll
  (lambda (add! get) body @dots{})
  args @dots{})
@end example
@end deffn

@emph{Discussion}:
@c EN
Other iterator methods are built on top of call-with-iterator and
call-with-builder.
By implementing those methods, you can easily adapt your own collection
class to all of those iterative
operations.   Optionally you can overload some of higher-level
methods for efficiency.
@c JP
他のイテレータメソッドは全てこのcall-with-iteratorとcall-with-builderの上に構築可能です。
最低限これらのメソッドを定義すれば、そのクラスはコレクションとして振舞うことができます。
もちろん最適化のために他のイテレータメソッドを定義しても構いませんが。
@c COMMON

@c EN
It is debatable that which set of operations should be primitives.
I chose call-with-iterator style for efficiency of the applications
I see most.   The following is a discussion of other possible
primitive iterators.
@c JP
どの操作を基礎的なメソッドとするかには議論の余地があります。
Gaucheでは、作者がよく見るパターンで最も効率が良くなるように考えて現在のスタイルを
選びました。以下に、他の基礎的なメソッドの可能性を検討します。
@c COMMON

@table @asis
@item @code{fold}
@c EN
It is possible to make @code{fold} a primitive method, and
build other iterator method on top of it.
Collection-specific iterating states can be kept in the
stack of @code{fold}, thus it runs efficiently.  The method
to optimize a procedure that uses @code{fold} as a basic
iterator construct.
However, it is rather cumbersome to derive
generator-style interface from it.   It is also tricky
to iterate irregulary over more than one collections.
@c JP
@code{fold}を最も基礎的なメソッドとして、他のイテレータメソッドをその上に
構築することも可能です。繰り返しの状態はスタックに置かれるので効率良く走ります。
@code{fold}を基礎とした繰り返し関数を最適化する方法は良く知られています。
しかし、@code{fold}を元にしてジェネレータスタイルのインタフェースを
作成するのは複雑です。また、複数のコレクションに対しての繰り返しを書くのも
面倒です。
@c COMMON

@item CPS
@c EN
Passes iteratee the continuation procedure that continues
the iteration.   The iteratee just returns when it want
to terminate the iteration.
It has resource management problem described in
Oleg Kiselyov's article (@ref{oleg2,,OLEG2}).
@c JP
繰り返しの中身の手続きに対し、繰り返しを続けるための継続手続きを渡す方法です。
繰り返しを続けたくなければ、手続きは継続を呼ばすにそのまま戻ります。
Oleg Kiselyovの記事(@ref{oleg2,,OLEG2})に指摘されているような、
リソース管理の問題があります。
@c COMMON

@item Iterator object
@c EN
Like C++ iterator or Common Lisp generator.
Easy to write loop.   The problem is that every call of
checking termination or getting next element must be dispatched.
@c JP
C++のイテレータやCommon Lispのジェネレータのようなオブジェクトを使う方法です。
ループを書くのは容易ですが、終了判定や要素取り出しの度にメソッドディスパッチが
起こってしまいます。
@c COMMON

@item Series
@c EN
Common Lisp's series can be very efficient if the compiler can statically
analyze the usage of series.  Unfortunately it is not the case in
Gauche.  Even if it could, the extension mechanism doesn't blend well
with Gauche's object system.
@c JP
Common Lispのシリーズはコンパイラがシリーズの使われかたを追跡できれば
非常に効率の良いコードに変換できます。Gaucheのコンパイラはそこまでのデータフロー解析を
行っていません。また、それをやったとしても、コレクションクラスを拡張するための方法が
Gaucheのオブジェクトシステムとはうまく調和しません。
@c COMMON

@item Macros
@c EN
Iterator can be implemented as macros, and that will be very efficient;
e.g. Scheme48's iterator macro.  It uses macros to extend, however,
and that doesn't blend well with Gauche's object system.
@c JP
効率を気にするなら、イテレータをマクロで書いてしまう方法もあります
(例えばScheme48の@code{iterator}マクロなど)。
効率は良いのですが、拡張するにはマクロを書くことが必要となり、
Gaucheのオブジェクトシステムとうまく調和しません。
@c COMMON
@end table

@c EN
The current implementation is close to the iterator object approach,
but using closures instead of iterator objects so that avoiding
dispatching in the inner loop.  Also it allows the iterator
implementator to take care of the resource problem.
@c JP
現在の実装はイテレータオブジェクトアプローチに近いですが、イテレータオブジェクトを
作る代わりにクロージャを使うことで内部のループでのメソッドディスパッチを
避けています。また、現在のインタフェースはリソース管理の問題を解決しています。
@c COMMON

@node Implementing collections,  , Fundamental iterator creators, Collection framework
@subsection Implementing collections
@c NODE コレクションの実装

@c EN
The minimum requirements of the collection class implementation
is as follow:
@itemize @bullet
@item
The class inherits @code{<collection>} abstract class.
@item
A method @code{call-with-iterator} is implemented.
@end itemize

This makes iterator methods such as @code{map}, @code{for-each},
@code{find} and @code{filter} to work.
@c JP
コレクションクラスの実装に最低限要求されるものには、以下のものがあります。
@itemize @bullet
@item
抽象クラス@code{<collection>}を継承している。
@item
メソッド@code{call-with-iterator}が実装されている。
@end itemize

これにより、@code{map}、@code{for-each}、@code{find}、@code{filter}などの
イテレータメソッドが動作するようになります。
@c COMMON

@c EN
In order to make the constructive methods (e.g. @code{map-to} to
create your collection), you have to implement @code{call-with-builder}
method as well.  Note that @code{call-with-builder} method must work
a sort of class method, dispatched by class, rather than normal method
dispatched by instance.   In Gauche, you can implement it by using a
metaclass.   Then the minimal code will look like this:
@c JP
建設的なメソッド(例えば、コレクションを作るための@code{map-to}など)を
作るためには、メソッド@code{call-with-builder}も実装しなければなりません。
メソッド@code{call-with-builder}は、クラスによりディスパッチされるクラスメソッドの
一種で、インスタンスによりディスパッチされる通常のメソッドとは異なります。
Gaucheでは、これはメタクラスを使うことによって実装できます。
最小限のコードは次のようになります。
@c COMMON

@example
(define-class <your-collection-meta> (<class>) ())

(define-class <your-collection> (<collection>)
 (...) ;; @r{slots}
 :metaclass <your-collection-meta>)

(define-method call-with-iterator
    ((coll <your-collection>) proc . options)
  @dots{}
  )

(define-method call-with-builder
     ((coll <your-collection-meta>) proc . options)
  @dots{}
  )
@end example

@c EN
Optionally, you can overload other generic functions to optimize
performance.
@c JP
パフォーマンスの最適化のために、他のジェネリック関数をオーバロードすることも
できます。
@c COMMON

@c ----------------------------------------------------------------------
@node Configuration parameters, Low-level file operations, Collection framework, Library modules - Gauche extensions
@section @code{gauche.config} - Configuration parameters
@c NODE コンフィグレーション情報, @code{gauche.config} - コンフィグレーション情報

@deftp {Module} gauche.config
@mdindex gauche.config
@c EN
This module provides a simple wrapper to obtain configuration
parameters via @code{gauche-config} program.

The @code{gauche-config} program is a simple shell script
that records various parameters given at the configuration time
of Gauche.
@c JP
このモジュールは、@code{gauche-config} プログラム経由で設定パラメータを
取得するシンプルなラッパーを提供します。

@code{gauche-config} プログラムは、Gauche の設定時に与えられた
様々なパラメータを記録するためのシンプルなシェルスクリプトです。
@c COMMON
@end deftp

@defun gauche-config option
@c EN
Calls @code{gauche-config} with the option @var{option}, and
returns the string of the parameter value.  It is an error
to give the option gauche-config doesn't understand.

See the manpage of @code{gauche-config}, or run @code{gauche-config}
without any argument from the shell, to find out the valid options.
@c JP
@code{gauche-config} をオプション @var{option} とともに呼び出すと、
パラメータの値の文字列が返ります。gauche-config が理解できないオプションを
渡すとエラーになります。

有効なオプションについては、@code{gauche-config} のマニュアルページを
見るか、シェルで @code{gauche-config} を引数なしで実行して下さい。
@c COMMON
@example
(gauche-config "--cc")
  @result{} "gcc"
(gauche-config "-L")
  @result{} "-L/usr/lib/gauche/0.6.5/i686-pc-linux-gnu"
(gauche-config "-l")
  @result{} "-ldl -lcrypt -lm -lpthread"
@end example
@end defun

@c ----------------------------------------------------------------------
@node Low-level file operations, Hooks, Configuration parameters, Library modules - Gauche extensions
@section @code{gauche.fcntl} - Low-level file operations
@c NODE 低レベルファイル操作, @code{gauche.fcntl} - 低レベルファイル操作

@deftp {Module} gauche.fcntl
@mdindex gauche.fcntl
@c EN
Provides an interface to @code{fcntl(2)}, including
advisory file locking.
@c JP
アドバイザリ・ファイルロックを含む、
@code{fcntl(2)}へのインタフェースを提供します。
@c COMMON
@end deftp

@defun sys-fcntl port-or-fd operation &optional arg
@c EN
Performs certain operation on the file specfied by @var{port-or-fd},
which should be a port object or an integer
that specifies a system file descriptor.  If it is a port, it must
be associated to the opened file (i.e. @code{port-type}
returns @code{file}, see @ref{Common port operations}).

The operation is specified by an integer @var{operation}.
Several variables are defined for valid @var{operation}.
@c JP
@var{port-or-fd} で指定されたファイルに対して特定の操作をおこないます。
ファイル指定は、ポートオブジェクトもしくはシステムのファイルディスクリプタ
である整数でなくてはなりません。それがポートである場合には、すでにオープン
されたファイルを結びついていなければなりません。
(@code{port-type} が @code{file} を返すようなポートということです。
@ref{Common port operations}参照。)

操作は整数 @var{operation} で指定します。
いくつかの変数が定義されいて、@var{operation} に使用できます。
@c COMMON

@table @code
@item F_GETFD
@vindex F_GETFD
@vindex FD_CLOEXEC
@c EN
Returns flags associated to the file descriptor of @var{port-or-fd}.
The optional argument @var{arg} is not used.   The return value is 
an integer whose definition is system specific, except one flag,
@code{FD_CLOEXEC}, which indicates the file descriptor should be
closed on @code{exec}.  See the manual entry of @code{fcntl(2)} of
your system for the details.
@c JP
@var{port-or-fd} のファイルディスクリプタに結びついているフラグを返します。
オプション引数の@var{arg}は使われません。返り値は整数で、その定義はシステム
によります。ただし、@code{FD_CLOEXEC}だけは例外で、これは@code{exec}で
クローズされたことを示しています。
詳しくはあなたのシステムの@code{fcntl(2)}のマニュアルエントリを
参照してください。
@c COMMON

@item F_SETFD
@vindex F_SETFD
@c EN
Sets the file descriptor flags given as @var{arg} to @var{port-or-fd}.
For example, the portable way of setting @code{FL_CLOEXEC} flag is
as follows:
@c JP
@var{port-or-fd}のファイルディスクリプタのフラグを与えられた@var{arg}に
します。たとえば、@code{FL_CLOEXEC}フラグを設定する、互換性のある方法では
次のようにします。
@c COMMON
@example
(sys-fcntl port F_SETFD
          (logior FD_CLOEXEC
                  (sys-fcntl port F_GETFD)))
@end example

@item F_GETFL
@vindex F_GETFL
@c EN
Returns flags associated to the open files specified by @var{port-or-fd}.
The flags includes the following information:
@c JP
@var{port-or-fd}によって指定されたオープンしたファイルに結びついている
フラグを返します。このフラグには以下のような情報が含まれています。
@c COMMON

@itemize @bullet
@item
@vindex O_ACCMODE
@vindex O_RDONLY
@vindex O_WRONLY
@vindex O_RDWR
@c EN
File access mode.  When masked by @code{O_ACCMODE}, 
it's either one of @code{O_RDONLY}, @code{O_WRONLY} or @code{O_RDWR}.
@c JP
ファイルのアクセスモード。@code{O_ACCMODE} でマスクしたとき、
これは、@code{O_RDONLY}、@code{O_WRONLY}、@code{O_RDWR}のうちどれかひとつです。
@c COMMON
@item
@vindex O_CREAT
@vindex O_EXCL
@vindex O_TRUNC
@c EN
File creation options.  @code{O_CREAT}, @code{O_EXCL} and/or
@c JP
ファイルの作成オプション。@code{O_CREAT}、@code{O_EXCL}のどちらか、または両方。
@c COMMON
@code{O_TRUNC}.
@item
@vindex O_APPEND
@c EN
Whether appending is allowed or not, by @code{O_APPEND}
@c JP
@code{O_APPEND}でマスクしたとき、追記が許されているかどうか。
@c COMMON
@item
@vindex O_NONBLOCK
@c EN
Whether I/O is blocking or non-blocking, by @code{O_NONBLOCK}.
@c JP
@code{O_NONBLOCK}でマスクしたとき、I/O が非ブロックモードかブロックモードか。
@c COMMON
@item
@vindex O_NOCTTY
@c EN
Whether it grabs terminal control, by @code{O_NOCTTY}.
@c JP
@code{O_NOCTTY}でマスクしたとき、端末制御を切離しているかどうか。
@c COMMON
@end itemize

@c EN
The system may define system-specific flags.
@c JP
システムが、そのシステム特有のフラグを定義していることがあります。
@c COMMON

@item F_SETFL
@vindex F_SETFL
@c EN
Sets flags to the open files specified by @var{port-or-fd}.
Among the flags listed above, only @code{O_NONBLOCK} and @code{O_APPEND}
can be changed.

Note that @code{F_GETFD}/@code{F_SETFD} concern flags associated
to the file descriptor itself, while @code{F_GETFL}/@code{F_SETFL}
concern flags associated to the opened file itself.  This makes difference
when more than one file descriptor points to the same opened file.
@c JP
@var{port-or-fd}で指定したオープンされたファイルのフラグを設定します。
上に列挙されたフラグのうち、@code{O_NONBLOCK} と @code{O_APPEND} だけが
変更可能です。

@code{F_GETFD}/@code{F_SETFD} はファイルディスクリプタそのものに結びついた
フラグについてであり、一方、@code{F_GETFL}/@code{F_SETFL} はオープンされた
ファイルそのものに結びついているフラグについての操作であることに注意して
ください。この違いは、2つ以上のファイルディスクリプタが同じオープンされた
ファイルを指しているような場合にあらわれます。
@c COMMON

@item F_DUPFD
@vindex F_DUPFD
@c EN
Creates new file descriptor that points to the same file referred by
@var{port-or-fd}.
An integer must be provided as @var{arg}, and that specifies
the minimum value of file descriptor to be assigned.
@c JP
@var{port-or-fd}で参照しているのと同じファイルを指す新しいファイル
ディスクリプタを生成します。
@var{arg}で整数を与えなければなりません。この数は割り当てられる
ファイルディスクリプタの最小値を指定します。
@c COMMON

@item F_GETLK
@vindex F_GETLK
@c EN
The third argument must be provided and be an instance of @code{<sys-flock>}
object described below.  It searches the lock information specified by
@var{arg}, and modifies @var{arg} accordingly.
@c JP
3つめの引数を与えなければなりません。これは、以下に述べる@code{<sys-flock>}
オブジェクトのインスタンスでなければなりません。@var{arg}で指定された
ロック情報を検索し、それにしかるべく変更します。
@c COMMON

@item F_SETLK
@itemx F_SETLKW
@vindex F_SETLK
@vindex F_SETLKW
@c EN
The third argument must be provided and be an instance of @code{<sys-flock>}
object described below.  Sets the advisory file lock according to 
@var{arg}.   If the lock is successfully obtained, @code{#t} is returned.
If the other process has the lock conflicting the request,
@code{F_SETLK} returns @code{#f}, while @code{F_SETLKW} waits until
the lock is available.
@c JP
3つめの引数を与えなければなりません。これは、以下に述べる@code{<sys-flock>}
オブジェクトのインスタンスでなければなりません。@var{arg}にしたがって、
アドバイザリロックを設定します。ロックの取得に成功すれば、@code{#t}が
返ります。もし、別のプロセスがロックをもっていて要求したものと衝突した
場合には @code{F_SETLK} のときは @code{#f} を返します。一方、@code{F_SETLKW}
のときはロックが利用可能になるまで待ちます。
@c COMMON

@item F_GETOWN
@vindex F_GETOWN
@c EN
Returns the process id or process group that will receive
SIGIO and SIGURG signals for events on the file descriptor.
Process group is indicated by a negative value.
This flag is only available on the systems that has this 
feature (BSD and Linux have this).
@c JP
当該ファイルディスクリプタ上のイベント用シグナル、SIGIO および SIGURG を
受けとることになるプロセスのプロセスIDあるいはプロセスグループを返します。
プロセスグループは負の値で表示されます。このフラグはシステムにこのような
機能がある場合にのみ利用可能です(BSD や Linux にはこの機能があります)。
@c COMMON

@item F_SETOWN
@vindex F_SETOWN
@c EN
Sets the process id or process group that will receive SIGIO
and SIGURG signals for events on the file descriptor.
Process group is indicated by a negative value.
This flag is only available on the systems that has this 
feature (BSD and Linux have this).
Check out fcntl(2) manpage of your system for the details.
@c JP
当該ファイルディスクリプタ上のイベント用シグナル、SIGIO および SIGURG を
受けとることになるプロセスのプロセスIDあるいはプロセスグループを設定します。
プロセスグループは負の値で表示されます。このフラグはシステムにこのような
機能がある場合にのみ利用可能です(BSD や Linux にはこの機能があります)。
詳細については、お使いのシステムの fcntl(2) のマニュアルページをチェック
してください。
@c COMMON

@end table

@c EN
Other value for @var{operation} causes an error.
@c JP
これ以外の値を @var{operation} で指定しようとするとエラーになります。
@c COMMON
@end defun

@deftp {Builtin Class} <sys-flock>
@clindex sys-flock
@c EN
A structure represents POSIX advisory record locking.
Advisory record locking means the system may not prevents the process
from operating on files that it doesn't have an appropriate lock.
All the processes are expected to use @code{fcntl} to check locks
before it operates on the files that may be shared.

The following slots are defined.
@c JP
POSIX のアドバイザリレコードロックを表わす構造体です。アドバイザリレコードロック
というのは、適切なロックをもたないプロセスが対象ファイルを操作しても
システムは関知しない、ということです。すべてのプロセスが、共有される可能性
のあるファイルを操作する前にロックを@code{fcntl}を使って検査することが
期待されています。
@c COMMON

@defivar {<sys-flock>} type
@c EN
An integer represents lock type.  Following variables are predefined
for the valid values:
@c JP
ロックのタイプを表す整数です。利用可能な値として以下の変数があらかじめ
定義されています。
@c COMMON

@table @code
@item F_RDLCK
@vindex F_RDLCK
@c EN
Read locking
@c JP
読み込みのロック
@c COMMON
@item F_WRLCK
@vindex F_WRLCK
@c EN
Write locking
@c JP
書き込みのロック
@c COMMON
@item F_UNLCK
@vindex F_UNLCK

@c EN
To remove a lock by @code{F_SETLK}, or to indicate the record is not
locked by @code{F_GETLK}.
@c JP
@code{F_SETLK}によるロックを除去するか、あるいはレコードが@code{F_GETLK}
でロックされていないことを示す。
@c COMMON
@end table
@end defivar

@defivar {<sys-flock>} whence
@c EN
Indicates from where @code{start} is measured.
@c JP
@code{start}の計測が開始される位置を示す。
@c COMMON
@end defivar

@defivar {<sys-flock>} start
@c EN
The offset of beginning of the locked region.
@c JP
ロックされる領域の開始位置オフセット
@c COMMON
@end defivar

@defivar {<sys-flock>} len
@c EN
The number of bytes to lock.  Zero means ``until EOF''.
@c JP
ロックされるバイト数。ゼロは「EOFまで」という意味。
@c COMMON
@end defivar

@defivar {<sys-flock>} pid
@c EN
An integer process id that holding the lock; used only by @code{F_GETLK}.
@c JP
当該のロックをもっている整数のプロセスID。@code{F_GETLK}でのみ使用。
@c COMMON
@end defivar
@end deftp

@c ----------------------------------------------------------------------
@node Hooks, Interactive session, Low-level file operations, Library modules - Gauche extensions
@section @code{gauche.hook} - Hooks
@c NODE フック, @code{gauche.hook} - フック

@deftp {Module} gauche.hook
@mdindex gauche.hook
@c EN
Provides a hook object, which manages a list of closures to be
called at certain time.

This API of hooks are upper-compatible of Guile's, with the
following extensions.
@c JP
フックオブジェクトを提供します。これは、特定のタイミングで
呼び出されるクロージャのリストを管理するものです。

フックのAPIはGuileのそれと上方互換で、下記のように拡張されています。
@c COMMON
@itemize @bullet
@item
@c EN
Based on Gauche's object system.  Most APIs are methods
so you can extend the hook features.
@c JP
Gaucheのオブジェクトシステムをベースにしています。
ほとんどのAPIはメソッドなので、フックの機能を拡張することが
できます。
@c COMMON
@item
@c EN
Hook object itself is applicable.  You don't need to use @code{run-hook}.
@c JP
フックオブジェクトはそれ自身適用可能です。@code{run-hook}を使う必要は
ありません。
@c COMMON
@item
@c EN
The method to remove a procedure from a hook is called @code{delete-hook!},
for consistency with SRFI-1 and others.  @code{remove-hook!} is
defined as an alias of @code{delete-hook!} for compability with Guile.
@c JP
フックから手続きを削除するメソッドは、SRFI-1やその他との一貫性の
ために@code{delete-hook!}と呼ばれます。
Guileとの互換性のために、@code{remove-hook!}が@code{delete-hook!}の
エイリアスとして定義されています。
@c COMMON
@end itemize
@end deftp

@deftp {Class} <hook>
@clindex hook
@c EN
A hook class, which keeps a list of procedures to be called at once.

The @code{object-apply} method is defined on @code{<hook>} class,
so you can "apply" a hook object as if it were a procedure---which
causes all the registered procedure to be invoked.
@c JP
フックのクラスで、一度に呼び出される手続きのリストを保持しています。

@code{<hook>}クラスには@code{object-apply}メソッドが定義されているので、
あたかもそれが手続きであるかのようにフックオブジェクトを``適用''できます。
フックオブジェクトを適用すると、登録されている全ての手続きが呼び出されます。
@c COMMON
@end deftp

@defun make-hook &optional (arity 0)
@c EN
Creates a new hook object with given arity, which should be a
non-negative integer.
@c JP
与えられたアリティ(正の整数でなければなりません)とともに新しい
フックオブジェクトを作成します。
@c COMMON
@end defun

@defun hook? obj
@c EN
Returns true if @var{obj} is a hook object.
@c JP
@var{obj}がフックオブジェクトであれば、真を返します。
@c COMMON
@end defun

@defun hook-empty? hook
@c EN
Returns true if @var{hook}'s procedure list is empty.
@c JP
@var{hook}の手続きリストが空なら、真を返します。
@c COMMON
@end defun

@deffn {Method} add-hook! (hook <hook>) proc &optional (append? #f)
@c EN
Adds a procedure @var{proc} to @var{hook}.  If @var{append?}
is given and true, @var{proc} is added at the end of the list.
Otherwise, @var{proc} is added at the front of the list.
The @var{proc} has to be called with the arity given 
at the @code{make-hook}.
@c JP
手続き@var{proc}を@var{hook}に追加します。
@var{append?}が与えられ真であれば、@var{proc}はリストの最後に
追加されます。そうでなければ、@var{proc}はリストの最初に追加
されます。
@var{proc}は、@code{make-hook}時に与えられたアリティとともに
呼ばれなければなりません。
@c COMMON
@end deffn

@deffn {Method} delete-hook! (hook <hook>) proc
@deffnx {Method} remove-hook! (hook <hook>) proc
@c EN
Removes @var{proc} from the procedure list of @var{hook}.
@code{Remove-hook!} is an alias of @code{delete-hook!} just for
compability with Guile.
@c JP
@var{hook}の手続きリストから@var{proc}を削除します。
Guileとの互換性のためだけに、@code{remove-hook!}が@code{delete-hook!}の
エイリアスとなっています。
@c COMMON
@end deffn

@deffn {Method} reset-hook! (hook <hook>)
@c EN
Empties @var{hook}'s procedure list.
@c JP
@var{hook}の手続きリストを空にします。
@c COMMON
@end deffn

@deffn {Method} hook->list (hook <hook>)
@c EN
Returns a copy of @var{hook}'s procedure list.
@c JP
@var{hook}の手続きリストのコピーを返します。
@c COMMON
@end deffn

@deffn {Method} run-hook (hook <hook>) arg @dots{}
@c EN
Calls @var{hook}'s procedures in order, with arguments @var{arg} @dots{}.
The number of arguments must match the arity given at @code{make-hook}.
@c JP
@var{hook}の手続きを、@var{arg} @dots{}を引数として順番に呼び出します。
引数の数は、@code{make-hook}時に与えられたアリティにマッチしなければ
なりません。
@c COMMON
@end deffn

@c ----------------------------------------------------------------------
@node Interactive session, Listener, Hooks, Library modules - Gauche extensions
@section @code{gauche.interactive} - Utilities for interactive session
@c NODE インタラクティブセッション, @code{gauche.interactive} - インタラクティブセッション

@deftp {Module} gauche.interactive
@mdindex gauche.interactive
@c EN
Provides useful utilities for the interactive session.

This module is automatically loaded when you run @code{gosh}
interactively.

This module also sets autoloads for functions defined in
@code{gauche.reload} module 
(see @ref{Reloading modules}), so that
those functions can be used by default in interactive development.
@c JP
インタラクティブセッションで便利なユーティリティ手続きを提供します。

@code{gosh}をインタラクティブモードで起動した場合、
このモジュールは自動的にロードされます。

また、このモジュールは@code{gauche.reload}
(@ref{Reloading modules}参照)で定義される
手続きに対してautoloadを設定し、それらの手続きが
インタラクティブな開発時にデフォルトで使えるようにします。
@c COMMON
@end deftp

@defmac apropos pattern &optional module
@c EN
Show a list of defined variables whose name matches @var{pattern}.
If you give a module or a module name @var{module}, only the variables
defined in that module are listed.  Without @var{module},
the variables "visible" from the current module are listed.
@c JP
名前が@var{pattern}にマッチするような定義された変数のリストを表示します。
@var{module}にモジュールオブジェクトまたはモジュール名を与えた場合は、
そのモジュール内で定義されている変数のみが表示されます。@var{module}が
省略された場合は、カレントモジュールから「見える」変数が全て表示されます。
@c COMMON

@c EN
@var{pattern} may be a symbol or a regexp object.
If it is a symbol, the variables whose name contains the
substring that matches the symbol's name are listed.
If it is a regexp object, the variables whose name matches
the regexp are listed.
@c JP
@var{pattern}はシンボルか正規表現オブジェクトでなければなりません。
シンボルの場合、そのシンボル名を部分文字列として名前に含むような変数が
リストされます。正規表現オブジェクトの場合は、その正規表現にマッチする
名前を持つ変数がリストされます。
@c COMMON

@c EN
Some examples:
@c JP
いくつか例を示します。
@c COMMON
@example
@c EN
;; @r{List variables that contains "string" in their name}
@c JP
;; @r{"string"を名前に含む変数を表示}
@c COMMON
(apropos 'string)

@c EN
;; @r{Search in srfi-14 module}
@c JP
;; @r{srfi-14モジュールの中のみを検索}
@c COMMON
(apropos 'char 'srfi-14)
@end example
@end defmac

@deffn {Generic Function} describe obj
@deffnx {Generic Function} d obj
@c EN
Prints the detail information about a Scheme object @var{obj}.
The default method shows @var{obj}'s class, and if it has
any slots, the list of slot names and their values.
You can specialize this method for customized display.
@c JP
Schemeオブジェクト@var{obj}の詳細情報を表示します。
既定メソッドは@var{obj}のクラスを表示し、さらに@var{obj}がスロットを
持っていればその名前と内容をリストします。
このメソッドをスペシャライズすることによりクラス毎に表示をカスタマイズできます。
@c COMMON
@end deffn

@defun info symbol
@c EN
Displays a page of Gauche's info file that contains definition of
the function or syntax specified by @var{symbol}.
If an environment variable @code{INFOPATH} is defined,
this function searches for the info file from the directories in it.
Otherwise, this function guesses info file location from the
@code{gosh}'s library directory.   If the info file can't be
found, an error is signalled.   If the info file is found,
but @var{symbol} is not in its index, an error is signalled as well.
So this function doesn't work if you haven't installed info file.
@c JP
Gaucheのinfoドキュメント中から、
@var{symbol}で指定される手続きか構文要素の定義を含んでいるページを表示します。
infoドキュメントは、もし環境変数@code{INFOPATH}が定義されていればそこに
示されるディレクトリ中から探され、そうでなければ@code{gosh}のライブラリディレクトリ
から推測されるディレクトリ中から探されます。infoドキュメントが見付からなかったり、
見付かっても@var{symbol}がIndexページ中に無かった場合はエラーとなります。
つまり、この手続きはinfoファイルがインストールされていないと動作しません。
@c COMMON

@c EN
If the current output port is a tty, the info page is displayed by
a paging software.  If an environment variable @code{PAGER} is defined,
it is used as a paging software.  Otherwise, this function looks for
@code{less} and @code{more} in this order from the directories in
@code{PATH}.  If none of them is found, or the output port is not
a tty, this function just displays the page.
@c JP
現在の出力ポートが端末である場合、infoドキュメントの該当ページは
ページングプログラムを用いて表示されます。環境変数@code{PAGER}が指定されていれば
それを用い、そうでなければコマンドサーチパスから@code{less}及び@code{more}を
この順で探します。いずれも見付からなかった場合や、出力ポートが端末では
ない場合には、単にページがそのまま出力されます。
@c COMMON

@c EN
The first invocation of this function in a session takes some time
to parse the info file.
@c JP
この手続きのセッション中での最初の呼び出しは、infoファイルをパーズするために
多少時間がかかります。
@c COMMON
@end defun

@c ----------------------------------------------------------------------
@node Listener, User-level logging, Interactive session, Library modules - Gauche extensions
@section @code{gauche.listener} - Listener
@c NODE リスナー, @code{gauche.listener} - リスナー

@deftp {Module} gauche.listener
@mdindex gauche.listener
@c EN
This module provides a convenient way to enable multiple
read-eval-print loop (repl) concurrently.
@c JP
このモジュールは、
複数のread-eval-printループ(repl)を並行して動作させるのに便利な機能を提供します。
@c COMMON

@c EN
An obvious way to run multiple repls is to use threads;
creating as many threads as sessions and calling
@code{read-eval-print-loop} (@xref{Eval and repl}) from each thread.
Nevertheless, sometimes single threaded implementation is preferred.
For instance, you're using a library which is not MT-safe,
or your application already uses select/poll-based dispatching mechanism.
@c JP
複数のreplを実現する自明な方法は、セッション毎にスレッドを生成して
各スレッド上で@code{read-eval-print-loop} (@ref{Eval and repl}参照)を
呼ぶことですが、シングルスレッドでの実装が好ましい場合もあります。
例えばアプリケーションがMT-safeでないライブラリに大きく依存していたり、
既にアプリケーションがselectやpollをベースにしたディスパッチメカニズムを
持っているような場合です。
@c COMMON

@c EN
To implement repl in the single-threaded selection-base application,
usually you register a handler that is called when data is available
in the listening port.  The handler reads the data and add them into
a buffer.  Then it examines if the data in the buffer consists a
complete expression, and if so, it reads the expression from the
buffer, evaluates it, then prints the result to the reporting port.
The @code{<listener>} class in this module provides this handler mechanism,
so all you need to do is to register the handler to your dispatching
mechanism.
@c JP
シングルスレッドのselectionベースのアプリケーションでreplを実装するには、
通常、listenしているポートにデータが到着した時に呼ばれるハンドラを登録します。
ハンドラはポートからデータを読み、内部バッファに追加します。
そして内部バッファをスキャンし、データが完全な式を構成した場合は
それをS式として読みだし、評価して結果をポートに流します。
このモジュールの@code{<listener>}クラスはこのハンドラのメカニズムを提供するので、
アプリケーション側はそれを自分のディスパッチメカニズムに登録するだけで済みます。
@c COMMON

@c EN
Note: it may also be desirable to buffer the output sometimes,
but the current version doesn't implement it.
@c JP
註：場合によっては、出力もバッファリングする必要があるかもしれませんが、
現在はそれは実装されていません。
@c COMMON
@end deftp

@deftp {Class} <listener>
@c EN
An object that maintains the state of a repl session.
It has many external slots to customize its behavior.
Those slot values can be set at construction time
by using the keyword of the same name as the slot,
or can be set by @code{slot-set!} afterwards.  However,
most of them should be set before calling 
@code{listener-read-hander}.
@c JP
Replセッションの状態を維持するオブジェクトです。
オブジェクトのふるまいをカスタマイズするためにいくつもの外部スロットがあります。
これらのスロットの値は、スロットの名前と同名のキーワード引数を用いて
オブジェクトの構築時に指定することもできますし、オブジェクト構築後に
@code{slot-set!}で設定することもできますが、@code{listener-read-handler}
を呼ぶ前に確定していなければなりません。
@c COMMON

@defivar <listener> input-port
@c EN
Specifies the input port from which the listener get the input.
The default value is the current input port when the object is
constructed.
@c JP
リスナーが入力を受けとる入力ポートを指定します。デフォルト値は、
オブジェクトが構築された時のカレント入力ポートです。
@c COMMON
@end defivar

@defivar <listener> output-port
@c EN
Specifies the output port to which the listener output will go.
The default value is the current output port when the object is
constructed.
@c JP
リスナーが出力をおこなう出力ポートを指定します。デフォルト値は、
オブジェクトが構築された時のカレント出力ポートです。
@c COMMON
@end defivar

@defivar <listener> error-port
@c EN
Specifies the output port to which the listener's error messages will go.
The default value is the current error port when the object is
constructed.
@c JP
リスナーのエラーメッセージを出力するポートを指定します。デフォルト値は、
オブジェクトが構築された時のカレントエラー出力ポートです。
@c COMMON
@end defivar

@defivar <listener> reader
@c EN
A procedure with no arguments.  It should read a Scheme expression
from the current input port when called.
The default value is system's @code{read} procedure.
@c JP
引数を取らない手続きです。呼び出し時のカレント入力ポートからScheme式を
読み込まなければなりません。デフォルト値はシステムの@code{read}手続きです。
@c COMMON
@end defivar

@defivar <listener> evaluator
@c EN
A procedure that takes two arguments, a Scheme expression and
an environment specifier.  It should evaluate the expression in
the given environment and returns zero or more value(s).
The default value is system's @code{eval} procedure.
@c JP
Scheme式と環境指定子のふたつの引数をとる手続きです。
式を与えられた環境で評価し、0個以上の値を返さなければなりません。
デフォルト値はシステムの@code{eval}手続きです。
@c COMMON
@end defivar

@defivar <listener> printer
@c EN
A procedure that takes zero or more argument(s) and prints them
out to the current output port.  The default value is a procedure
that prints each value by @code{write}, followed by a newline.
@c JP
0以上の引数をとり、カレント出力ポートに印字する手続きです。
デフォルト値は、各値を@code{write}で印字したのち、改行する手続きです。
@c COMMON
@end defivar

@defivar <listener> prompter
@c EN
A procedure with no arguments.  It should prints a prompt
to the current output port.  The output is flushed by the listener
object so this procedure doesn't need to care about it.
The default procedure prints @code{"listener> "}.
@c JP
引数をとらない手続きです。カレント出力ポートにプロンプトを
印字しなければなりません。リスナーは、この手続きが面倒を見なくてよいように、
出力をフラッシュします。
デフォルトの手続きは @code{"listener> "} を印字します。
@c COMMON
@end defivar

@defivar <listener> environment
@c EN
An environment specifier where the expressions will be
evaluated.  The default value is the value returned by
@code{(interaction-environment)}.
@c JP
式を評価する環境指定子です。デフォルト値は@code{(interaction-environment)}が
返す値です。
@c COMMON
@end defivar

@defivar <listener> finalizer
@c EN
A thunk that will be called when EOF is read from @code{input-port}.
It can be @code{#f} if no such procedure is needed.
The default value is @code{#f}.
@c JP
@code{input-port}からEOFが読み込まれたときに呼び出されるサンクです。
このような手続きが必要ない場合は@code{#f}にしておいて構いません。
デフォルトの値は@code{#f}です。
@c COMMON
@end defivar

@defivar <listener> error-handler
@c EN
A procedure that takes one argument, an error exception.  It is
called when an error occurs during read-eval-print stage,
with the same dynamic environment as the error is signalled.
The default value is a procedure that simply prints the
error exception by @code{report-error}.
@c JP
エラー例外をひとつ引数としてとる手続きです。read-eval-printの最中に
エラーが発生すると、エラーシグナルが発生すのと同じ動的環境で、
呼び出されます。
デフォルト値はエラー例外を@code{report-error}を使って印字する手続きです。
@c COMMON
@end defivar
@end deftp


@deffn {Method} listener-read-handler (listener <listener>)
@c EN
Returns a thunk that is to be called when a data is available
from @code{input-port} of the listener.

The returned thunk (read handler) does the following steps.
Note that the first prompt is @emph{not} printed by this
procedure.  See @code{listener-show-prompt} below.
@enumerate
@item
Reads available data from @code{input-port} and appends it to the
listener's internal buffer.
@item
Scans the buffer to see if it has a complete S-expression.
If not, returns.
@item
Reads the S-expression from the buffer.
The read data is removed from the buffer.
@item
Evaluates the S-expression, then prints the result to
@code{output-port}.
@item
Prints the prompt by prompter procedure to @code{output-port},
then flush @code{output-port}.
@item
Repeats from 2.
@end enumerate
@c JP
リスナーの@code{input-port}から読み込んだデータが正しい時に
呼ばれるサンクを返します。

返されたサンク(readハンドラ)は、以下のように実行されます。
この手続きは最初のプロンプトを印字@emph{しない}ことに
注意してください。これについては後述の@code{listener-show-prompt}を
参照してください。
@enumerate
@item
@code{input-port}にあるデータを読み、これをリスナーの内部バッファに
連結する。
@item
バッファをスキャンして、それが完結したS式であるかを確かめ、
完結していなければ、リターンする。
@item
バッファからそのS式を読み込み、そのバッファからは
そのデータを除去する。
@item
そのS式を評価して、結果を@code{output-port}へ印字する。
@code{output-port}.
@item
プロンプタ手続きを使って、プロンプトを@code{output-port}に印字したのち、
@code{output-port}をフラッシュする。
@item
2から繰り返す。
@end enumerate
@c COMMON
@end deffn

@deffn {Method} listener-show-prompt (listener <listener>)
@c EN
Shows a prompt to the listener's output port, by using
listener's prompter procedure.  Usually you want to use
this procedure to print the first prompt, for instance,
when the client is connected to the listener socket.
@c JP
リスナーの出力ポートにプロンプトを表示します。表示にはリスナーの
プロンプタ手続きを使います。通常この手続きは最初のプロンプトを
印字するために使います。たとえば、クライアントがリスナーソケットに
接続してきたときです。
@c COMMON
@end deffn

@defun complete-sexp? str
@c EN
Returns @code{#t} if @var{str} contains a complete S-expression.
This utility procedure is exported as well, since it might be useful
for other purposes.

Note that this procedure only checks syntax of the expressions,
and doesn't rule out erroneous expressions (such as containing
invalid character name, unregistered SRFI-10 tag, etc.).
This procedure may raise an error if the input contains
'@code{#<}' character sequence.
@c JP
もし、@var{str}が完結したＳ式を含んでいれば@code{#t}を返します。
このユーティリティ手続きは、他の目的にも有用なので、
他の手続きといっしょにエクスポートしてあります。

この手続きは構文のチェックをするだけで、(不正な文字名を含んだり、
登録されていないSRFI-10のタグを含むなど)誤りのある式を判別するわけでは
ないことに注意してください。この手続きは入力が'@code{#<}'文字の
シーケンスを含むと、エラーを発生させます。
@c COMMON
@end defun

@c EN
The following code snippet opens a server socket, and opens
a Scheme interactive session when a client is connected.
(Note: this code is just for demonstration.  Do not run
this program on the machine accessible from outside network!)
@c JP
以下のコード断片は、サーバソケットをオープンし、クライアントが
接続してきたときにSchemeの対話的セッションをオープンするというものです。
(註: このコードはdemo用のコードです。決して、外のネットワークから
アクセス可能なマシン上で走らせてはいけません！)
@c COMMON

@example
(use gauche.net)
(use gauche.selector)
(use gauche.listener)

(define (scheme-server port)
  (let ((selector (make <selector>))
        (server   (make-server-socket 'inet port :reuse-addr? #t))
        (cid      0))

    (define (accept-handler sock flag)
      (let* ((client (socket-accept server))
             (id     cid)
             (input  (socket-input-port client :buffering :none))
             (output (socket-output-port client))
             (finalize (lambda ()
                         (selector-delete! selector input #f #f)
                         (socket-close client)
                         (format #t "client #~a disconnected\n" id)))
             (listener (make <listener>
                         :input-port input
                         :output-port output
                         :error-port output
                         :prompter (lambda () (format #t "client[~a]> " id))
                         :finalizer finalize))
             (handler (listener-read-handler listener))
             )
        (format #t "client #~a from ~a\n" cid (socket-address client))
        (inc! cid)
        (listener-show-prompt listener)
        (selector-add! selector input (lambda _ (handler)) '(r))))

    (selector-add! selector
                   (socket-fd server)
                   accept-handler
                   '(r))
    (format #t "scheme server started on port ~s\n" port)
    (do () (#f) (selector-select selector))))
@end example

@c ----------------------------------------------------------------------
@node User-level logging, Singleton, Listener, Library modules - Gauche extensions
@section @code{gauche.logger} - User-level logging
@c NODE ユーザレベルのロギング, @code{gauche.logger} - ユーザレベルのロギング

@deftp {Module} gauche.logger
@mdindex gauche.logger
@c EN
Provides a simple interface to log the program's activity.
The information can be written to the specified file,
or to the system logger using @code{syslog(3)}.
When a file is used, syslog-like prefix string is added
to each message, which is configurable.  It can also takes care of
locking of the file (see the description of @code{lock-policy} below).
@c JP
プログラムからログを書き出す簡単なインタフェースを提供します。
情報は指定されたファイルへ書き出されるか、もしくは@code{syslog(3)}を
使ってシステムログへと送られます。
ファイルに書き出される場合は、
syslogに似たプレフィクスが各メッセージの前に追加されます。
プレフィクスはカスタマイズすることもできます。
また、ログファイルの排他制御も行われます (下の@code{lock-policy}の説明を
参照して下さい)。
@c COMMON
@end deftp

@deftp {Class} <log-drain>
@clindex log-drain
@c EN
Represents the destination of log messages.
There's one implicit global @code{<log-drain>} instance, which is
used by default.  However, you can create as many instances
by @code{make} method as you want, in case if you want to log
to more than one destination.
@c JP
ログメッセージの行き先を表現するオブジェクトです。
デフォルトのログの行き先として、グローバルな@code{<log-drain>}のインスタンスが
ひとつ作られます。
ログをいくつかにわけて出力する場合などは@code{make}メソッドを使って
いくつでも@code{<log-drain>}のインスタンスを作ることができます。
@c COMMON

@defivar {<log-drain>} path
@c EN
Path of the log file.  It can be also @code{#t}, which means 
the current error port, or @code{#f}, which makes @code{log-format}
to return the formatted message but not write to any log files,
or a symbol @code{syslog}, which means the messages are sent to
the system logger.

By default, this slot is @code{#f}.
@c JP
ログファイルのパス名か、@code{#t}、@code{#f}、あるいはシンボル@code{syslog}
の値を取ります。このスロットが@code{#t}の場合、ログメッセージは現在のエラーポートに
書き出されます。@code{#f}の場合は@code{log-format}は
ログを書き出すかわりにフォーマットされたログメッセージを文字列として返します。
シンボル@code{syslog}の場合はメッセージがシステムログへと送られます。

このスロットの初期値は@code{#f}です。
@c COMMON
@end defivar

@defivar {<log-drain>} prefix
@c EN
Specifies the prefix string that is attached to the beginning of every
message.  If the message spans to several lines, the prefix is
attached to each line.   The value of this slot can also be a procedure
that takes @code{<log-drain>} object and returns a string to be used as
the prefix.  The procedure is called every time prefix is needed.
@c JP
各メッセージの前に追加されるプレフィクス文字列を指定します。
メッセージが複数行に渡る場合、プレフィクスは各行の頭に追加されます。
またこのスロットには手続きをセットすることもできます。
その場合、プレフィクス文字列が必要とされる度にその手続きが@code{<log-drain>}
を引数として呼び出され、戻り値の文字列がプレフィクスとして使われます。
@c COMMON

@c EN
When the @code{path} slot is a symbol @code{syslog}, the value of this slot
is ignored.  System logger will attach an appropriate prefix.
@c JP
@code{path}スロットの値がシンボル@code{syslog}の場合は、
このスロットの値は無視されます。システムのログ機構が適切なプレフィクスを付けるからです。
@c COMMON

@c EN
When the value of the prefix slot is a string, the following character sequences
have special meanings and replaced by @code{log-format} for appropriate
information when written out.
@c JP
prefixスロットの値が文字列の場合、以下に挙げる文字シーケンスは特別な意味を持ち、
@code{log-format}によって置換されます。
@c COMMON

@table @code
@item ~T
@c EN
Current time, in the format of "Mmm DD hh:mm:ss" where "Mmm" is
an abbreviated month, "DD" is the day of month, "hh", "mm" and
"ss" are hours (in 24 hour basis), minutes and seconds, respectively.
This format is compatible with system logs.
@c JP
現在の時刻を"Mmm DD hh:mm:ss"という形式で表したもの。
ここで"Mmm" は英語の月名の省略形、"DD" は日、"hh"、"mm"、
"ss" は時間(24時間制)、分、秒です。
このフォーマットはシステムログと同じです。
@c COMMON

@item ~Y
@c EN
Current 4-digit year.
@c JP
4桁で表した現在の西暦。
@c COMMON

@item ~P
@c EN
The program name.  The default value is the basename of
@code{*program-name*} (@xref{Writing Scheme scripts}), 
but you can change it by the @code{program-name}
slot described below.
@c JP
プログラム名。初期値は@code{*program-name*}の値のbasenameが使われます
(@ref{Writing Scheme scripts}参照)。
下に述べる@code{program-name}スロットの値を変えれば
ここに現れる文字列を変えることができます。
@c COMMON

@item ~$
@c EN
The process id of this program.
@c JP
このプログラムのプロセスID。
@c COMMON

@item ~U
@c EN
The name of the effective user of the process.
@c JP
このプロセスの実行ユーザ名。
@c COMMON

@item ~H
@c EN
The hostname the process is running.
@c JP
このプロセスが走っているホスト名。
@c COMMON
@end table

@c EN
The default value of this slot is "@code{~T ~P[~$]: }".  For example,
if a string "this is a log message.\nline 2\nline 3" is given as the
message, it produces something like the following log entry.
@c JP
このスロットの初期値は"@code{~T ~P[~$]: }"です。例えば
"this is a log message.\nline 2\nline 3"というメッセージが
与えられると、次のようなログが書き出されます。
@c COMMON

@example
Sep  1 17:30:23 myprogram[441]: this is a log message
Sep  1 17:30:23 myprogram[441]: line 2
Sep  1 17:30:23 myprogram[441]: line 3
@end example

@end defivar

@defivar {<log-drain>} program-name
@c EN
Specifies the program name written by @code{~P} directive of
the prefix slot.
@c JP
プレフィクス文字列の@code{~P}が置換されるプログラム名を指定します。
@c COMMON
@end defivar

@defivar {<log-drain>} lock-policy
@c EN
Specifies the way the log file should be locked.
If the value of this slot is a symbol @code{fcntl},
the log file is locked using
fcntl() (@xref{Low-level file operations}).
If the value is a symbol @code{file}, the log file is locked by
creating auxiliary lock file, whose name is generated by appending ".lock"
after the log file path.  The logging
process needs a write permission to the log file directory.
Note that if the process is killed forcibly during writing the
log file, a stale lock file may remain.  @code{Log-format}
silently removes the lock file if it is unusually old (currently 10 minutes).
If the value is @code{#f}, no locking is performed.

The default value is @code{fcntl}, except MacOSX which doesn't
support fcntl()-style locking and thus @code{file} is default.

The locking isn't performed if the destination is not a file.
@c JP
ログファイルのロックの方法を指定します。
このスロットの値がシンボル@code{fcntl}だった場合は、
fcntl()によるファイルロックが使われます
(@ref{Low-level file operations}参照)。
このスロットの値がシンボル@code{file}だった場合は、
ログファイルのパス名に ".lock" を追加したロックファイルを作成することによる
排他制御が行われます。この場合、ログを行うプロセスはログファイルの
置かれるディレクトリに書き込み権限が必要です。
また、プロセスがログファイル書き込み中に強制的に終了させられた場合、
ロックファイルが残ってしまう恐れがあります。
@code{Log-format}はロックファイルが十分に古い場合(現在は10分をリミットとしています)
ロックファイルを自動的に削除します。
このスロットの値が@code{#f}だった場合は、排他制御は行われません。

デフォルトの値は@code{fcntl}です。但しMacOSXではfcntlスタイルのロックが
サポートされていないため、@code{file}がデフォルト値となります。

ログの行き先がファイルでない場合は排他制御は行われません。
@c COMMON
@end defivar

@defivar {<log-drain>} syslog-option
@defivarx {<log-drain>} syslog-facility
@defivarx {<log-drain>} syslog-priority
@c EN
The value of these slots are used when the destination of the drain
is the system logger.   @xref{Syslog}, for the detailed information
about these values.  The default values of these slots
are @code{LOG_PID}, @code{LOG_USER} and @code{LOG_INFO}, respectively.
@c JP
これらのスロットの値は、ログの行き先がシステムログの場合にのみ使われます。
これらの値に関する説明は@ref{Syslog}を参照して下さい。
デフォルトの値はそれぞれ@code{LOG_PID}、@code{LOG_USER}、@code{LOG_INFO}です。
@c COMMON
@end defivar
@end deftp


@defun log-open path &keyword prefix program-name
@c EN
Sets the destination of the default log message to the path @var{path}.
It can be a string or a boolean, as described above.
You can also set prefix and program name by corresponding keyword 
arguments.
@c JP
デフォルトのログの行き先を@var{path}に指定します。
@var{path}は文字列かboolean値あるいはシンボル@code{syslog}で、
上の@code{path}スロットで述べたものと
おなじ意味を持ちます。またプレフィクスとプログラム名をキーワード引数で
指定することもできます。
@c COMMON

@c EN
Despite its name, this function doesn't open the specified file
immediately.  The file is opened and closed every time @code{log-format}
is called.
@c JP
名前に"open"とありますが、この手続きは指定されたファイルをオープンしません。
ファイルは@code{log-format}が呼ばれるたびにオープンされクローズされます。
@c COMMON
@end defun

@deffn {Method} log-format (format <string>) arg @dots{}
@deffnx {Method} log-format (drain <log-drain>) (format <string>) arg @dots{}
@c EN
Formats a log message by @var{format} and @var{arg @dots{}}, by using
@code{format} (@xref{Output}).    In the first form, the output goes
to the default destination.  In the second form, the output goes to
the specfied drain.
@c JP
ログメッセージを@code{format}手続きでフォーマットし(@ref{Output}参照)、
指定された行き先に書き出します。最初の形式ではデフォルトの行き先が使われます。
@c COMMON

@c EN
The file is opened and closed every time.  You can safely move
the log file while your program that touches the log file is running.
Also @code{log-format} acquires a write lock of the log file by
@code{sys-fcntl} (@xref{Low-level file operations}).
@c JP
ファイルはこの手続きが呼ばれるたびにオープンされクローズされます。
したがって、ログファイルに書き出すプログラムが走っている最中でも
ログファイルをmoveすることができます。
また、@code{log-format}は@code{sys-fcntl} (@ref{Low-level file operations}参照)
を使ってファイルロックを獲得します。
@c COMMON

@c EN
If the first form of @code{log-format} is called before @code{log-open}
is called, @code{log-format} does nothing.
It is useful to embed debug stubs in your code; once your code is
past the debugging stage, you just comment out @code{log-open} and
the code runs without logging.
@c JP
@code{log-open}が呼ばれる前に@code{log-format}が最初の形式で呼ばれた場合、
@code{log-format}は何もしません。したがって、@code{log-format}をデバッグに
活用し、必要なくなったら@code{log-open}だけをコメントアウトする、というような
使用法も可能です。
@c COMMON
@end deffn

@c ----------------------------------------------------------------------
@node Singleton, Slot with validator, User-level logging, Library modules - Gauche extensions
@section @code{gauche.mop.singleton} - Singleton
@c NODE シングルトン, @code{gauche.mop.singleton} - シングルトン

@deftp {Module} gauche.mop.singleton
@mdindex gauche.mop.singleton
@c EN
Provides a metaclass to define a singleton class.
@c JP
シングルトンクラスを定義するためのメタクラスを提供します。
@c COMMON
@end deftp

@deftp {Class} <singleton-meta>
@clindex singleton-meta
@c EN
Creates a singleton class.  A singleton class is a class that is
guaranteed to create only one instance.
The first invocation of @code{make} creates the single instance,
and further attempt of creation returns the same instance.
@c JP
シングルトンクラスを生成します。シングルトンクラスはそのインスタンスが
ただ一つしかないことを保証するクラスです。 @code{make} の
最初の呼び出しで、唯一のインスタンスを生成し、その後の呼出しでは
最初に生成したものと同一のインスタンスを返します。
@c COMMON
@example
(define-class single () () :metaclass <singleton-meta>)

(define a (make single))
(define b (make single))

(eq? a b) @result{} #t
@end example

@c EN
The slots of the instance are initialized at the first invocation
of @code{make}.  Initargs of @code{make} are effective only in the
fist invocation, and ignored in the subsequent invocation.
@c JP
インスタンスのスロットは最初の @code{make} の呼び出し時に
初期化されます。@code{make}への初期引数は最初の呼び出しのときに
だけ効果があり、それ以降の呼び出しでは無視されます。
@c COMMON
@end deftp

@deffn {Method} instance-of (class <singleton-meta>) &rest initargs
@c EN
This method just calls @code{make} with the passed arguments.
It is more obvious in the program that you're dealing with singleton.
@c JP
このメソッドは渡された引数とともに @code{make} を呼んでいるだけです。
シングルトンを扱うプログラム中ではこちらの方が分りやすいでしょう。
@c COMMON
@end deffn

@deftp {Class} <singleton-mixin>
@clindex singleton-mixin
@c EN
An instance of @code{<singleton-meta>}.  Instead of specifying
@code{<singleton-meta>} as the @code{:metaclass} argument of
@code{define-class}, you can inherit this class to give your
class the property of singleton.
@c JP
@code{<singleton-meta>}のインスタンスです。@code{<singleton-meta>}
を @code{define-class} の @code{:metaclass} 引数として指定せずに、
このクラスを継承することで、定義しようとするクラスにシングルトンの
性質を与えることができます。
@c COMMON
@end deftp

@c ----------------------------------------------------------------------
@node Slot with validator, Networking, Singleton, Library modules - Gauche extensions
@section @code{gauche.mop.validator} - Slot with validator
@c NODE Validator付きスロット, @code{gauche.mop.validator} - Validator付きスロット

@deftp {Module} gauche.mop.validator
@mdindex gauche.mop.validator
@c EN
Provides a metaclass that adds @code{:validator} slot option.
@c JP
@code{:validator}スロットオプションを追加するメタクラスを提供するモジュールです。
@c COMMON
@end deftp

@deftp {Class} <validator-meta>
@clindex validator-meta
@c EN
This metaclass adds a feature that the class can validate a value
before being set to the slot.   For example, if you want to guarantee
that a certain slot always holds a string value, you can make a procedure
be called before the slot is modified, either by @code{slot-ref} or
by a setter method.  In the procedure you can either rejects a
value except string, or coerce the value to a string.

The validator procedure can be set per each slot by using @code{:validator}
slot option.  The procedure takes two values, the instance and
the value to be set.  Whatever the procedure returns is set to
the actual slot value.
See the following example:
@c JP
このメタクラスは、スロットに対して値がセットされようとする時にその値の正当性を
検査する手続きを指定する機能を提供します。例えば、あるスロットに常に文字列のみが
セットされているようにしたい場合、そのスロットに、@code{slot-ref}経由であれ
アクセサメソッド経由であれ値がセットされようとした時に指定の手続きが呼ばれるように
し、その手続きの中で、値が文字列でなかったらエラーとするか、強制的に値を
文字列に変換してしまうことができます。その手続きが返した値が実際にスロットに
セットされます。

検査手続きは@code{:validator}スロットオプションによってスロット毎に指定できます。
手続きは、インスタンスとセットされようとしている値の二つを引数に取ります。
その手続きが返した値が実際にスロットにセットされる値となります。
下の例を参照して下さい。
@c COMMON

@example
(define-class <v> ()
  ((a :accessor a-of
      :validator (lambda (obj value) (x->string value)))
   (b :accessor b-of
      :validator (lambda (obj value)
                   (if (integer? value)
                       value
                       (error "integer required for slot b")))))
  :metaclass <validator-meta>)

(define v (make <v>))
(slot-set! v 'a 'foo)
(slot-ref v 'a) @result{} "foo"

(set! (a-of v) 1234)
(a-of v) @result{} "1234"

(slot-set! v 'b 55)
(slot-ref v 'b) @result{} 55

(slot-set! v 'b 3.4) @result{} @r{error}
(set! (b-of v) 3.4)  @result{} @r{error}
@end example

@c EN
You can specify default slot value (@code{:init-value} etc.) with
@code{:validator}.  In that case, the initialization method of the
instance calls the validator with the specified default value,
if :init-keyword is not given.
@c JP
@code{:validator} が指定されたスロットにも、@code{:init-value}等を
使って既定の初期値を指定しておくことができます。その場合、インスタンスの初期化ルーチンは、
init-keywordによる初期値指定が無ければ既定の初期値を引数としてvalidator手続きを
呼び出します。
@c COMMON

@example
(define-class <v> ()
  ((a :initform 'foo :init-keyword :a
      :validator (lambda (obj value) (x->string value)))))

(slot-ref (make <v>) 'a)        @result{} "foo"
(slot-ref (make <v> :a 555) 'a) @result{} "555"
@end example

@c EN
It looks similar to the virtual slot, but note that a slot with
validator has an actual storage in the instance, while a virtual
slot doesn't.

It is also a good example of customizing how the slots are accessed
using the metaobject protocol.  This feature is implemented by
only couple of dozen lines of code.
@c JP
仮想スロットに似ていますが、validatorを持つスロットはインスタンス内に実際に
値を格納している点が異なります。

このモジュールはまた、スロットのアクセスをメタオブジェクトプロトコルを使って
カスタマイズする例でもあります。この機能は20行ほどのコードで実現されています。
@c COMMON
@end deftp

@c ----------------------------------------------------------------------
@node Networking, Parameters, Slot with validator, Library modules - Gauche extensions
@section @code{gauche.net} - Networking
@c NODE ネットワーキング, @code{gauche.net} - ネットワーキング

@deftp {Module} gauche.net
@mdindex gauche.net
@c EN
Provides a set of functions necessary for network communications
based on BSD socket interface.

The API is provided in two different levels.  Lower level routines
reflect traditional BSD socket interface, such as @code{bind(2)}.
Higher level routines provides more convenient way to create
typical connection-oriented server/client sockets.

This module also provides APIs to obtain various information
about hostnames, service ports, and protocols.
@c JP
BSDソケットに基づいたネットワーキングに必要な手続きを提供するモジュールです。

2つのレベルのAPIが定義されています。低レベルの手続きは@code{bind(2)}のような
BSDソケットインタフェースに近いインタフェースを提供し、高レベルの手続きは
典型的なコネクション指向のクライアントサーバアプリケーションに便利な
インタフェースを提供します。

また、ホストネームやプロトコルに関する情報にアクセスするAPIも定義されます。
@c COMMON
@end deftp


@menu
* Socket address::              
* High-level network functions::  
* Low-level socket interface::  
* Netdb interface::             
@end menu

@node Socket address, High-level network functions, Networking, Networking
@subsection Socket address
@c NODE ソケットアドレス

@deftp {Builtin Class} <sockaddr>
@clindex sockaddr
@c EN
An abstract base class of socket addresses.  Each socket address family
is implemented as a subclass of this class.

Although socket addresses are built-in classes, you can use
@code{make} method to create an instance of a
specific socket address family.
@c JP
ソケットアドレスの抽象ベースクラスです。
ソケットアドレスファミリはこのクラスのサブクラスとして実装されます。

ソケットアドレスはビルトインクラスですが、@code{make}メソッドで
特定のソケットアドレスファミリのインスタンスを作成することができます。
@c COMMON
@end deftp

@deffn {Generic Function} sockaddr-family addr
@c EN
Returns a symbol that indicates the family of the socket address
@var{addr}.
@c JP
ソケットアドレス@var{addr}のファミリを表すシンボルを返します。
@c COMMON
@end deffn

@deffn {Generic Function} sockaddr-name addr
@c EN
Returns a string which represents the content of the socket address
@var{addr}.
@c JP
ソケットアドレス@var{addr}の名前を表す文字列を返します。
@c COMMON
@end deffn

@deftp {Builtin Class} <sockaddr-in>
@clindex sockaddr-in
@c EN
AF_INET family socket address.  To create an instance of this class,
use @code{make} method as follows:
@c JP
AF_INETファミリのソケットアドレスです。このクラスのインスタンスを
作成するには、次のようにして@code{make}メソッドを呼びます。
@c COMMON
@example
(make <sockaddr-in> :host @var{host} :port @var{port})
@end example
@c EN
@var{host} can be a string, or one of the keywords
@code{:any}, @code{:broadcast}, @code{:none} or @code{:loopback}.
If it is a string, it is either a host name or a dotted IP notation.
Gauche uses @code{gethostbyname(3)} to obtain the actual IP address from
@var{host} parameter.  If it is a keyword @code{:any}, 
or @code{:broadcast}, the address
uses @code{INADDR_ANY}, or @code{INADDR_BROADCAST}
respectively.  The keyword @code{:loopback} is a synonym to the
IPv4 loopback address "127.0.0.1".
@c JP
@var{host}は文字列か、
@code{:any}、@code{:broadcast}、@code{:none}、@code{:loopback}の
いずれかのキーワードでなければなりません。
文字列の場合、それはホスト名かIPアドレスのドット表記です。
Gaucheは@code{gethostbyname(3)}を使って実際のIPアドレスを得ます。
この値がキーワード@code{:any}か@code{:broadcast}なら、それぞれ
@code{INADDR_ANY}か@code{INADDR_BROADCAST}がアドレスとして使われます。
キーワード@code{:loopback}はIPv4のループバックアドレス"127.0.0.1"を表します。
@c COMMON

@c EN
@var{port} must be a positive integer indicating the port number.
@c JP
@var{port}はポート番号を示す正の整数です。
@c EN
See also @code{make-sockaddrs} below, to create multiple
socket addresses on the machine which may have more than one
protocol stack.
@c JP
2つ以上のプロトコルスタックを持つようなマシン上で複数のソケットアドレスを
生成するには、後述の @code{make-sockaddrs} も参照してください。
@c COMMON
@end deftp

@deffn {Method} sockaddr-family (addr <sockaddr-in>)
@c EN
Returns a symbol @code{inet}.
@c JP
シンボル@code{inet}を返します。
@c COMMON
@end deffn

@deffn {Method} sockaddr-name (addr <sockaddr-in>)
@c EN
Returns a string in the form "@var{a}.@var{b}.@var{c}.@var{d}:@var{port}",
 where "@var{a}.@var{b}.@var{c}.@var{d}" is dotted decimal notion of
the IP address and @var{port} is the port number.
@c JP
文字列"@var{a}.@var{b}.@var{c}.@var{d}:@var{port}"を返します。
コロンの前はIPアドレスのドット表記で、@var{port}はポート番号です。
@c COMMON
@end deffn

@deffn {Method} sockaddr-addr (addr <sockaddr-in>)
@c EN
Returns the IP address as an integer.
@c JP
IPアドレスを整数で返します。
@c COMMON
@end deffn

@deffn {Method} sockaddr-port (addr <sockaddr-in>)
@c EN
Returns the port number as an integer.
@c JP
ポート番号を整数で返します。
@c COMMON
@end deffn

@deftp {Builtin Class} <sockaddr-un>
@clindex sockaddr-un
@c EN
AF_UNIX family socket address.  To create an instance of this class,
use @code{make} method as follows:
@c JP
AF_UNIXファミリのソケットアドレスです。このクラスのインスタンスを作成するには、
@code{make}メソッドを次のように呼んで下さい。
@c COMMON
@example
(make <sockaddr-un> :path @var{path})
@end example
@c EN
@var{path} must be a string specifying pathname of the socket.
@c JP
@var{path}はソケットのパス名を表す文字列です。
@c COMMON
@end deftp

@deffn {Method} sockaddr-family (addr <sockaddr-un>)
@c EN
Returns a symbol @code{unix}.
@c JP
シンボル@code{unix}を返します。
@c COMMON
@end deffn

@deffn {Method} sockaddr-name (addr <sockaddr-un>)
@c EN
Returns a pathname of the socket address.
@c JP
ソケットアドレスのパス名を返します。
@c COMMON
@end deffn

@deftp {Builtin Class} <sockaddr-in6>
@clindex sockaddr-in6
@c EN
AF_INET6 family socket address.  This is only avalable if
gauche is configured with --enable-ipv6 configure option.
The constructor and the slots are the same as @code{<sockaddr-in>}.
@c JP
AF_INET6ファミリのソケットアドレスです。
このクラスはgaucheが--enable-ipv6つきでconfigureされている場合に使えます。
コンストラクタとスロットは@code{<sockaddr-in>}と同じです。
@c EN
See also @code{make-sockaddrs} below, to create multiple
socket addresses on the machine which may have more than one
protocol stack.
@c JP
2つ以上のプロトコルスタックを持つようなマシン上で複数のソケットアドレスを
生成するには、後述の @code{make-sockaddrs} も参照してください。
@c COMMON
@end deftp

@defun make-sockaddrs host port &optional proto
@c EN
This is a higher-level utility procedure to create all possible
inet domain socket addresses that point to @code{@var{host}:@var{port}}
of protocol @var{proto}.  Particularly, if the specified host has
both IPv4 and IPv6 addresses, and the running system supports both,
then both IPv4 and IPv6 socket addresses are returned.   If @var{host} has
multiple IP addresses, socket addresses are created for each of these
IP address.   You can make your network application much more portable
among different network stack configurations.

Passing @code{#f} to @var{host} creates the local
(server) address.  You can also pass a service name (e.g. @code{"http"})
instead of an integer, to the @var{port} argument.
The value of @var{proto} can be either a symbol @code{tcp} or @code{udp},
and the default is @code{tcp}.

It always returns a list of socket addresses.  If the lookup of @var{host}
is failed, null list is returned.
@c JP
これは上位レベルのユーティリティ手続きで、プロトコル @var{proto} の
@code{@var{host}:@var{port}} を指す、可能なすべてのドメインソケット
アドレスを生成します。特に、指定したホストが IPv4 および IPv6 の両方の
アドレスを持ち、稼働中のシステムがその両方をサポートしている場合、IPv4 と
IPv6 の両方のソケットアドレスが返ります。もし、@var{host} が複数の
IP アドレスをもつ場合、ソケットアドレスはそれぞれのIPアドレス毎に生成
されます。自分のネットワークアプリケーションを異るネットワークスタックの
設定の間でこれまでよりはるかにポータブルなものにすることができます。

@var{host} に @code{#f} を渡すと、ローカルな(サーバ)アドレスが生成されます。
@var{port} 引数に整数のかわりに、サービス名(たとえば、@code{"http"})を
わたすこともできます。@var{proto} の値は、@code{tcp} あるいは @code{udp}
のどちらかのシンボルになります。デフォルトでは、@code{tcp} です。

この手続きは常にソケットアドレスのリストを返します。もし、@var{host} の
検索に失敗した場合には、空リストが返ります。
@c COMMON
@end defun


@node High-level network functions, Low-level socket interface, Socket address, Networking
@subsection High-level network functions
@c NODE 高レベルネットワーク手続き

@deftp {Builtin Class} <socket>
@clindex socket
@c EN
Abstracts a socket, a communication endpoint.

For a connection-oriented socket, you can access the communication
channel by two ports associated to the socket, one for input and
another for output.  @code{socket-input-port} and @code{socket-output-port}
returns those ports, respectively.
@c JP
コミュニケーション終端であるソケットを表すクラスです。

コネクション型のソケットに対しては、2つのポート(入力用と出力用)を使って
コミュニケーションチャネルにアクセスすることができます。
@code{socket-input-port}と@code{socket-output-port}がこれらのポートを
それぞれ返します。
@c COMMON
@end deftp

@c EN
The following two functions are convenient ways to create
a connection-oriented socket.  Those functions
are to provide an easy methods for typical cases,
but have less control.  If you need more than these functions
provide, use low-level interface.
@c JP
以下の2つの手続きはコネクション型のソケットを作成する
便利な手続きです。これらは典型的な場合に対する簡単な方法を提供しますが、
細かい制御はできません。動作のより細かい制御が必要な場合は低レベルAPIを
見て下さい。
@c COMMON

@defun make-client-socket &optional address-spec @dots{}
@c EN
Creates and returns a client socket, connected to the address
specified by @var{address-spec} @dots{}.
@c JP
引数@var{address-spec} @dots{} によって指定されるアドレスと通信する
クライアントソケットを作成して返します。
@c COMMON

@table @code
@item (make-client-socket 'unix @var{path})
@c EN
The client socket is connected to the unix domain server socket
of addreess @var{path}.
@c JP
@var{path}で待っているUnixドメインのサーバーソケットに接続します。
@c COMMON
@item (make-client-socket 'inet @var{host} @var{port})
@c EN
The client socket is connected to the inet domain server socket
with hostname @var{host} and port @var{port}.   TCP protocol is
assumed.   @var{host} can be either a hostname, or
a dotted decimal notation of IPv4 address.
If gauche is compiled with --enable-ipv6, IPv6 address notation
can also be used.  @var{Port} must be an exact integer specifying
a port number, or a string service name (e.g. @code{"http"}).

If gauche is compiled with --enable-ipv6, and the hostname is given,
and the hostname has both IPv6 and IPv4 addresses, then
IPv6 connection is tried first, and IPv4 is used when IPv6 fails.
@c JP
ホスト@var{host}のポート@var{port}で待っているInetドメインのサーバーソケットに
TCPを使って接続します。@var{host}はIPアドレスのドット表記でもホスト名でも
構いません。Gaucheが--enable-ipv6でコンパイルされていれば、IPv6形式のアドレス
表記も受け付けます。
@var{port}はポート番号を指定する正確な整数か、文字列のサービス名
(@code{"http"}等)でなければなりません。

Gaucheが--enable-ipv6でコンパイルされており、ホスト名が渡されて、
そのホストがIPv6とIPv4の両方のアドレスを持っていた場合は、
最初にIPv6での接続が試みられ、それが失敗した場合にIPv4での接続が試みられます。
@c COMMON
@item (make-client-socket @var{host} @var{port})
@c EN
This works the same as above.  This form is for compatibility with STk.
@c JP
上と同じです。この形式はSTkとの互換性のために提供されています。
@c COMMON
@item (make-client-socket @var{sockaddr})
@c EN
If an instance of @code{<sockaddr>} is passed,
a socket suitable for @var{sockaddr} is opened and then connected
to the given address.
@c JP
@code{<sockaddr>}のインスタンスが渡された場合には、それに対応する
ソケットがオープンされ、そのアドレスへと接続されます。
@c COMMON
@end table

@c EN
This function raises an error if it cannot create a socket,
or cannot connect to the specified address.
@c JP
ソケットを作成できなかったり、指定されたアドレスに接続できなかった場合は
エラーが報告されます。
@c COMMON

@example
(make-client-socket 'inet "www.w3.com" 80)
  @result{} ;@r{a socket connected to www.w3.com, port 80}
(make-client-socket "127.0.0.1" 23)
  @result{} ;@r{a socket connected to localhost, port 23}
(make-client-socket 'unix "/tmp/.sock"
  @result{} ;@r{a socket connected to a unix domain socket "/tmp/.sock"}
@end example
@end defun

@defun make-server-socket &optional address-spec @dots{}
@c EN
Creates and returns a server socket, listening the address
specified by @var{address-spec}.
@c JP
@var{address-spec}にて接続を待つサーバソケットを作成して返します。
@c COMMON

@table @code
@item (make-server-socket 'unix @var{path})
@c EN
The socket is bound to a unix domain socket with a name @var{path}.
@c JP
パス名@var{path}を持つUnixドメインソケットが作成されます。
@c COMMON
@item (make-server-socket 'inet @var{port} [:reuse-addr? @var{flag}] [:sock-init @var{proc}])
@c EN
The socket is bound to an inet domain TCP socket, listening
port @var{port}, which must be a non-negative exact integer
or a string service name (e.g. @code{"http"}).
If @var{port} is zero, the system assigns one of available port numbers.
If a keyword argument @var{reuse-addr?} is given and true,
@code{SO_REUSEADDR} option is set to the socket before bound to
the port.  This allows the process to bind the server socket
immediately after other process releases the port.
@c JP
ポート@var{port}にて接続を待つInetドメインのTCPソケットが作成されます。
@var{port}は非負の整数か、文字列のサービス名(@code{"http"}等)でなければなりません。
@var{port}が0の場合はシステムが適当なポート番号を割り当てます。
キーワード引数@var{reuse-addr?}に真の値が与えられた場合は、
ソケットに@code{SO_REUSEADDR}オプションがセットされます。
このオプションをセットすると、他のプロセスがそのポートを使わなくなったら直ちに
このプロセスがそのポートを使うことができます。
@c COMMON

@c EN
If keyword argument @code{sock-init} is given, it should be a procedure
that takes two arguments, a created socket and the socket address.
The procedure is called just after the socket is created.  It is
useful to set some special socket options.
@c JP
キーワード引数@code{sock-init}が与えられた場合、それは
2つ引数を取る手続きでなければなりません。その手続きは
ソケットが作られた直後に、ソケットとアドレスを引数にして呼び出されます。
特殊なソケットオプションを設定したいような場合に使えます。
@c COMMON
@item (make-server-socket @var{port} [:reuse-addr? @var{flag}] [:sock-init @var{proc}])
@c EN
This is a synonym to the above form (except @var{port} must be 
an integer).  This form is backward-compatible
with STk's @code{make-server-socket}.
@c JP
これは、@var{port}が整数でなければならないことを除けば、
上の形式と同じ動作をします。STkの@code{make-server-socket}との
互換性のために提供されています。
@c COMMON
@item (make-server-socket @var{sockaddr} [:reuse-addr? @var{flag}][:sock-init @var{proc}])
@c EN
This form explicitly specifies the socket address to listen
by an instance of @code{<sockaddr>}.
@c JP
この形式は、listenするソケットアドレスを@code{<sockaddr>}のインスタンスで
明示的に指定します。
@c COMMON
@end table

@example
(make-server-socket 'inet 8080)
  @result{} #<socket (listen "0.0.0.0:8080")>
(make-server-socket 8080)
  @result{} #<socket (listen "0.0.0.0:8080")>
(make-server-socket 'inet 0)
  @result{} #<socket (listen "0.0.0.0:35628")>
(make-server-socket 'unix "/tmp/.sock")
  @result{} #<socket (listen "/tmp/.sock")>
@end example
@end defun

@defun make-server-sockets host port &keyword reuse-addr? sock-init
@c EN
Creates one or more sockets that listen at @var{port}
on all available network interfaces of @var{host}.
You can specify a service name (such as "@code{http}") to
@var{port}, as well as an integer port number.
Returns a list of opened, bound and listened sockets.

This procedure is particularly useful when the host
has multiple protocol stacks, such as IPv4 and IPv6; in which
case, you can start a server that listenes both protocol
using @code{make-server-sockets}.

The meaning of keyword arguments are the same as of @code{make-server-socket}.
@c JP
@var{host} のすべての利用可能なネットワークインタフェース上の
@var{port} をリッスンする1つ以上のソケットを生成します。
@var{port} に対しては数字のポート番号と同様に、サービス名を
指定できます。たとえば、"@code{http}" です。この手続きは
オープンされ、バインドされ、リッスンされたソケットのリストを
返します。

この手続きは、ホストが複数のプロトコルスタック(IPv4とIPv6など)を
持つ場合に特に便利です。このような場合、両方のプロトコルで
リッスンするようなサーバを @code{make-server-sockets} をつかって、
スタートすることができます。

キーワード引数の意味は@code{make-server-socket}のそれと同じです。
@c COMMON
@end defun

@c EN
Several accessors are available on the returned socket object.
@c JP
返されたソケットオブジェクトに対して、以下のようなアクセサを適用することができます。
@c COMMON

@defun socket-address socket
@c EN
Returns a socket address associated with @var{socket}.
If no address has been associated to the socket, @code{#f} is returned.
@c JP
ソケット@var{socket}のアドレスを返します。
ソケットにアドレスがまだバインドされていない場合は@code{#f}が返ります。
@c COMMON
@end defun

@defun socket-input-port socket &keyword (buffering @code{:modest})
@defunx socket-output-port socket &keyword (buffering @code{:line})
@c EN
Returns an input and output port associated with @var{socket},
respectively.
@c JP
@var{socket}からデータを読みだす入力ポート、または
@var{socket}にデータを書き出す出力ポートを返します。
@c COMMON

@c EN
The keyword argument @var{buffering} specifies the buffering mode
of the port.  @xref{File ports}, for explanation of the
buffering mode.
@c JP
キーワード引数@var{buffering}はポートのバッファリングモードを
指定します。バッファリングモードの説明は@ref{File ports}を見て下さい。
@c COMMON
@end defun

@defun socket-close socket
@c EN
Closes @var{socket}.  All the ports associated to
@var{socket} are closed as well.   If the socket is connected,
@c JP
ソケット@var{socket}をクローズします。@var{socket}の入出力ポートも
クローズされます。

@c EN
Note: as of release 0.7.2, this procedure does not shutdown
the connection.  It is because @var{socket} may be referenced
by forked process(es) and you might want to close it without
interfering the existing connection.   You can call
@code{socket-shutdown} to shutdown the connection explicitly.

@c JP
注意: リリース 0.7.2 より、この手続きは接続をシャットダウンしないように
なりました。その理由は、@var{socket} が fork した別プロセスから参照され
ている可能性があり、既存の接続を妨害することなくクローズしたい場合がある
からです。@code{socket-shutdown} を呼べば接続を明示的にシャットダウンできます。
@c COMMON
@end defun

@defun call-with-client-socket socket proc
@c EN
@var{socket} must be a connected client socket.  @var{proc} is called
with two arguments, an input port that reads from the socket
and an output port that writes to the socket.
The socket is closed after @var{proc} returns or @var{proc}
raises an error.
@c JP
@var{socket}は接続されたクライアントソケットでなければなりません。
@var{proc}がソケットから読み出す入力ポートと、
ソケットに書き出す出力ポートを引数として呼ばれます。
@var{proc}が正常終了するか、エラーを投げた場合にソケットは閉じられます。
@c COMMON
@end defun

@c EN
This is an example of usage of high-level socket functions,
a very simple http client.
@c JP
これは高レベルソケット手続きを使った、非常に単純なhttpクライアントです。
@c COMMON

@example
#!/usr/bin/env gosh
(use gauche.regexp)
(use gauche.net)

(define (usage)
  (display "Usage: swget url\n" (current-error-port))
  (exit 1))

;; Returns three values: host, port, and path.
(define (parse-url url)
  (rxmatch-let (rxmatch #/^http:\/\/([-A-Za-z\d.]+)(:(\d+))?(\/.*)?/ url)
      (#f host #f port path)
    (values host port path)))

(define (get url)
  (receive (host port path) (parse-url url)
    (call-with-client-socket
        (make-client-socket 'inet host (string->number (or port "80")))
      (lambda (in out)
        (format out "GET ~a HTTP/1.0\r\n" path)
        (format out "host: ~a\r\n\r\n" host)
        (flush out)
        (copy-port in (current-output-port))))))

(define (main args)
  (if (= (length args) 2)
      (get (cadr args))
      (usage))
  0)
@end example


@node Low-level socket interface, Netdb interface, High-level network functions, Networking
@subsection Low-level socket interface
@c NODE 低レベルソケットインタフェース

@c EN
These functions provide APIs similar to the system calls.
Those who are familiar to programming with socket APIs will
find these functions useful since you can have more detailed control over
the sockets.
@c JP
ここにある関数群はシステムコールと類似した API を提供します。
ソケット API プログラミングに慣れていれば、ソケットをより細かく
制御できるので、役に立つでしょう。
@c COMMON

@defun make-socket domain type &optional protocol
@c EN
Returns a socket with specified parameters.
@c JP
パラメータで指定したソケットを返します。
@c COMMON
@end defun

@defvar PF_UNIX
@defvarx PF_INET
@c EN
These variables are bound to @code{PF_UNIX} and @code{PF_INET}.
@c JP
これらの変数はそれぞれ、@code{PF_UNIX}、@code{PF_INET}
に束縛されています。
@c COMMON
@end defvar

@defvar AF_UNIX
@defvarx AF_INET
@c EN
These variables are bound to @code{AF_UNIX} and @code{AF_INET}.
@c JP
これらの変数はそれぞれ、@code{AF_UNIX}、@code{AF_INET}
に束縛されています。
@c COMMON
@end defvar

@defvar SOCK_STREAM
@defvarx SOCK_DGRAM
@defvarx SOCK_RAW
@c EN
These variables are bound to @code{SOCK_STREAM}, @code{SOCK_DGRAM}
and @code{SOCK_RAW}.
@c JP
これらの変数はそれぞれ、@code{SOCK_STREAM}、@code{SOCK_DGRAM}、
@code{SOCK_RAW} に束縛されています。
@c COMMON
@end defvar

@defun socket-fd socket
@c EN
Returns an integer system file descriptor of the underlying socket.
@c JP
ソケットのもつ整数のシステムファイルディスクリプタを返します。
@c COMMON
@end defun


@defun socket-status socket
@c EN
Returns a internal status of @var{socket}, by one of the following
symbols.
@multitable {aaaaaaaaaaaaaaaaa} {aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}
@item none
@tab The socket is just created.
@item bound
@tab The socket is bound to an address by @code{socket-bind}
@item listening
@tab The socket is listening a connection by @code{socket-listen}
@item connected 
@tab The socket is connected by @code{socket-connect} or @code{socket-accept}.
@item shutdown
@tab The socket is shutdown by @code{socket-shutdown}
@item closed
@tab The socket is closed by @code{socket-close}.
@end multitable
@c JP
@var{socket} の内部状態を、以下のシンボルのどれかで返します。
@multitable {aaaaaaaaaaaaaaaaa} {aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}
@item none
@tab 生成直後
@item bound
@tab @code{socket-bind} によって、あるアドレスに束縛されている
@item listening
@tab @code{socket-listen} によって、接続をリッスンしている
@item connected 
@tab @code{socket-connect} あるいは @code{socket-accept} によって接続されている
@item shutdown
@tab @code{socket-shutdown} によってシャットダウンされた
@item closed
@tab @code{socket-close} によってクローズされた
@end multitable
@c COMMON
@end defun

@defun socket-bind socket address
@c EN
Binds @var{socket} to the local network address @var{address}.
It is usually used to associate specific address to the server port.
If binding failed, an error is signalled (most likely the address is
already in use).

For the inet domain address, you can pass @var{address} with port=0;
the system assigns the port number and sets the actual address to
the @code{address} slot of @var{socket}.
@c JP
@var{socket} をローカルネットワークアドレス @var{address} に束縛します。
通常は、特定のアドレスをこのサーバのポートに結びつけるのに用います。
もし、束縛が失敗したら(多くの場合、そのアドレスが既に使用されている)、
エラーシグナルが発生します。

INET ドメインアドレスの場合には port=0 とした @var{address} を
渡せます。システムがポート番号を割当て、@var{socket} の
@code{address} スロットに実際のアドレスをセットします。
@c COMMON
@end defun

@defun socket-listen socket backlog
@c EN
Listens @var{socket}.  The socket must be already bound to some
address.  @var{backlog} specifies maximum number of connection
requests to be queued.
@c JP
@var{socket} をリッスンします。ソケットは既になんらかのアドレスに
束縛されていなければなりません。@var{backlog} はキューに入れる
接続要求の最大数を指定します。
@c COMMON
@end defun

@defun socket-accept socket
@c EN
Accepts a connection request coming to @var{socket}.
Returns a new socket that is connected to the remote entity.
The original @var{socket} keeps waiting for further connections.
If there's no connection requests, this call waits for one to come.

You can use @code{sys-select} to check if there's a pending connection
request.
@c JP
@var{socket}に来た接続要求をアクセプトします。リモートエンティティへ
接続している新しいソケットを返します。元の @var{socket} は引き続き
次の接続要求を待ちます。接続要求がないとき、これの呼出しは要求が
一つ来るまで待ちます。

接続要求をペンディングしているかどうかをチェックするのに
@code{sys-select}が使えます。
@c COMMON
@end defun

@defun socket-connect socket address
@c EN
Connects @var{socket} to the remote address @var{address}.
This is the way for a client socket to connect to the remote entity.
@c JP
@var{socket} をリモートアドレス @var{address} に接続します。
これは、クライアントソケットをリモートエンティティに接続するための
方法です。
@c COMMON
@end defun

@defun socket-shutdown socket how
@c EN
Shuts down connection of @var{socket}.  If @var{how} is 0, the receive
channel of @var{socket} is disallowed.  If @var{how} is 1, the send
channel of @var{socket} is disallowed.  If @var{how} is 2, both
receive and send channels are disallowed.
It is an error to call this function on a non-connected socket.

If you shut down the send channel of the socket, the remote peer
sees EOF from its receive channel.  This is useful if the remote peer
expects EOF before sending something back to you.
@c JP
@var{socket} の接続をシャットダウンします。@var{how} が0なら、
@var{socket} の受信チャネルが不許可となります。@var{how} が1なら、
@var{socket} の送信チャネルが不許可となります。@var{how} が2なら、
@var{socket} の送受信チャネルの両方が不許可となります。
接続していないソケットに対して、この手続きを呼ぶとエラーになります。

ソケットの送信チャネルをシャットダウンすると、リモート側の受信チャネル
に EOF があらわれます。これは、リモート側が何かを送り返す前に EOF
を受けとることを期待している場合、便利です。
@c COMMON
@end defun

@defun socket-getsockname socket
@c EN
Returns a @code{<sockaddr>} instance that is the local address of
@var{socket}.
@c JP
@var{socket}のローカル側アドレスを表す@code{<sockaddr>}インスタンスを返します。
@c COMMON
@end defun

@defun socket-getpeername socket
@c EN
Returns a @code{<sockaddr>} instance that is the peer address of
@var{socket}.
@c JP
@var{socket}の通信相手のアドレスを表す@code{<sockaddr>}インスタンスを返します。
@c COMMON
@end defun

@defun socket-send socket msg &optional flags
@defunx socket-sendto socket msg to-address &optional flags.
@c EN
Interfaces to @code{send(2)} and @code{sendto(2)}, respectively.
Transmits the content of @var{msg} (string) through @var{socket}.
When @code{socket-send} is used, @var{socket} must already be connected.
On the other hand, @code{socket-setdto} can be used for non-connected
socket, and the destination address is specified by 
a @code{<sockaddr>} instance @var{to-address}.
@c JP
それぞれ、@code{send(2)} および @code{sendto(2)} へのインタフェース。
@var{msg} の内容(文字列)を @var{socket} を通じて送出します。
@code{socket-send} を使うときには、@var{socket} は既に接続されて
いなければなりません。他方、@code{socket-setdto} は未接続の
ソケットに対して使用でき、送出先アドレスは @code{<sockaddr>} のインスタンス
@var{to-address} で指定します。
@c COMMON

@c EN
The optional @var{flags} can be a bitwise OR of the integer
constants @code{MSG_*}.  See the system's manpage of @code{send(2)}
and @code{sendto(2)} for the details.
@c JP
オプション引数 @var{flags} は整数定数 @code{MSG_*} のビット毎のORで
指定できます。詳しくはシステムの man ページ @code{send(2)} および
@code{sendto(2)} を見て下さい。
@c COMMON
@end defun

@defun socket-recv socket bytes &optional flags
@defunx socket-recvfrom socket bytes &optional flags
@c EN
Interfaces to @code{recv(2)} and @code{recvfrom(2)}, respectively.
Receives a message up to the @var{bytes} bytes from a socket
@var{socket}.  @code{socket-recv} should be used with a connected socket,
whereas @code{socket-recvfrom} can be used with non-connected socket.
@c JP
それぞれ、@code{recv(2)} および @code{recvfrom(2)} へのインタフェース。
ソケット @var{socket} から @var{bytes} バイトまでのメッセージを受信します。
@code{socket-recv} は接続済みのソケットを使わなければなりませんが、
他方、@code{socket-recvfrom} は未接続のソケットを使えます。
@c COMMON

@c EN
@code{socket-recv} returns a received message as a (possibly incomplete)
string.   @code{socket-recvfrom} returns two values, a received message
and the sender's socket address.
@c JP
@code{socket-recv} は(不完全なものである可能性もある)文字列として受信した
メッセージを返します。@code{socket-recvfrom} は値を2つ返し、一つは受信した
メッセージ、もうひとつは送信者のソケットアドレスです。
@c COMMON

@c EN
The optional @var{flags} can be a bitwise OR of the integer
constants @code{MSG_*}.  See the system's manpage of @code{recv(2)}
and @code{recvfrom(2)} for the details.
@c JP
オプション引数 @var{flags} は整数定数 @code{MSG_*} のビット毎のORで
指定できます。詳しくはシステムの man ページ @code{recv(2)} および
@code{recvfrom(2)} を見て下さい。
@c COMMON
@end defun

@defvar MSG_CTRUNC
@defvarx MSG_DONTROUTE
@defvarx MSG_EOR
@defvarx MSG_OOB
@defvarx MSG_PEEK
@defvarx MSG_TRUNC
@defvarx MSG_WAITALL
@c EN
Pre-defined integer constants to be used as @var{flags} values
for @code{socket-send}, @code{socket-sendto}, @code{socket-recv}
and @code{socket-recvfrom}.   Some of these constants may not be
defined if the underlying operating system doesn't provide them.
@c JP
@code{socket-send}、@code{socket-sendto}、@code{socket-recv} および
@code{socket-recvfrom} の @var{flag} として使う定義済み整数定数。
これらの定数のいくつかは、基盤のＯＳが提供していなければ未定義に
なっています。
@c COMMON
@end defvar

@c EN
Further control over sockets and protocol layers is possible
by getsockopt/setsockopt interface, as described below.
@c JP
以下に解説する getsockopt/setsockopt インタフェースを使えば、
ソケットやプロトコルをさらに制御することができます。
@c COMMON

@defun socket-setsockopt socket level option value
@defunx socket-getsockopt socket level option rsize
@c EN
These are the interface to setsockopt() and getsockopt() calls.
The interface is a bit clumsy, in order to allow full access to
those low-level calls.

@var{socket} must be a non-closed socket object.
@var{level} and @var{option} is an exact integer to specify
the level of protocol stack and the option you want to deal with.
There are several variables pre-bound to system constants listed below.

To set the socket option, you can pass either an exact integer or
a string to @var{value}.  If it is an integer, the value is passed
to setsockopt(2) as C @code{int} value.  If it is a string, the
byte sequence is passed as is.  The required type of value depends on
the option, and Gauche can't know if the value you passed is expected
by setsockopt(2); it is your responsibility to pass the correct values.

To get the socket option, you need to tell the maximum length of expected
result by @var{rsize} parameter, for Gauche doesn't know the amount
of data each option returns.
@code{socket-getsockopt} returns the option value as a byte string.
If you know the option value is an integer, you can pass 0 to @var{rsize};
in that case @code{socket-getsockopt} returns the value as an exact integer.

Note about the name: I tempted to name these function socket-@{set|get@}opt
or socket-@{set|get@}-option,
but I rather took the naming consistency.  Hence duplicated "sock"s.

@c JP
これらは、setsockopt() および getsockopt() を呼ぶための
インタフェースです。このインタフェースが少々ぎこちないのは、
低レベルの呼び出しすべてにアクセスできるようにしているためです。

@var{socket} および @var{option} は、処理する対象の
プロトコルスタックのレベルおよびオプションを指定する
正確な整数です。以下にリストアップしたシステム定数に束縛された
変数があります。

ソケットオプションを設定するには、@var{value} に正確な整数を渡す方法と
文字列を渡す方法があります。それが、整数なら、その値は、C の
@code{int} として setsockopt (2) に渡されます。文字列なら、バイト列が
そのまま渡されます。どの型の値が要求されるかは、オプションに依存します。
Gauche 側では渡された値が setsockopt (2) で期待された型であるかどうかは
知ることができません。正しい値が渡されるかどうかはプログラマの責任です。

ソケットオプションを知るには、結果として期待する最大の長さを @var{rsize}
を使って教える必要があります。Gauche 側は返されるそれぞれのオプションの
合計を知らないからです。
@code{socket-getsockopt} はオプションの値をバイト列として返します。
オプションの値が整数だと、わかっているなら @var{rsize} に0を渡すこと
ができます。その場合 @code{socket-getsockopt} は正確な整数として値を返します。

関数名に関する註: これらの関数の名前を socket-@{set|get@}opt あるいは
socket-@{set|get@}-option にしようかとも思いましたが、結局、命名の
一貫性をとることにしました。それで、"sock" が重複しています。
@c COMMON

@end defun

@c EN
The following predefined variables are provided.
Note that some of them are not available on all platforms.
See manpages @code{socket(7)}, @code{tcp(7)} or @code{ip(7)} of
your system to find out exact specification of those values.

For ``level'' argument:
@c JP
以下のような定義済みの変数が用意されています。
すべてのプラットフォームで利用できるわけではないものも含まれている
ことに注意してください。
これらの値の正確な使用は、お使いのシステムの man ページ @code{socket(7)}、
@code{tcp(7)} あるいは @code{ip(7)} を参照してください。

``level'' 引数
@c COMMON
@defvar SOL_SOCKET
@defvarx SOL_TCP
@defvarx SOL_IP
@c EN
These variables are bound to @code{SOL_SOCKET}, @code{SOL_TCP} and
@code{SOL_IP}, respectively.
@c JP
これらの変数は、それぞれ、@code{SOL_SOCKET}、@code{SOL_TCP} および
@code{SOL_IP} に束縛されています。
@c COMMON
@end defvar

@c EN
For ``option'' argument:
@c JP
``option'' 引数
@c COMMON
@defvar SO_KEEPALIVE
@c EN
Expects integer value.  If it is not zero, enables sending  of
keep-alive messages on connection-oriented sockets.
@c JP
整数が期待されています。0でなければ、コネクション指向ソケットに
キープアライブ(keep-alive)メッセージを送ることができます。
@c COMMON
@end defvar

@defvar SO_OOBINLINE
@c EN
Expects integer value.  If it is not zero, out-of-band data is
directly placed into the receive data stream.  Otherwise
out-of-band  data  is  only passed when the
MSG_OOB flag is set during receiving.
@c JP
整数が期待されています。0でなければ、帯域外データは直接
受信データストリームに乗ります。さもなければ、帯域外データは、受信中に
MSG_OOBフラグが設定されてたときにのみ渡されます。
@c COMMON
@end defvar

@defvar SO_REUSEADDR
@c EN
Expects integer value.  If it is not zero, @code{socket-bind}
allows to reuse local addresses, unless an active listening
socket bound to the address.
@c JP
整数が期待されています。0ではない場合、@code{socket-bind}は、
ローカル・アドレスが、アクティブソケットにリッスンされていない
場合にかぎり、そのアドレスを再利用することを許可されます。

@c COMMON
@end defvar

@defvar SO_TYPE
@c EN
Gets the socket type as an integer (like @code{sock_stream}).
Can be only used with @code{socket-getsockopt}.
@c JP
ソケットの型(@code{sock_stream}など)を整数として取得します。
@code{socket-getsockopt}でのみ使用可能です。
@c COMMON
@end defvar

@defvar SO_BROADCAST
@c EN
Expects integer value.  If it is not zero, datagram sockets
are allowed to send/receive broadcast packets.
@c JP
整数が期待されています。0でなければ、データグラムソケットは
ブロードキャストパケットを送受信することを許されます。
@c COMMON
@end defvar

@defvar SO_PRIORITY
@c EN
Expects integer value, specifying the protocol-defined priority
for all packets to be sent on this socket.
@c JP
整数が期待されています。このソケットで送信されるすべてのパケットに
ついてプロトコル定義の優先順位を指定します。
@c COMMON
@end defvar

@defvar SO_ERROR
@c EN
Gets and clears the pending socket error as an integer.
Can be only used with @code{socket-getsockopt}.
@c JP
保留状態のソケットエラー(整数値)を取得し、それをクリアします。
@code{socket-getsockopt}でのみ使用可能です。
@c COMMON
@end defvar

@node Netdb interface,  , Low-level socket interface, Networking
@subsection  Netdb interface
@c NODE Netdbインタフェース

@deftp {Builtin Class} <sys-hostent>
@clindex sys-hostent
@c EN
A class of objects for network hosts.  Corresponding to
@code{struct hostent} in C.  The following slots are available read-only.
@c JP
このクラスはネットワークホストのオブジェクト用で、
C の @code{struct hostent}
に対応しています。以下のスロットは読み込み専用です。
@c COMMON

@defivar {<sys-hostent>} name
@c EN
The formal name of the host (string).
@c JP
ホストの正式名(文字列)
@c COMMON
@end defivar
@defivar {<sys-hostent>} aliases
@c EN
A list of alias names of the host (list of strings).
@c JP
ホストの別名リスト(文字列のリスト)
@c COMMON
@end defivar
@defivar {<sys-hostent>} addresses
@c EN
A list of addresses (list of strings).  Only ipv4 address is 
supported currently.  Each address is represented by dotted decimal
notation.
@c JP
アドレスのリスト(文字列のリスト)。現時点では IPv4 のアドレスのみサポート
しています。それぞれのアドレスは、ドットつき十進記法で表記されています。
@c COMMON
@end defivar
@end deftp

@defun sys-gethostbyname name
@c EN
Looks up a host named @var{name}.
If found, returns a @code{<sys-hostent>} object.
Otherwise, returns @code{#f}.
@c JP
@var{name}という名まえのホストを探し、見つかれば、@code{<sys-hostent>}
オブジェクトを返します。見つからなければ、@code{#f} を返します。
@c COMMON
@example
(let ((host (sys-gethostbyname "www.w3c.org")))
  (list (slot-ref host 'name)
        (slot-ref host 'aliases)
        (slot-ref host 'addresses)))
  @result{} ("www.w3.org" ("www.w3c.org") ("18.29.1.34" "18.29.1.35"))
@end example
@end defun

@defun sys-gethostbyaddr addr proto
@c EN
Looks up a host that has an address @var{addr} of protocol @var{proto}.
@var{addr} is a natural string representation of the address;
for ipv4, it is a dotted decimal notation.  @var{proto} is a
protocol number; only @code{AF_INET} is supported currently.
If the host is found, returns a @code{<sys-hostent>} object.
Otherwise, returns @code{#f}.
@c JP
@var{proto}というプロトコルの、@var{addr}というアドレスを持つホストを
探します。@var{addr}はアドレスの自然な文字列表現で、IPv4 については、
ドットつき十進記法です。@var{proto}はプロトコル番号で、現時点では
@code{AF_INET}のみサポートされています。ホストが見つかれば、
@code{<sys-hostent>}オブジェクトを返します。
見つからなければ、@code{#f} を返します。
@c COMMON
@example
(let ((host (sys-gethostbyaddr "127.0.0.1" AF_INET)))
  (list (slot-ref host 'name)
        (slot-ref host 'aliases)
        (slot-ref host 'addresses))
  @result{} ("localhost" ("localhost.localdomain") ("127.0.0.1"))
@end example
@end defun

@deftp {Builtin Class} <sys-servent>
@clindex sys-servent
@c EN
An entry of the network service database.  Corresponding to
@code{struct servent} in C.  The following slots are available read-only.
@c JP
ネットワークサービスデータベースのエントリです。
C の @code{struct servent}に対応しています。
以下のスロットは読み込み専用です。
@c COMMON

@defivar {<sys-servent>} name
@c EN
The formal name of the service (string).
@c JP
サービスの正式名(文字列)
@c COMMON
@end defivar
@defivar {<sys-servent>} aliases
@c EN
A list of alias names of the service (list of strings).
@c JP
サービスの別名リスト(文字列のリスト)
@c COMMON
@end defivar
@defivar {<sys-servent>} port
@c EN
A port number registered for this service (exact integer).
@c JP
サービスに割り当てられたポート番号(正確な整数)
@c COMMON
@end defivar
@defivar {<sys-servent>} proto
@c EN
A protocol name for this service (string).
@c JP
このサービス用のプロトコル名(文字列)
@c COMMON
@end defivar
@end deftp

@defun sys-getservbyname name proto
@c EN
Looks up the network service database with a service name @var{name} and
a protocol @var{proto}.  Both @var{name} and @var{proto} must be a string.
If a service is found, an instance of @code{<sys-servent>} is returned.
Otherwise, @code{#f} is returned.
@c JP
ネットワークサービスデータベースをサービス名 @var{name} および
プロトコル @var{proto} で検索します。@var{name} および @var{proto}
は文字列でなければなりません。サービスが見つかれば、@code{<sys-servent>}
のインスタンスが返します。見つからなければ、@code{#f} を返します。
@c COMMON
@example
(let ((serv (sys-getservbyname "http" "tcp")))
  (list (slot-ref serv 'name)
        (slot-ref serv 'aliases)
        (slot-ref serv 'port)
        (slot-ref serv 'proto)))
  @result{} ("http" () 80 "tcp")
@end example
@end defun

@defun sys-getservbyport port proto
@c EN
Looks up the network service database with a service port @var{port} and
a protocol @var{proto}.  @var{port} must be an exact integer, and
@var{proto} must be a string.
If a service is found, an instance of @code{<sys-servent>} is returned.
Otherwise, @code{#f} is returned.
@c JP
ネットワークサービスデータベースをサービス名 @var{port} および
プロトコル @var{proto} で検索します。@var{port} は正確な整数でなければ
なりません。また、@var{proto} は文字列でなければなりません。
サービスが見つかれば、@code{<sys-servent>}
のインスタンスが返します。見つからなければ、@code{#f} を返します。
@c COMMON
@example
(let ((serv (sys-getservbyport 6000 "tcp")))
  (list (slot-ref serv 'name)
        (slot-ref serv 'aliases)
        (slot-ref serv 'port)
        (slot-ref serv 'proto)))
  @result{} ("x-server" () 6000 "tcp")
@end example
@end defun

@deftp {Builtin Class} <sys-protoent>
@clindex sys-protoent
@c EN
An entry of the protocol database.   Corresponds to @code{struct protoent}
in C.   The following slots are available read-only.
@c JP
プロトコルデータベースのエントリです。C の @code{struct protoent}に
対応しています。以下のスロットは読み込み専用です。
@c COMMON

@defivar {<sys-servent>} name
@c EN
The formal name of the protocol (string).
@c JP
プロトコルの正式名(文字列)
@c COMMON
@end defivar
@defivar {<sys-servent>} aliases
@c EN
A list of alias names of the protocol (list of strings).
@c JP
プロトコルの別名のリスト(文字列のリスト)
@c COMMON
@end defivar
@defivar {<sys-servent>} proto
@c EN
A protocol number (exact integer).
@c JP
プロトコル番号(正確な整数)
@c COMMON
@end defivar
@end deftp

@defun sys-getprotobyname name
@c EN
Looks up the network protocol database with a name @var{name},
which must be a string.
If a protocol is found, an instance of @code{<sys-protoent>} is returned.
Otherwise, @code{#f} is returned.
@c JP
名前 @var{name} でネットワークプロトコルデータベースを検索します。
名前 @var{name} は文字列でなければなりません。
プロトコルが見つかれば、@code{<sys-protoent>}
のインスタンスを返します。見つからなければ、@code{#f} を返します。
@c COMMON
@example
(let ((proto (sys-getprotobyname "icmp")))
  (list (slot-ref proto 'name)
        (slot-ref proto 'aliases)
        (slot-ref proto 'proto)))
  @result{} ("icmp" ("ICMP") 1)
@end example
@end defun

@defun sys-getprotobynumber number
@c EN
Looks up the network protocol database with a protocol number @var{number},
which must be an exact integer.
If a protocol is found, an instance of @code{<sys-protoent>} is returned.
Otherwise, @code{#f} is returned.
@c JP
プロトコル番号 @var{number} でネットワークプロトコルデータベースを検索
する。プロトコル番号 @var{number} は正確な整数でなければなりません。
プロトコルが見つかれば、@code{<sys-protoent>}
のインスタンスを返します。見つからなければ、@code{#f} を返します。
@c COMMON
@example
(let ((proto (sys-getprotobynumber 17)))
  (list (slot-ref proto 'name)
        (slot-ref proto 'aliases)
        (slot-ref proto 'proto)))
  @result{} ("udp" ("UDP") 17)
@end example
@end defun

@deftp {Builtin Class} <sys-addrinfo>
@clindex sys-addrinfo
@c EN
The new interface to keep address information.
Corresponds to @code{struct addrinfo} in C.
This is only available if gauche is configured with --enable-ipv6 option.
The following slots are provided.
@c JP
アドレス情報を保持する新しいインタフェースです。C の @code{struct addrinfo}
に対応しています。これは gauche が --enable-ipv6 オプションで設定され、
ビルドされた場合にのみ利用可能です。以下のスロットが提供されます。
@c COMMON

@defivar {<sys-addrinfo>} flags
@end defivar
@defivar {<sys-addrinfo>} family
@end defivar
@defivar {<sys-addrinfo>} socktype
@end defivar
@defivar {<sys-addrinfo>} protocol
@end defivar
@defivar {<sys-addrinfo>} addrlen
@end defivar
@defivar {<sys-addrinfo>} addr
@end defivar
@end deftp

@defun sys-getaddrinfo nodename servname hints
@c EN
Returns @code{<sys-addrinfo>} instance from the given @var{nodename},
@var{servname} and @var{hints}.
This is only available if gauche is compiled with --enable-ipv6 option.
@c JP
与えられた @var{nodename}、@var{servname} および @var{hints} から
@code{<sys-addrinfo>} のインスタンスを返します。
これは gauche が --enable-ipv6 オプションで設定され、
ビルドされた場合にのみ利用可能です。
@c COMMON
@end defun

@c ----------------------------------------------------------------------
@node Parameters, Parsing command-line options, Networking, Library modules - Gauche extensions
@section @code{gauche.parameter} - Parameters
@c NODE パラメータ, @code{gauche.parameter} - パラメータ

@deftp {Module} gauche.parameter
@mdindex gauche.parameter
@c EN
A @emph{parameter} is somethink like a stateful procedure that takes zero or
one argument.
If no argument is given, the parameter returns the current value it is keeping.
If single argument is given, it will be the current value of the parameter.
A parameter has several advantages over global variables to store
states.
@c JP
「パラメータ」は基本的にゼロもしくは一個の引数を取る状態を持つ手続きとみなせます。
引数が与えられなかった場合、それは内部に保持した値を返します。
一つの引数が与えられた場合、その値が新たなパラメータ内部の値となり、
変更前の値が返されます。
パラメータは状態を保持する手段として、
単なるグローバル変数に比べていくつかの利点を持っています。
@c COMMON

@c EN
Value of parameters are kept for each thread, so you can use
a parameter as a thread-local storage.  When a new thread is
created, it inherits a copy of parameters from its creator thread.
@c JP
パラメータの値はスレッド毎に保持されるので、
パラメータをスレッドローカルな格納領域として利用することができます。
新たに作られたスレッドは、その作成元のスレッドのパラメータのコピーを
受け取ります。
@c COMMON

@c EN
You can give a "filter procedure" that checks the new
value before setting it as the parameter value,
so that you can guarantee the value of the parameter is always sane.
@c JP
パラメータに値がセットされるときに、指定の「フィルタ手続き」を呼んで
値を検査することができます。これにより、パラメータの値が常に正当なもので
あることを保証できます。
@c COMMON

@c EN
With the macro @code{parameterize}, you can change the parameter's
value within certain dynamic scope.   It can effectively
replace dynamically scoped variables.
@c JP
マクロ@code{parameterize}により、特定のダイナミックスコープの中だけ
パラメータの値を変えることができます。これは、実質的にダイナミックスコープを
持つ変数を置き換えることができます。
@c COMMON

@c EN
You can also register callback procedures to be called whenever
the value of the parameter is changed.   It can effectively
replace so-called "traced variables"
@c JP
また、パラメータの値が変更されたときに呼ばれるコールバック手続きを
登録しておくこともできます。これによって実質的に、いわゆる
「traceされた変数」を置き換えることができます。
@c COMMON

@c EN
The basic parameter object feature is defined in SRFI-39.
It also can be found in other Scheme implementations,
including ChezScheme, Chicken and MzScheme.
Gauche's one is upper compatible to SRFI-39.
@c JP
パラメータオブジェクトの基本的な機能はSRFI-39で定義されています。
この機能はまた、ChezScheme、Chicken、MzSchemeなどいくつかのScheme処理系に
見られます。GaucheのパラメータはSRFI-39の上位互換になっています。
@c COMMON
@end deftp

@deftp {Class} <parameter>
@clindex parameter
@c EN
A parameter class.  A @code{object-apply} method is defined
so that a parameter can be used as if it were a procedure.
@c JP
パラメータのクラスです。@code{object-apply}メソッドが定義されているので、
パラメータオブジェクトは普通の手続きと同様に使うことが出来ます。
@c COMMON
@end deftp

@defun make-parameter value &optional filter
[SRFI-39]
@c EN
Creates a parameter whose initial value is @var{value}.
If an optional argument @var{filter} is given, it must be
a procedure that takes one argument and returns one value;
whenever the parameter's value is about to change, the procedure
is called with the given value, and the value the procedure
returns will be the parameter's value.  The filter procedure
can raise an error or reject to change the parameter's value.
@c JP
初期値が@var{value}であるパラメータを作成します。
もし省略可能な引数@var{filter}が与えられた場合、
それは一つの引数を取る手続きでなければなりません。
パラメータの値が変更されようとした時、@var{filter}は与えられた値を
引数として呼ばれ、@var{filter}が返した値がパラメータの新しい値と
なります。@var{filter}はエラーを報告したりパラメータの値を変えずに置くことも
可能です。
@c COMMON
@end defun

@defmac parameterize ((param value) @dots{}) body @dots{}
[SRFI-39]
@c EN
Evaluages @var{body} @dots{}, with
change parameter @var{param}'s value to the given @var{value} within
the dynamic scope of @var{body} @dots{}.
Returns the value(s) of the result of the last @var{body}.
@c JP
@var{body} @dots{}を評価します。
但し、@var{body} @dots{} の実行中のみ、パラメータ@var{param}の値を
@var{value}に変更します。最後@var{body}の返した値を返します。
@c COMMON
@end defmac

@c EN
Some examples:
@c JP
例：
@c COMMON
@example
(define a (make-parameter 1))
(a) @result{} 1
(a 2) @result{} 1
(a) @result{} 2
(parameterize ((a 3))
  (a)) @result{} 3
(a) @result{} 2
@end example

@deffn {Method} parameter-observer-add! (p <parameter>) proc &optional when where
@c EN
Adds @var{proc} to "observer" procedures of a parameter @var{p}.
Observer procedures are called either (1) just before
a new value is set to the parameter, or (2) just after the new value
is set to the parameter.   In case of (1), a filter procedure is
already applied before a callback is called.
In either case, observer procedures are called with two arguments,
the old value and the new value.  The return value(s) of observer
procedures are discarded.
@c JP
@var{proc}をパラメータ@var{p}の``オブザーバ''手続きに追加します。
オブザーバ手続きは、(1)パラメータに新しい値がセットされる直前、
あるいは(2)パラメータに新しい値がセットされた直後、に呼ばれます。
(1)の場合、コールバックが呼ばれる前にフィルタ手続きがすでに適用
されています。どちらの場合も、オブザーバ手続きは、古い値と新しい
値の2引数を伴って呼ばれます。オブザーバ手続きの戻り値は無視されます。
@c COMMON

@c EN
The optional @var{when} argument must be either a symbol @code{before}
or @code{after}, to specify whether @var{proc} should be called
before or after the value is changed.   If omitted, @code{after} is
assumed.
@c JP
オプショナル引数@var{when}は、シンボル@code{before}か@code{after}の
いずれかでなければならず、値が変更された前と後のどちらで@var{proc}が
呼ばれるかを指定します。省略されると、@code{after}を指定したものと
されます。
@c COMMON

@c EN
The optional @var{where} argument must be either a symbol
@code{append} or @code{prepend}, to specify whether @var{proc} should
be prepended or appended to the existing observer procedure list.
If omitted, @code{append} is assumed.
@c JP
オプショナル引数@var{where}は、シンボル@code{append}か@code{prepend}の
いずれかでなければならず、@var{proc}が既存のオブザーバ手続きのリストの
前に追加されるか後に追加されるかを指定します。省略されると、@code{append}
を指定したものとされます。
@c COMMON

@c EN
@emph{Note}: Although the parameter value itself is thread-local,
the observer list is shared by all threads.
@c JP
@emph{注意}: パラメータの値自身がスレッドローカルであっても、
オブザーバのリストは全てのスレッドで共有されます。
@c COMMON
@end deffn

@deffn {Method} parameter-observer-delete! (p <parameter>) proc &optional when
@c EN
Deletes @var{proc} from observer procedure list of a parameter @var{p}.
If @var{proc} is not in the list, nothing happens.
You can give either a symbol @code{before} or @code{after} to
@var{when} argument to specify from which list @var{proc} should be
deleted.  If @var{when} argument is omitted, @var{proc} is deleted
from both lists.
@c JP
パラメータ@var{p}のオブザーバ手続きのリストから@var{proc}を削除します。
@var{proc}がリストになければ、何も起こりません。
@var{when}引数にシンボル@code{before}か@code{after}を与えて、
@var{proc}をどちらのリストから削除するかを指定することができます。
@var{when}引数が省略されると、@var{proc}は両方のリストから削除されます。
@c COMMON
@end deffn

@deffn {Method} parameter-pre-observers (p <parameter>)
@deffnx {Method} parameter-post-observers (p <parameter>)
@c EN
Returns a hook object (@xref{Hooks}) that keeps
"before" or "after" observers, respectively.

@emph{Note}: Although the parameter value itself is thread-local,
these hook objects are shared by all threads.
@c JP
``before''か``after''オブザーバをそれぞれキープするフックオブジェクト
(@ref{Hooks}参照)を返します。

@emph{注意}: パラメータの値自身がスレッドローカルであっても、
オブザーバのリストは全てのスレッドで共有されます。
@c COMMON
@end deffn

@c ----------------------------------------------------------------------
@node Parsing command-line options, High Level Process Interface, Parameters, Library modules - Gauche extensions
@section @code{gauche.parseopt} - Parsing command-line options
@c NODE コマンドライン引数の解析, @code{gauche.parseopt} - コマンドライン引数の解析

@deftp {Module} gauche.parseopt
@mdindex gauche.parseopt
@c EN
This module defines a convenient way to parse command-line options.
The interface is hinted by Perl, and conveniently handles long-format
options with mutiple option arguments.

Actually, you have a few choices to parse command-line
options in Gauche.
SRFI-37 (@xref{A program argument processor}) provides
functional interface to parse POSIX/GNU compatible argument syntax.
SLIB has @code{getopt}-compatible utility.
Required features may differ from application to application,
so choose whichever fits your requirement.
@c JP
このモジュールでは、コマンドラインオプションをパースするための便利な方法を定義
しています。インタフェースは Perl にヒントを受けたもので、複数のオプション引数を
伴う長い形式のオプションを便利に扱うことができます。

実際、Gauche でコマンドラインオプションをパースするにはいくつかの選択肢が
あります。SRFI-37 (@ref{A program argument processor}参照)では、
POSIX/GNU 互換の引数構文をパースするための関数的なインタフェースを提供しています。
SLIB は、@code{getopt} 互換のユーティリティを持っています。
要求される機能はアプリケーションごとに異なるので、
あなたの要求にフィットするものを選んで下さい。
@c COMMON
@end deftp

@defmac parse-options args (option-clause @dots{})
@c EN
@var{args} is an expression that contains a list of command-line arguments.
This macro scans the command-line options (an argument that begins with
`@code{-}') and processes it as specified in @var{option-clause}s, then
returns the remaining arguments.
@c JP
@var{args} は、コマンドライン引数のリストを含む式です。
このマクロは、コマンドラインオプション(`@code{-}' で始まる引数)をスキャンし、
@var{option-clause} の指定に従って処理し、残りの引数を返します。
@c COMMON

@c EN
Unlike typical @code{getopt} or @code{getopt_long} implementation in C,
@code{parse-options} does not permute the given command-line arguments.
It stops parsing when it encounters a non-option argument (argument without
starting with a minus sign).
@c JP
C における典型的な @code{getopt} や @code{getopt_long} の実装とは異なり、
@code{parse-options} は与えられたコマンドライン引数の順番を変えません。
オプションでない引数(ハイフンで始まらない引数)に遭遇した時点でパースを
中止します。
@c COMMON

@c EN
If the parser encounters an argument with only two minus signs `@code{--}',
it stops argument parsing and returns a list of arguments after `@code{--}'.

Each @var{option-clause} is consisted by a pair of @var{option-spec}
and its action.
@c JP
パーサは、ハイフン2つのみの引数 `@code{--}' に遭遇すると、引数パーシングを
中止して`@code{--}' の後の引数のリストを返します。

それぞれの @var{option-clause} は、@var{option-spec} とそのアクションのペアで
構成されます。
@c COMMON

@c EN
@var{option-spec} is a string that specifies the name of the option and
how the option takes the arguments.  An alphanumeric characters, underscore,
plus and minus sign is allowed for option's names, except that
minus sign can't be the first character, i.e. the valid option name
matches a regexp @code{#/[\w+][-\w+]*/}.
@c JP
@var{option-spec} は、オプションの名前とそのオプションがどのように引数を取るか
を指定する文字列です。オプションの名前には、アルファベット文字、数字、
アンダースコア、プラス記号、ハイフンが許されますが、ハイフンは最初の文字としては
使えません。すなわち、有効なオプションの名前は、@code{#/[\w+][-\w+]*/} という
正規表現にマッチするものです。
@c COMMON

@c EN
If the option takes argument(s), it can be specified by attaching 
equal character and a character (or characters) that represents
the type of the argument(s) after the name.  The option
can take more than one arguments.
The following characters are recognized as a type specifier of
the option's argument.
@c JP
オプションが引数を取る場合、名前の後ろに等号文字と引数の型を表現する文字を
付けることで指定できます。オプションは一つ以上の引数を取ることができます。
以下の文字がオプションの引数の型を表現するものとして認識されます。
@c COMMON

@table @code
@item s
@c EN
String.
@c JP
文字列。
@c COMMON
@item n
@c EN
Number.
@c JP
数値。
@c COMMON
@item f
@c EN
Real number (flonum).
@c JP
実数 (flonum)。
@c COMMON
@item i
@c EN
Exact integer.
@c JP
正確な整数。
@c COMMON
@item e
@c EN
S-expression.
@c JP
S式。
@c COMMON
@item y
@c EN
Symbol (argument is converted by @code{string->symbol}).
@c JP
シンボル (引数は@code{string->symbol}により変換される)。
@c COMMON
@end table

@c EN
Let's see some examples of @var{option-spec}:
@c JP
@var{option-spec}の例を見てみましょう：
@c COMMON

@table @code
@item "@var{name}"
@c EN
Specifies option @var{name}, that doesn't take any argument.
@c JP
引数を取らないオプションの @var{name} を指定します。
@c COMMON

@item "@var{name}=s"
@c EN
Option @var{name} takes one argument, and it is passed as a string.
@c JP
オプション @var{name} は引数を一つ取り、それは文字列として渡されます。
@c COMMON

@item "@var{name}=i"
@c EN
Option @var{name} takes one argument, and it is passed as an exact integer.
@c JP
オプション @var{name} は引数を一つ取り、それは正確整数として渡されます。
@c COMMON

@item "@var{name}=ss"
@c EN
Option @var{name} takes two arguments, both string.
@c JP
オプション @var{name} は引数を二つ取り、両方とも文字列です。
@c COMMON

@item "@var{name}=iii"
@c EN
Option @var{name} takes three integer arguments.
@c JP
オプション @var{name} は3つの整数の引数を取ります。
@c COMMON

@item "@var{name}=sf"
@c EN
Option @var{name} takes two arguments, the first is a string and the
second is a number.
@c JP
オプション @var{name} は2つの引数を取ります。一つ目は文字列で、
二つ目は数値です。
@c COMMON
@end table

@c EN
If the option has alternative names, they can be concatenated by "|".
For example, an option spec @code{"h|help"} will match both
"h" and "help".
@c JP
オプションにいくつかの別名がある場合は、"|" でつなげて書いておくことができます。
例えば@code{"h|help"}という@var{option-spec}は
"h"にも"help"にもマッチします。
@c COMMON

@c EN
In the command line, the option may appear with preceding
single or double minus signs.  The option's argument may be comibined
by the option itself with an equal sign.  For example, all the following
command line arguments match an option spec @code{"prefix=s"}.
@c JP
コマンドラインでは、オプションは一つか二つのハイフンに続いて与えられます。
オプションの引数は、オプションそのものと等号記号でつながれていても構いません。
例えば、以下の全てのコマンドライン引数は、オプションの仕様、@code{"prefix=s"} に
マッチします。
@c COMMON
@example
-prefix /home/shiro
-prefix=/home/shiro
--prefix /home/shiro
--prefix=/home/shiro
@end example

@c EN
If a given command-line option matches one of @var{option-spec}, then
the associated action is evaluated.  An action can be one of the
following forms.
@c JP
与えられたコマンドラインオプションが @var{option-spec} の一つにマッチすると、
関連付けられたアクションが評価されます。アクションは以下のフォームの一つです。
@c COMMON

@table @code
@item @var{bind-spec} @var{body} @dots{}
@c EN
@var{bind-spec} is a proper or dotted list of variables like lambda-list.
The option's arguments are bound to @var{bind-spec}, then
then @var{body} @dots{} is evaluated. 
@c JP
@var{bind-spec} は、ラムダリストのような変数の正しいリストかドット対リストです。
オプションの引数は @var{bind-spec} に束縛され、@var{body} @dots{} が評価されます。
@c COMMON

@item => @var{proc}
@c EN
If a command-line option matches @var{option-spec}, calls a procedure
@var{proc} with a list of the option's arguments.
@c JP
コマンドラインオプションが @var{option-spec} にマッチすると、
@var{proc} がオプションの引数のリストとともに呼び出されます。
@c COMMON
@end table

Examples:
@example
(parse-options '("-file" "foo")
  (("file=s" (file)
     (format #t "file is ~s\n" file))))
 @result{} ;@r{``@code{file is "foo"}'' is printed}

(parse-options '("-scale" "1.5" "2.2")
  (("scale=ff" (xscale yscale)
     (format #t "scale is ~sx~s\n" xscale yscale))))
 @result{} ;@r{``@code{scale is 1.5x2.2}'' is printed}

(parse-options '("-scale" "1.5" "2.2")
  (("scale=ff" scales
     (format #t "scale is ~s\n" scales))))
 @result{} ;@r{``@code{scale is (1.5 2.2)}'' is printed}

(define (scales x y)
  (format #t "scale is ~sx~s\n" x y))

(parse-options '("-scale" "1.5" "2.2")
  (("scale=ff" => scales)))
 @result{} ;@r{``@code{scale is 1.5x2.2}'' is printed}
@end example

@c EN
If a symbol @code{else} is at the position of @var{option-spec},
the clause is selected when no other option clause matches a given
command-line option.  Three ``arguments'' are associated to
the clause; the unmatched option, the rest of arguments, and
a procedure that represents the option parser.
@c JP
シンボル @code{else} が @var{option-spec} の位置にある場合、その節は、
与えられたコマンドラインオプションにマッチする他のオプション節が
ない場合に選択されます。その節には3つの``引数''が関連付けられます。
それらは、マッチしなかったオプション、引数の残り、オプションパーサを
表す手続きです。
@c COMMON

@example
(parse-options args
  (("file=s" => process-file)
   (else (option . _)  (error "unrecognized option:" option))))
@end example

@c EN
Unlike other clause, the else clause returns to the caller of
@code{parse-options}, without looping further.  In order to
continue looping, you have to call the third argument of the else
clause with the remaining arguments.  This can be used
to implement your own sub-parser.  The following example
just skips unrecognized option, with printing a warning,
and continues parsing:
@c JP
他の節とは異なり、else 節はそれ以上繰り返しをせずに
@code{parse-options} の呼び出し元へ戻ります。
繰り返しを続けるためには、else 節の三つ目の引数を残りの引数を
伴って呼び出さなければなりません。これは、あなた独自のサブパーサを
実装するのに使うことができるでしょう。以下の例では、認識されない
オプションを単にスキップし、警告を表示し、パーシングを続けます。
@c COMMON

@example
(parse-options args
  (("file=s" => process-file)
   (else (option args continue)
     (format #t "warning: ignoring unrecognized option: ~a" option)
     (continue args))))
@end example

@end defmac

@defmac let-args args (bind-spec @dots{} [. rest]) body @dots{}
@c EN
This macro wraps @code{parse-options} to make it look more
like ordinary Scheme construct.
For example, a simple script can be written as follows:
@c JP
このマクロは@code{parse-options}のラッパーで、
より通常のScheme構文に近い形式を提供します。
例えば、簡単なスクリプトが次のように書けるでしょう。
@c COMMON

@example
(define (main args)
  (let-args (cdr args)
      ((quiet   "q|quiet" #t)
       (verbose "v|verbose" #f)
       (outfile "o|outfile=s")
       (help    "h|help" => (cut show-help (car args)))
      )
    ....))

(define (show-help progname)
  ...)
@end example

@c EN
@var{Bind-spec} must be one of the following forms.
@c JP
@var{Bind-spec}は次のいずれかの形式でなければなりません。
@c COMMON

@example
1. (@var{var} @var{option-spec})
2. (@var{var} @var{option-spec} @var{default})
3. (@var{var} @var{option-spec} => @var{callback})
4. (@var{var} @var{option-spec} @var{default} => @var{callback})

5. (else @var{formals} @var{form} ...)
@end example

@c EN
A list of command-line arguments passed to @var{args} are parsed
according to @var{option-spec}s.  If the corresponding option
is given, a variable @var{var} is bound to a value as follows:
@example
(a) If the @var{bind-spec} is 1. or 2., then
  (a1) If @var{option-spec} doesn't require an argument, then @code{#t}:
  (a2) If @var{option-spec} requires one argument, then the value of
       the argument:
  (a3) If @var{option-spec} requires more than one argument,
       the list of the values of the arguments.
(b) If the @var{bind-spec} is 3. or 4., then @var{callback} is called with
  the value(s) of arguments, and its return value.
@end example
@c JP
コマンドライン引数のリストが@var{args}に渡されると、それが
@var{option-spec}に基づいてパーズされます。該当するオプションが見付かれば、
変数@var{var}が次に述べる値に束縛されます：
@example
(a) @var{bind-spec}の形式が上の1. または2. の場合：
  (a1) @var{option-spec}が引数を要求しない場合は、@code{#t}。
  (a2) @var{option-spec}がひとつの引数を要求する場合は、その引数の値。
  (a3) @var{option-spec}がそれ以上の引数を要求する場合は、引数の値のリスト。
(b) @var{bind-spec}の形式が上の3. または4. の場合、@var{callback}を
  引数の値を伴って呼び出し、その戻り値。
@end example
@c COMMON

@c EN
As a special case, @var{var} can be @code{#f}, in which case
the value is ignored.  It is only useful for side effects in
@var{callback}.
@c JP
特別な場合として、@var{var}を@code{#f}とすることもできます。
その場合、値は無視されます。
@var{callback}での副作用だけに関心がある場合に使えるでしょう。
@c COMMON

@c EN
If the corresponding option is not given in @var{args},
@var{var} is bound to @var{default} if it is given, or
@code{#f} otherwise.
@c JP
対応するオプションが@var{args}に与えられなかった場合、
@var{var}は@var{default}が与えられていればその値に、
そうでなければ@code{#f}に束縛されます。
@c COMMON

@c EN
The last @var{bind-spec} may be the form 5. in which case
it is treated in the same way as @code{else} clause
of @code{parse-options}.
@c JP
最後の@var{bind-spec}は5.の形式であっても良く、
その場合は@code{parse-options}の@code{else}節と同様に処理されます。
@c COMMON

@c EN
The @var{bind-spec} list can be an improper list, whose last @code{cdr} is
a symbol.  In which case, a list of the rest of the command-line arguments
is bound to the variable named by the symbol.
@c JP
束縛リストは、最後の@code{car}にシンボルを持つ不完全なリストであっても良く、
その場合はコマンドライン引数の残りのリストがその変数にと束縛されます。
@c COMMON

@c EN
Note that the @var{default}, @var{callback}, and forms in @code{else}
clause is evaluated outside of the scope of binding of @var{var}s
(as the name @code{let-args} implies).
@c JP
@var{default}、@var{callback}、@code{else}節のフォーム等は
@var{var}の束縛の外側のスコープで評価されることに注意して下さい。
@c COMMON

@c EN
After all the bindings is done, @var{body} @dots{} are evaluated.
@var{Body} may began with internal define forms.
@c JP
全ての束縛が終了した後、@var{body} @dots{} が評価されます。
@var{body}は内部defineで始まっていても構いません。
@c COMMON
@end defmac

@defmac make-option-parser (option-clause @dots{})
@c EN
This is a lower-level interface.  @var{option-clause}s are the
same as @code{parse-options}.  This macro returns a procedure
that can be used later to parse the command line options.

The returned procedure takes one required argument and one
optional argument.  The required argument is a list of strings,
for given command-line arguments.  The optional argument may
be a procedure that takes more than three arguments, and if given,
the procedure is used as if it is the body of @code{else} option clause.
@c JP
これは低レベルのインタフェースです。@var{option-clause} は、
@code{parse-options} と同じです。このマクロは、コマンドラインオプションを
後でパースするために使うことができる手続きを返します。

返される手続きは、一つの必須の引数と一つのオプション引数を取ります。
必須の引数は、与えられたコマンドライン引数としての文字列のリストです。
オプションの引数は、三つ以上の引数を取る手続きで、それが与えられると
手続きはそれが @code{else} オプション節のボディであるかのように使われます。
@c COMMON
@end defmac

@c ----------------------------------------------------------------------
@node High Level Process Interface, Regular expression utilities, Parsing command-line options, Library modules - Gauche extensions
@section @code{gauche.process} - High Level Process Interface
@c NODE 高レベルプロセスインタフェース, @code{gauche.process} - 高レベルプロセスインタフェース

@deftp {Module} gauche.process
@mdindex gauche.process
@c EN
This module provides a higher-level API of Unix process control,
implemented on top of low-level system calls such as @code{sys-fork}
and @code{sys-exec}.  The interface is mostly compatible with
STk's process library.  This module also provides ``process ports'', 
a convenient way to send/receive information to/from subprocesses.
@c JP
このモジュールは、@code{sys-fork} や @code{sys-exec} などの低レベルな
システムコールの上に実装された、Unix プロセス制御の高レベル API を提供します。
インターフェースは、STk のプロセスライブラリとほとんどの点で互換性があります。
また、このモジュールは、サブプロセスに情報を送ったり、サブプロセスから
情報を受け取ったりするのに便利な「プロセスポート」を提供します。
@c COMMON
@end deftp

@menu
* Process object::              
* Process ports::               
@end menu

@node Process object, Process ports, High Level Process Interface, High Level Process Interface
@subsection Process object

@deftp {Class} <process>
@clindex process
@c EN
An object to keep the status of a child process.  You can create
the process object by @code{run-process} procedure described below.
The process ports explained in the next section also use process objects.
@c JP
子プロセスの状態を保持するためのオブジェクト。以下で説明される
@code{run-process} 手続きにより、プロセスを作ることができます。
次章で説明するプロセスポートもプロセスオブジェクトを用いています。
@c COMMON

@c EN
Note that the @code{<process>} class keeps track of
the child processes spawned by high-level APIs such
as @code{run-process} or @code{open-input-process}.
The exit status of such children must be collected by
@code{process-wait} or @code{process-wait-any} calls,
which also do some bookkeeping.   Using
the low-level process calls such as @code{sys-wait} or
@code{sys-waitpid} directly will cause inconsistent state.
@c JP
@code{<process>}クラスは、@code{run-process}や@code{open-input-process}
といった高レベルAPIで作られた子プロセスの状態を管理しています。
それらの子プロセスの終了ステータスをとるには、
@code{process-wait}や@code{process-wait-any}といった
高レベルAPIを利用してください。これらの手続きはシステムコール以外の情報管理も
行います。@code{sys-wait}や@code{sys-waitpid}といった低レベルAPIで
直接子プロセスの終了ステータスを取ると、@code{<process>}クラスの
内部状態に矛盾が生じます。
@c COMMON

@end deftp

@defun run-process command arg @dots{}
@c EN
Run @var{command} with @var{arg} in a subprocess, and returns a
@code{<process>} object.   @var{command} is searched from the
command search path.  

Command line arguments @var{arg}s can include the following keyword
arguments which specify special handling of the child process, as
listed below.

Other than such keyword arguments, @var{command} and @var{arg}s
are converted to strings by @code{x->string}.
@c JP
サブプロセスで、@var{arg} を引数として @var{command} を実行し、
@code{<process>} オブジェクトを返します。@var{command} は、
コマンドサーチパスから探されます。

コマンドライン引数 @var{arg} は、下に示す、
子プロセスを特別に扱うためのキーワード引数を含むことができます。

それらのキーワード引数を除いては、@var{command}と@var{arg}は
@code{x->string}を用いて文字列に変換されます。
@c COMMON
@table @code
@item :input @var{file}
@itemx :output @var{file}
@itemx :error @var{file}
@c EN
These arguments controls the subprocess' standard i/o.
@var{file} may be either a string or a keyword @code{:pipe}.
If it is a string, the process' standard input, output, or error goes
to the named file.   If it is @code{:pipe}, the process'
corresponding standard i/o is connected to a pipe, 
and the other side of the pipe is available for the calling process.
@c JP
これらの引数は、サブプロセスの標準入出力を制御します。
@var{file} は文字列かキーワード @code{:pipe} です。
文字列の場合は、プロセスの標準入力、標準出力、標準エラーはそのファイルに
なります。@code{:pipe} の場合は、プロセスの対応する標準入出力はパイプに
結び付けられ、そのパイプのもう一方はプロセスの呼び出し側で利用できます。
@c COMMON

@item :wait @var{flag}
@c EN
If @var{flag} is true, @code{run-process} waits until the
subprocess terminates.  Othewise the subprocess runs asynchronously
and @code{run-process} returns immediately, which is the default behavior.
Note that if the subprocess is running asynchronously, it is the
caller's responsibility to call @code{process-wait} at certain
timing to collect its exit status.
@c JP
@var{flag} が真の場合、@code{run-process} はサブプロセスが終了するまで待ちます。
そうでなければ、サブプロセスは非同期に実行され、@code{run-process} は
すぐに返ります。これがデフォルトの振る舞いになります。
サブプロセスが非同期に実行している場合、その終了ステータスを回収するために
適切なタイミングで @code{process-wait} を呼ぶことは、呼び出し側の責任であることに
注意してください。
@c COMMON

@item :fork @var{flag}
@c EN
If @var{flag} is true, @code{run-process} forks to run
the subprocess, which is the default behavior.  If @var{flag} is
false, @code{run-process} directly calls @code{sys-exec}, so
it never returns.
@c JP
@var{flag} が真の場合、@code{run-process} はサブプロセスを実行するために
フォークします。これはデフォルトの振る舞いです。@var{flag} が偽の場合、
@code{run-process} は直接 @code{sys-exec} を呼ぶので、それは返りません。
@c COMMON
@end table
@end defun

@defun process? obj
@equiv{} @code{(is-a? @var{obj} <process>)}
@end defun

@deffn {Method} process-pid (process <process>)
@c EN
Returns the process ID of the subprocess @var{process}.
@c JP
サブプロセス @var{process} のプロセスIDを返します。
@c COMMON
@end deffn

@deffn {Method} process-command (process <process>)
@c EN
Returns the command invoked in the subprocess @var{process}.
@c JP
サブプロセス @var{process} 内で起動されたコマンドを返します。
@c COMMON
@end deffn

@deffn {Method} process-input (process <process>)
@deffnx {Method} process-output (process <process>)
@deffnx {Method} process-error (process <process>)
@c EN
If the process' standard input, output or error is connected to
a pipe, returns another end of the pipe, i.e. @code{process-input}
returns an output port that can feed data to @var{process}' stdin,
@code{process-output} returns an input port that can read data from
@var{process}' stdout, and @code{process-error} returns an input port that
can read data from @code{process}' stderr.
If the corresponding i/o is not connected to the pipe,
the function returns @code{#f}.
@c JP
プロセスの標準入力、標準出力、標準エラーがパイプに接続されている場合は、
パイプのもう一方の終端を返します。例えば、@code{process-input} は、
@var{process} の標準入力へデータを送ることができる出力ポートを返します。
@code{process-output} は @var{process} の標準出力からデータを読み込むことの
できる入力ポートを返します。そして、@code{process-error} は、@code{process}
の標準エラーからデータを読み込むことのできる入力ポートを返します。
対応する入出力がパイプに接続されていない場合、手続きは @code{#f} を返します。
@c COMMON

@example
(let* ((process (run-process "date" :output :pipe))
       (line (read-line (process-output process))))
  (process-wait process)
  line)
 @result{} "Fri Jun 22 22:22:22 HST 2001"
@end example
@end deffn

@defun process-alive? process
@c EN
Returns true if @var{process} is alive.  Note that Gauche can't
know the subprocess' status until it is explicitly checked by
@code{process-wait}.
@c JP
@var{process} が生きている場合は真を返します。@code{process-wait} によって
明示的にチェックされない限り、Gauche はサブプロセスのステータスを知ることが
できないことに注意してください。
@c COMMON
@end defun

@defun process-list
@c EN
Returns a list of active processes.  The process remains active
until its exit status is explicitly collected by @code{process-wait}.
Once the process's exit status is collected and its state changed
to inactive, it is removed from the list @code{process-list} returns.
@c JP
アクティブなプロセスのリストを返します。プロセスは、その終了ステータスが
@code{process-wait} によって明示的に回収されない場合は、アクティブなまま
残ります。
ひとたび終了ステータスが回収され、プロセスの状態がインアクティブに
変更されると、そのプロセスは@code{process-list}が返すリストからは除かれます。
@c COMMON
@end defun

@defun process-wait process &optional nohang
@c EN
Obtains the exit status of the subprocess @var{process}, and stores it
to @var{process}'s status slot.  The status can be obtained by
@code{process-exit-status}.

This suspends execution until @var{process} exits by default.
However, if a true value is given to an optional argument @var{nohang},
it returns immediately if @var{process} hasn't exit.

Returns @code{#t} if this call actually obtains the exit status,
or @code{#f} otherwise.
@c JP
サブプロセス @var{process} の終了ステータスを取得し、@var{process}
のstatusスロットに値を格納します。statusスロットの値は
@code{process-exit-status}で得ることができます。

デフォルトでは、この手続きは@var{process} が終了するまで実行を一時停止します。
しかし、@var{nohang}に真の値が与えられた場合は、@var{process}が終了して
いない場合にも直ちに返ります。

この呼び出しによって@var{process}の終了ステータスが実際に取得された場合は
@code{#t}を、そうでなければ@code{#f}を返します。
@c COMMON
@end defun

@defun process-wait-any &optional nohang
@c EN
Obtains the exit status of any of the subprocesses created by
@code{run-process}.
Returns a process object whose exit status is collected.

If a true value is given to the optional argument @var{nohang}, this procedure
returns @code{#f }immediately even if no child process has exit.
If @var{nohang} is omitted or
@code{#f}, this procedure waits for any of children exits.

If there's no child processes, this procedure immediately returns @code{#f}.
@c JP
@code{run-process}で作られたサブプロセスのどれかの終了ステータスを取得します。
終了ステータスが取得できたプロセスのプロセスオブジェクトを返します。

真の値が@var{nohang}に与えられた場合は、どの子プロセスも終了していない場合は
直ちに@code{#f}を返します。そうでなければ、この手続きはいずれかの子プロセスが
終了するまで待ちます。

子プロセスが存在しない場合は、この手続きは直ちに@code{#f}を返します。
@c COMMON
@end defun


@defun process-exit-status process
@c EN
Returns exit status of @var{process} retrieved by @code{process-wait}.
If this is called before @code{process-wait} is called on @var{process},
the result is undefined.
@c JP
@code{process-wait}によって取得された@var{process}の終了ステータスを
返します。@var{process}に対して@code{process-wait}を呼ぶ前にこの手続きを
呼んだ場合の結果は未定義です。
@c COMMON
@end defun

@defun process-send-signal process signal
@c EN
Sends a signal @var{signal} to the subprocess @var{process}.
@var{signal} must be an exact integer for signal number.
@xref{Signal}, for predefined variables of signals.
@c JP
サブプロセス @var{process} にシグナル @var{signal} を送ります。
@var{signal} は正確整数のシグナルナンバーでなければなりません。
シグナルの定義済み変数については、@ref{Signal}を参照して下さい。
@c COMMON
@end defun

@defun process-kill process
@defunx process-stop process
@defunx process-continue process
@c EN
Sends SIGKILL, SIGSTOP and SIGCONT to @var{process}, respectively.
@c JP
それぞれ、@var{process} に、SIGKILL、SIGSTOP、SIGCONT を送ります。
@c COMMON
@end defun

@node Process ports,  , Process object, High Level Process Interface
@subsection Process ports

@defun open-input-process-port command &keyword output error encoding conversion-buffer-size
@c EN
Runs @var{command} asynchronously in a subprocess.  Returns
two values, an input port which is connected to the stdout of the
running subprocess, and a process object.  
@c JP
@var{command} を子プロセスで非同期に実行します。
走らせた子プロセスの標準出力につながれた入力ポートと、
プロセスオブジェクトの二つの値を返します。
@c COMMON

@c EN
@var{Command} can be a string or a list.
If it is a string, it is passed to @code{/bin/sh}.
You can use shell metacharacters in this form, such as
environment variable interpolation, globbing, and redirections.
@c JP
@var{command}は文字列かリストです。
文字列の場合、それは@code{/bin/sh}に渡されます。
環境変数の置換やグロブパターン、リダイレクトなどのシェルの機能が
文字列中で使えます。
@c COMMON

@c EN
If @var{command} is a list, each element is converted to a
string by @code{x->string} and then passed directly to @code{sys-exec}
(the @code{car} of the list is used as both the command path
and the first element of argv, i.e. @code{argv[0]}).
Use this form if you want to avoid the shell from interfering.
@c JP
@var{command}がリストの場合は、各要素が@code{x->string}で文字列に
変換された後に、@code{sys-exec}を使って直接コマンドを起動します
(リストの@code{car}がコマンドのパス名と@code{argv[0]}の両方に使われます)。
シェルの介入を避けたい場合はこの形式を使うと良いでしょう。
@c COMMON

@c EN
The subprocess's stdout is redirected to @code{/dev/null} by default,
and its stderr shares the calling process's stderr.
You can change these by giving file pathnames to @var{output} and
@var{error} keyword arguments, respectively.
@c JP
デフォルトでは、子プロセスの標準出力は@code{/dev/null}にリダイレクトされ、
標準エラー出力は呼び出したプロセスと共有されます。
@var{output}と@var{error}キーワード引数にパス名を与えることで、
これらの出力をリダイレクトすることができます。
@c COMMON

@c EN
You can also give the @var{encoding} keyword argument
to specify character encoding of the process output.  If it differs
from the Gauche's internal encoding format,
@code{open-input-process-port} inserts a character encoding
conversion port.  
If @var{encoding} is given, the @var{conversion-buffer-size} keyword
argument can control the conversion buffer size.
See @ref{Character code conversion}, for
the details of character encoding conversions.
@c JP
また、プロセスの出力の文字エンコーディングを指定するために
@var{encoding}キーワード引数を与えることもできます。
それがGaucheの内部エンコーディングと異なっていた場合、
@code{open-input-process-port}は文字コード変換ポートを挿入します。
@var{encoding}が与えられた場合、@var{conversion-buffer-size}キーワード引数で
変換バッファの大きさを指定することも可能です。文字コード変換の詳細については
@ref{Character code conversion}を参照して下さい。
@c COMMON
@example
(receive (port process) (open-input-process-port "ls -l Makefile")
  (begin0 (read-line port)
          (process-wait process)))
 @result{} "-rw-r--r--   1 shiro    users        1013 Jun 22 21:09 Makefile"

(receive (port process) (open-input-process-port '(ls -l "Makefile"))
  (begin0 (read-line port)
          (process-wait process)))
 @result{} "-rw-r--r--   1 shiro    users        1013 Jun 22 21:09 Makefile"

(open-input-process-port "command 2>&1")
 @result{} ;@r{the port reads both stdout and stderr}

(open-input-process-port "command 2>&1 1>/dev/null")
 @result{} ;@r{the port reads stderr}
@end example
@c EN
The exit status of subprocess is not automatically collected.
It is the caller's responsibility to issue @code{process-wait},
or the subprocess remains in a zombie state.  If it bothers you,
you can use one of the following functions.
@c JP
サブプロセスの終了ステータスは自動的に回収されません。
@code{process-wait} を呼ぶことは呼び出し側の責任であり、これを怠ると
サブプロセスはゾンビプロセスになります。それが面倒であれば、以下の
手続きを使うことができます。
@c COMMON
@end defun

@defun call-with-input-process command proc &keyword output error encoding conversion-buffer-size
@c EN
Runs @var{command} in a subprocess and pipes its stdout
to an input port, then call @var{proc} with the port as an argument.
When @var{proc} returns, it collects its exit status,
then returns the result @var{proc} returned.
The cleanup is done even if @var{proc} raises an error.

The semantics of @var{command} and keyword arguments are the same
as @code{open-input-process-port} above.
@c JP
子プロセスで@var{command} を実行し、その標準出力と入力ポートを
パイプで繋ぎ、そのポートを引数として @var{proc} を呼び出します。
@var{proc} が返るとその終了ステータスを回収し、@var{proc} が返した
結果を返します。@var{proc} がエラーを通知しても、クリーンアップは
行われます。

@var{command}およびキーワード引数の意味は@code{open-input-process-port}と
同じです。
@c COMMON
@example
(call-with-input-process "ls -l *"
  (lambda (p) (read-line p)))
@end example
@end defun

@defun with-input-from-process command thunk &keyword output error encoding conversion-buffer-size
@c EN
Runs @var{command} in a subprocess, and calls @var{thunk}
with its current input port connected to the command's stdout.
The command is terminated and its exit status is collected,
after @var{thunk} returns or raises an error.

The semantics of @var{command} and keyword arguments are the same
as @code{open-input-process-port} above.
@c JP
子プロセスで @var{command} を実行し、コマンドの標準出力に
接続された現在の入力ポートとともに @var{thunk} を呼び出します。
@var{thunk}が終了するかエラーを投げた後に、コマンドの終了ステータスが
回収されます。

@var{command}およびキーワード引数の意味は@code{open-input-process-port}と
同じです。
@c COMMON
@example
(with-input-from-process "ls -l *" read-line)
@end example
@end defun

@defun open-output-process-port command &keyword input error encoding conversion-buffer-size
@c EN
Runs @code{command} in a subprocess asynchronously.  Returns two values,
an output port which is connected to the stdin of the subprocess.
and the process object.

The subprocess's stdin is redirected from @code{/dev/null}, 
and its stderr shares the calling process's stderr by default.
You can change these by giving file pathnames to @var{input} and
@var{error} keyword arguments, respectively.

The semantics of @var{command} is the same as
@code{open-input-process-port}.  The semantics of
@var{encoding} and @var{conversion-buffer-size} are also the same.

The exit status of the subprocess is not automatically collected.
The caller should call @code{process-wait} on the subprocess
at appropriate time.
@c JP
子プロセスで @code{command} を非同期に実行します。
子プロセスの標準入力に接続された出力ポートと、
プロセスオブジェクトの二つの値を返します。

デフォルトでは、子プロセスの標準入力は@code{/dev/null}にリダイレクトされ、
標準エラー出力は呼び出したプロセスと共有されます。
@var{input}と@var{error}キーワード引数にパス名を与えることで、
これらの出力をリダイレクトすることができます。

@var{command}引数、および@var{encoding}と@var{conversion-buffer-size}の
意味は、@code{open-input-process-port}と同じです。

サブプロセスの終了ステータスは自動的には回収されません。
適切なタイミングで、サブプロセスに対して @code{process-wait} を呼ぶ
必要があります。
@c COMMON
@end defun

@defun call-with-output-process command proc &keyword input error encoding conversion-buffer-size
@c EN
Runs @code{command} in a subprocess, and calls @var{proc} 
with an output port which is connected to the stdin of the command.
The exit status of the command is collected after either @var{proc}
returns or raises an error.

The semantics of keyword arguments are the same as
@code{open-input-process-port}.
@c JP
@code{command} を子プロセスで実行し、コマンドの標準入力に
接続された出力ポートとともに @var{proc} を呼び出します。
コマンドの終了ステータスは、@var{proc} が返るかエラーを通知した
後に回収されます。

キーワード引数の意味は@var{open-input-process-port}と同じです。
@c COMMON
@example
(call-with-output-process "/usr/sbin/sendmail"
  (lambda (out) (display mail-body out)))
@end example
@end defun

@defun with-output-to-process command thunk &keyword input error encoding conversion-buffer-size
@c EN
Same as @code{call-with-output-process}, except that the
output port which is connected to the stdin of the command
is set to the current output port while executing @var{thunk}.
@c JP
コマンドの標準入力に接続された出力ポートが、@var{thunk} の実行中は
現在の出力ポートにセットされることを除いて、@code{call-with-output-process}
と同じです。
@c COMMON
@end defun

@defun call-with-process-io command proc &keyword error encoding conversion-buffer-size
@c EN
Runs @var{command} in a subprocess, and calls @var{proc}
with two arguments; the first argument is an input port which
is connected to the command's stdout, and the second is an output
port connected to the command's stdin.  The error output from
the command is shared by the calling process's, unless
an alternative pathname is given to the @var{error} keyword argument.

The exit status of the command is collected when @var{proc}
returns or raises an error.
@c JP
@var{command} をサブプロセスで実行し、@var{proc} を2つの引数と
ともに呼び出します。最初の引数は入力ポートで、コマンドの標準出力に
接続されたものです。2番目の引数は出力ポートでコマンドの標準入力に
接続されたものです。コマンドからのエラー出力は、@var{error}キーワード
引数でパス名が指定されない限り、呼び出したプロセスのエラー出力が共有されます。

コマンドの終了ステータスは、@var{proc}が戻るかエラーを投げた場合に
回収されます。
@c COMMON
@end defun

@defun process-output->string command
@defunx process-output->string-list command
@c EN
Runs @var{command} and collects its output (to stdout) and returns them.
@code{process-output->string} concatenates all the output from @var{command}
to one string, replacing any sequence of whitespace characters to
single space.   The action is similar to ``command substitution''
in shell scripts.
@code{process-output->string-list} collects the output from
@var{command} line-by-line and returns the list of them.  Newline
characters are stripped.

Internally, @var{command} is run by @code{call-with-input-process}.
@c JP
@var{command} を実行し、その(標準出力への)出力を回収して返します。
@code{process-output->string} は @var{command} からの全ての出力を連結し
1つの文字列とします。その際、空白文字からなるシーケンスは1つの空白に
置換されます。このアクションは、シェルスクリプトにおける「コマンド置換」
に似たものです。
@code{process-output->string-list} は @var{command} からの出力を行ごとに
回収し、それらをリストにしたものを返します。改行文字は削除されます。

内部的には、@var{command} は @code{call-with-input-process} により
実行されます。
@c COMMON
@example
(process-output->string "uname -smp")
  @result{} "Linux i686 unknown"

(process-output->string "ls")
  @result{} "a.out foo.c foo.c~ foo.o"

(process-output->string-list "ls")
  @result{} ("a.out" "foo.c" "foo.c~" "foo.o")
@end example

@end defun

@c ----------------------------------------------------------------------
@node Regular expression utilities, Reloading modules, High Level Process Interface, Library modules - Gauche extensions
@section @code{gauche.regexp} - Regular expression utilities
@c NODE 正規表現ユーティリティ, @code{gauche.regexp} - 正規表現ユーティリティ

@deftp {Module} gauche.regexp
@mdindex gauche.regexp
@c EN
This module defines some macros and utilities useful in regexp match.
See @ref{Regular expression} for builtin regexp features.
As of release 0.4.11, this module is set to be autoloaded in @code{gosh},
so you don't usually need to say @code{(use gauche.regexp)}.

The interface of some of the macros is borrowed from scsh
(@code{if-match}, @code{let-match} and @code{match-cond}),
but I changed the name of
macros since scsh's @code{match-cond} can be confusing
(e.g. Bigloo has @code{match-lambda} and @code{match-case} in
pattern match library, that sounds too similar).
@c JP
このモジュールは正規表現のマッチに関連する便利なマクロとユーティリティ関数を
定義します。組み込みの正規表現機能については@ref{Regular expression}を
参照して下さい。また、リリース0.4.11以降、このモジュールは@code{gosh}を
使う場合はオートロードされるようになっているので、
@code{(use gauche.regexp)}とする必要はありません。

いくつかのマクロのインタフェースはscshの
@code{if-match}、@code{let-match}、@code{match-cond} 
を参考にしました。但し名前に関してはscshのものは正規表現以外の
マッチライブラリと混乱しやすいため (例：Biglooのパターンマッチライブラリ
には@code{match-case}があります)、正規表現であることを明示する
名前に変えてあります。
@c COMMON
@end deftp

@c EN
In the following macros, @var{match-expr} is an expression
which produces a match object or @code{#f}. Typically
it is a call of @code{rxmatch}, but it can be any expression.
@c JP
以下のマクロにおいて、@var{match-expr}はマッチオブジェクトか
@code{#f}を生成する式でなければなりません。通常それは
@code{rxmatch}を呼ぶ式になりますが、それだけに限られるわけではありません。
@c COMMON

@defmac rxmatch-let match-expr (var @dots{}) form @dots{}

@c EN
Evaluates @var{match-expr}, and if matched, binds @var{var @dots{}}
to the matched strings, then evaluates @var{form}s.
The first @var{var} receives the entire match, and subsequent
variables receive submatches.  If the number of submatches are
smaller than the number of variables to receive them, the rest
of variables will get @code{#f}.
@c JP
@var{match-expr}を評価し、それがマッチオブジェクトを返したら、
マッチした文字列を@var{var @dots{}}に束縛し、@var{form}を評価します。
最初の@var{var}はマッチした文字列全体に束縛され、
以降の変数はサブマッチ文字列に束縛されます。実際のサブマッチ文字列が
与えられた変数より少なかった場合は、余った変数は@code{#f}に束縛されます。
@c COMMON

@c EN
It is possible to put @code{#f} in variable position, which says
you don't care that match.
@c JP
特定のマッチ文字列を受け取る必要が無いときは、その場所の
変数の変わりに@code{#f}を置いておくこともできます。
@c COMMON

@example
(rxmatch-let (rxmatch #/(\d+):(\d+):(\d+)/
                      "Jan  1 23:59:58, 2001")
   (time hh mm ss)
  (list time hh mm ss))
 @result{} ("23:59:58" "23" "59" "58")

(rxmatch-let (rxmatch #/(\d+):(\d+):(\d+)/
                      "Jan  1 23:59:58, 2001")
   (#f hh mm)
  (list hh mm))
 @result{} ("23" "59")
@end example

@c EN
This macro corresponds to scsh's @code{let-match}.
@c JP
このマクロはscshの@code{let-match}に相当します。
@c COMMON
@end defmac

@defmac rxmatch-if match-expr (var @dots{}) then-form else-form
@c EN
Evaluates @var{match-expr}, and if matched, binds @var{var} @dots{}
to the matched strings and evaluate @var{then-form}.
Otherwise evaluates @var{else-form}.
The rule of binding @var{var}s is the same as @code{rxmatch-let}.
@c JP
@var{match-expr}を評価し、それがマッチオブジェクトを返したら
マッチした文字列を変数@var{var} @dots{}に束縛して@var{then-form}を
評価します。マッチオブジェクトが返されなければ束縛は行われず、
@var{else-form}が評価されます。変数@var{var}をマッチ文字列に
束縛するルールは@code{rxmatch-let}と同じです。
@c COMMON

@example
(rxmatch-if (rxmatch #/(\d+:\d+)/ "Jan 1 11:22:33")
    (time)
  (format #f "time is ~a" time)
  "unknown time")
 @result{} "time is 11:22"

(rxmatch-if (rxmatch #/(\d+:\d+)/ "Jan 1 11-22-33")
    (time)
  (format #f "time is ~a" time)
  "unknown time")
 @result{} "unknown time"
@end example

@c EN
This macro corresponds to scsh's @code{if-match}.
@c JP
このマクロはscshの@code{if-match}に相当します。
@c COMMON
@end defmac

@defmac rxmatch-cond clause @dots{}
@c EN
Evaluate condition in @var{clause}s one by one.
If a condition of a clause satisfies, rest portion of the clause
is evaluated and becomes the result of @code{rxmatch-cond}.
@var{Clause} may be one of the following pattern.
@c JP
@var{clause}の条件を順に評価してゆき、条件を満たすものが現れたら
その@var{clause}の残りのフォームを評価し、最後のフォームの値を
@code{rxmatch-cond}の値とします。@var{clause}は以下のいずれかの
形式でなければなりません。
@c COMMON

@table @code
@item (@var{match-expr} (@var{var} @dots{}) @var{form} @dots{})
@c EN
Evaluate @var{match-expr}, which may return a regexp match
object or @code{#f}.  If it returns a match object, the matches
are bound to @var{var}s, like @var{rxmatch-let}, and @var{form}s
are evaluated.
@c JP
@var{match-expr}を評価し、それがマッチオブジェクトを返した場合は
マッチ文字列を変数@var{var} @dots{}に束縛した上で
@var{form} @dots{}を評価します。
@c COMMON

@item (test @var{expr} @var{form} @dots{})
@c EN
Evaluates @var{expr}.  If it yields true, evaluates @var{form}s.
@c JP
@var{expr}を評価し、それが真の値を返した場合は@var{form} @dots{}を評価します。
@c COMMON

@item (test @var{expr} => @var{proc})
@c EN
Evaluates @var{expr} and if it is true,
calls @var{proc} with the result of @var{expr} as the only argument.
@c JP
@var{expr}を評価し、それが真の値を返した場合は
それを唯一の引数として手続き@var{proc}を呼びます。
@c COMMON

@item (else @var{form} @dots{})
@c EN
If this clause exists, it must be the last clause.
If other clauses fail, @var{form}s are evaluated.
@c JP
この@var{clause}は、もし与えられたとすれば最後の@var{clause}でなければ
なりません。全ての@var{clause}が失敗した場合に、@var{form} @dots{}が
評価されます。
@c COMMON
@end table

@c EN
If no @code{else} clause exists, and all the other clause fail,
an undefined value is returned.
@c JP
@code{else} @var{clause}が与えられず、かつ全ての@var{clause}が
失敗した場合の戻り値は未定義です。
@c COMMON

@example
@c EN
;; @r{parses several possible date format}
@c JP
;; @r{何通りかの日付のフォーマットをパーズする}
@c COMMON
(define (parse-date str)
  (rxmatch-cond
    ((rxmatch #/^(\d\d?)\/(\d\d?)\/(\d\d\d\d)$/ str)
        (#f mm dd yyyy)
      (map string->number (list yyyy mm dd)))
    ((rxmatch #/^(\d\d\d\d)\/(\d\d?)\/(\d\d?)$/ str)
        (#f yyyy mm dd)
      (map string->number (list yyyy mm dd)))
    ((rxmatch #/^\d+\/\d+\/\d+$/ str)
        (#f)
     (error "ambiguous: ~s" str))
    (else (error "bogus: ~s" str))))

(parse-date "2001/2/3") @result{} (2001 2 3)
(parse-date "12/25/1999") @result{} (1999 12 25)
@end example

@c EN
This macro corresponds to scsh's @code{match-cond}.
@c JP
このマクロはscshの@code{match-cond}に相当します。
@c COMMON
@end defmac

@defmac rxmatch-case string-expr clause @dots{}
@c EN
@var{String-expr} is evaluated, and @var{clause}s are interpreted
one by one.  A @var{clause} may be one of the following pattern.
@c JP
@var{string-expr}がまず評価され、続いて@var{clause}が順に検査されます。
@var{clause}は以下のいずれかの形式でなければなりません。
@c COMMON

@table @code
@item (@var{re} (@var{var} @dots{}) @var{form} @dots{})
@c EN
@var{Re} must be a literal regexp object (@xref{Regular expression}).
If the result of @var{string-expr} matches @var{re},
the match result is bound to @var{var}s
and @var{form}s are evaluated, and @code{rxmatch-case} returns
the result of the last @var{form}.
@c JP
@var{re}はリテラル正規表現オブジェクトでなければなりません
(@ref{Regular expression}参照)。@var{string-expr}の結果が文字列であり
@var{re}にマッチした場合は、マッチ文字列が変数@var{var} @dots{}に
束縛され、@var{form}が評価されます。最後の@var{form}の値が@code{rxmatch-case}
の値となります。
@c COMMON

@c EN
If @var{re} doesn't match the result of @var{string-expr},
@var{string-expr} yields non-string value, the interpretation proceeds
to the next clause.
@c JP
@var{string-expr}の結果の文字列が@var{re}にマッチしないか、
@var{string-expr}の結果が文字列以外であった場合は次の@var{clause}へと
処理が進みます。
@c COMMON

@item (test @var{proc} @var{form} @dots{})
@c EN
A procedure @var{proc} is applied on the result of @var{string-expr}.
If it yields true value, @var{form}s are evaluated, and
@code{rxmatch-case} returns the result of the last @var{form}.
@c JP
手続き@var{proc}が@var{string-expr}の結果を引数として呼ばれます。
それが真の値を返した場合は@var{form}が順に評価され、最後の@var{form}の
値が@code{rxmatch-case}の値として返されます。
@c COMMON

@c EN
If @var{proc} yieds @code{#f}, the interpretation proceeds
to the next clause.
@c JP
@var{proc}が@code{#f}を返した場合は次の@var{clause}へと
処理が進みます。
@c COMMON

@item (test @var{proc} => @var{proc2})
@c EN
A procedure @var{proc} is applied on the result of @var{string-expr}.
If it yields true value, @var{proc2} is applied on the result,
and its result is returned as the result of @code{rxmatch-case}.
@c JP
手続き@var{proc}が@var{string-expr}の結果を引数として呼ばれます。
それが真の値を返した場合は、その値を引数として@var{proc2}が呼ばれ、
その返り値が@code{rxmatch-case}の値として返されます。
@c COMMON

@c EN
If @var{proc} yieds @code{#f}, the interpretation proceeds
to the next clause.
@c JP
@var{proc}が@code{#f}を返した場合は次の@var{clause}へと
処理が進みます。
@c COMMON

@item (else @var{form} @dots{})
@c EN
This form must appear at the end of @var{clause}s, if any.
If other clauses fail, @var{form}s are evaluated,
and the result of the last @var{form} becomes the result of
@code{rxmatch-case}.
@c JP
このフォームは、与えられる場合は最後の@var{clause}でなければなりません。
他の全ての@var{clause}が失敗した場合に、@var{form}が順に評価され、最後の@var{form}の
値が@code{rxmatch-case}の値として返されます。
@c COMMON
@end table

@c EN
If no @code{else} clause exists, and all other clause fail,
an undefined value is returned.
@c JP
@code{else} @var{clause}が与えられず、かつ全ての@var{clause}が
失敗した場合の戻り値は未定義です。
@c COMMON

@c EN
The @code{parse-date} example above becomes simpler if you use
@code{rxmatch-case}
@c JP
上の@code{parse-date}の例は@code{rxmatch-case}を使うとより単純になります。
@c COMMON
@example
(define (parse-date2 str)
  (rxmatch-case str
    (test (lambda (s) (not (string? s))) #f)
    (#/^(\d\d?)\/(\d\d?)\/(\d\d\d\d)$/ (#f mm dd yyyy)
     (map string->number (list yyyy mm dd)))
    (#/^(\d\d\d\d)\/(\d\d?)\/(\d\d?)$/ (#f yyyy mm dd)
     (map string->number (list yyyy mm dd)))
    (#/^\d+\/\d+\/\d+$/                (#f)
     (error "ambiguous: ~s" str))
    (else (error "bogus: ~s" str))))
@end example
@end defmac


@defun regexp-replace regexp string substitution
@defunx regexp-replace-all regexp string substitution
@c EN
Replaces the part of @var{string} that matched to @var{regexp}
for @var{substitution}.  @code{regexp-replace} just replaces
the first match of @var{regexp}, while @code{regexp-replace-all}
repeats the replacing throughout entire @var{string}.
@c JP
@var{string}中で@code{regexp}にマッチした部分を@var{substitution}で
置き換えます。@code{regexp-replace}は最初にマッチした部分のみを置き換え、
@code{regexp-replace-all}は全てのマッチを置き換えます。
@c COMMON

@c EN
@var{substitution} may be a string or a procedure.  If it is a string,
it can contain a digit sequence preceded by a backslash
(e.g. @code{\2}) that refers the submatch.  @code{\0} refers to the
entire match.  Note that you need two backslashes to include
backslash character in the literal string; if you want to include a backslash
character itself in the @var{substitution}, you need four backslashes.
@c JP
@var{substitution}は文字列か手続きです。
文字列の場合、バックスラッシュに続く数値を使ってサブマッチ文字列を参照できます。
@code{\0}はマッチ文字列全体を参照します。文字列リテラルにバックスラッシュを
埋め込む場合は二つのバックスラッシュが必要であることに注意して下さい。
バックスラッシュそのものを@var{substitution}中で使いたい場合は
二つのバックスラッシュを重ねます; 文字列リテラルの場合は4つのバックスラッシュが
必要になります。
@c COMMON

@example
(regexp-replace #/def|DEF/ "abcdefghi" "...")
  @result{} "abc...ghi"
(regexp-replace #/def|DEF/ "abcdefghi" "|\\0|")
  @result{} "abc|def|ghi"
(regexp-replace #/def|DEF/ "abcdefghi" "|\\\\0|")
  @result{} "abc|\\0|ghi"
(regexp-replace #/c(.*)g/ "abcdefghi" "|\\1|")
  @result{} "ab|def|hi"
@end example

@c EN
If @var{substitution} is a procedure, for every match in @var{string}
it is called with one argument, regexp-match object.  The returned
value from the procedure is inserted to the output string using
@code{display}.
@c JP
@var{substitution}が手続きである場合、@var{string}中の各マッチについて、
マッチオブジェクトを引数としてその手続きが呼ばれます。その手続きが返す
値を@code{display}で表現したものが置換文字列として使われます。
@c COMMON

@example
(regexp-replace #/c(.*)g/ "abcdefghi" 
                (lambda (m)
                  (list->string
                   (reverse
                    (string->list (rxmatch-substring m 1))))))
 @result{} "abfedhi"
@end example

@c EN
Note: @code{regexp-replace-all} applies itself recursively to the remaining 
of the string after match.  So the beginning of string assertion
in @var{regexp} doesn't only mean the beginning of input string.
@c JP
註: @code{regexp-replace-all} は文字列でマッチした部分の後ろの部分に
ついて再帰的に自分自身を適用します。従って、@var{regexp}が
文字列先頭のアサーション (@code{^}) を含んでいても、それは@var{string}の
先頭だけにマッチするとは限りません。
@c COMMON
@end defun

@defun regexp-quote string
@c EN
Returns a string with the characters that are special to regexp escaped.
@c JP
@var{string}中で、正規表現において特別な意味を持つ文字を全てエスケープした
文字列を返します。
@c COMMON
@example
(regexp-quote "[2002/10/12] touched foo.h and *.c")
 @result{} "\\[2002/10/12\\] touched foo\\.h and \\*\\.c"
@end example
@end defun

@c ----------------------------------------------------------------------
@node Reloading modules, Simple dispatcher, Regular expression utilities, Library modules - Gauche extensions
@section @code{gauche.reload} - Reloading modules
@c NODE モジュールの再ロード, @code{gauche.reload} - モジュールの再ロード

@deftp {Module} gauche.reload
@mdindex gauche.reload
@c EN
In the development cycle, you often have to reload modules frequently.
This module supports it.

Note that some part of semantics of the program depends on
the order of loading modules, so reloading arbitrary modules
may change the program behavior unexpectedly.  This module
is for developers who knows what they are doing.
@c JP
開発のサイクルのなかで、モジュールを再ロードしなければならないことは
頻繁におこります。このモジュールはそれを支援するものです。

プログラムのいくつかの部分のセマンティクスはモジュールのロードの順に
依存します。それで、任意のモジュールを再ロードすることはプログラムの
ふるまいを予期せぬものに変えてしまう可能性があります。このモジュールは
自分がなにをしようとしているか判っている開発者向けのものです。
@c COMMON

@c EN
@strong{Redefinition rules}: Reloading a module resets all
the binding in the module by default.
Sometimes it is not desirable, however.  For example,
you might have  a large list of objects that takes time to rebuild.
You can specify rules for the reloading procedure to determine
which binding to keep.

The rule is described in the following syntax.
@c JP
@strong{再定義ルール}: モジュールを再ロードすると、デフォルトでは、その
モジュール内のすべての束縛はリセットされます。
しかしながら、場合によってこれは望ましいことではありません。たとえば、
再構築するのに時間のかかるオブジェクトの大きなリストをもつような場合です。
再ロード手続きにどの束縛を保存するかを決めるためのルールを指定することが
できます。

このルールは以下の構文で記述します。
@c COMMON
@example
  <module-rules> : (<module-rule> @dots{})
  <module-rule>  : (<module-pattern> <rule> @dots{})
  <module-pattern> : @r{a symbol module name, or a symbol containing glob pattern}
  <rule>         : @r{procedure} | @r{symbol} | @r{regexp}
                 | (and <rule> @dots{})
                 | (or  <rule> @dots{})
                 | (not <rule>)
@end example

@c EN
@code{<module-rules>} is the global rule to determine per-module
rules.  @code{<module-pattern>} is either a symbol module name
or a symbol that contains glob pattern (e.g. @code{mylib.*}).
If @code{<rule>} is a procedure, it is used as a predicate
and the bindings whose value satisfies the predicate are kept from
redefinition.   If @code{<rule>} is a symbol, the binding of
the variable whose name is the symbol is kept.  If @code{<rule>}
is a regexp, the bindings of the variable whose name matches the
regexp are kept.

Note that the mechanism to prevent redefinition is kind of ad-hoc
hack and semantically unclean.  It's just for your convenience.
Take a look at the code if you want to know the exact behavior.
@c JP
@code{<module-rules>} はモジュールごとのルールをきめるグローバルルール
です。@code{<module-pattern>} はモジュール名シンボルまたは(@code{mylib.*}
のような)グロブパターンを含むシンボルのどちらかです。@code{<rule>} が
手続きであれば、述語として使われ、この述語を満す値の束縛は再定義から
保護されます。@code{<rule>} がシンボルであれば、それと同じ名前の
変数の束縛は保護されます。@code{<rule>} が正規表現の場合、この正規表現に
マッチする名前の変数は保護されます。

再定義からの保護機構は、場当たり的なもので、セマンティクスとしても
不透明なものであることに注意してください。利便のためだけのものです。
正確な振舞いをしれたければ、コードを見てください。
@c COMMON
@end deftp

@defun reload module-name &optional rule @dots{}
@c EN
Reloads the specified module.   You can optionally specify
redefinition rules by @var{rule} @dots{},
where each @var{rule} is the term @code{<rule>} defined above.
@c JP
指定されたモジュールを再ロードします。オプションで
@var{rule} @dots{} をつかって再定義ルールを指定することができます。
ここで、それぞれの @var{rule} は上の @code{<rule>} で定義されたものです。
@c COMMON
@end defun

@defun reload-modified-modules &optional module-rules
@c EN
Reloads module(s) that have been modified since they are loaded
last time.  If optional @var{module-rules} is given, it is
used to determine the redefinition rules for reloaded modules.
If @var{module-rules} is omitted, the current rules are used.
The default of current rules is empty.   You can set the current
rules by @code{module-reload-rules}.
@c JP
前回ロードしたときより変更のあったモジュールを再ロードします。
オプション引数 @var{module-rules} が与えられていれば、再ロードした
モジュールに適用する再定義ルールを決定するために使います。
@var{module-rules}が省略された場合、現在のルールが適用されます。
デフォルトの現在のルールは空です。現在のルールは
@code{module-reload-rules}をつかって設定できます。

@c COMMON
@end defun

@defun module-reload-rules &optional module-rules
@c EN
This is a parameter (@xref{Parameters}) that keeps
the default module rules for @code{reload-modified-modules}.
If called without arguments, returns the current module rules.
If called with @var{module-rules}, sets the argument to the
current module rules.
@c JP
これは一種の「パラメータ」(@ref{Parameters}参照)で、
@code{reload-modified-modules}に対応するデフォルトのモジュールルールを
保持しています。引数なしで呼ばれたときには、現在のモジュールルールを
返します。@var{module-rules}とともに呼ばれたきにはその引数を
現在のモジュールルールにします。
@c COMMON
@end defun

@defun reload-verbose &optional flag
@c EN
This is a parameter to control verbosity of the reloading procedures.
If called without arguments, returns the current verbosity flag.
If called with @var{flag}, it is set to the current verbosity flag.
@c JP
これは再ロード手続きのメッセージ出力レベルを制御するパラメータです。
引数なしで呼ばれると現在の出力レベルフラグを返します。@var{flag}と
ともに呼ばれると現在の出力レベルをこれに設定します。
@c COMMON
@end defun

@c ----------------------------------------------------------------------
@node Simple dispatcher, Sequence framework, Reloading modules, Library modules - Gauche extensions
@section @code{gauche.selector} - Simple dispatcher
@c NODE 簡単なディスパッチャ, @code{gauche.selector} - 簡単なディスパッチャ

@deftp {Module} gauche.selector
@mdindex gauche.selector
@c EN
This module provides a simple interface to dispatch I/O events to
registered handlers, based on @code{sys-select} (@xref{I/O multiplexing}).
@c JP
このモジュールは、@code{sys-select} (@ref{I/Oの多重化}参照)に基づき、
登録されたハンドラにI/Oイベントをディスパッチするためのシンプルな
インタフェースを提供します。
@c COMMON
@end deftp

@deftp {Class} <selector>
@clindex selector
@c EN
A dispatcher instance that keeps watching I/O ports with associated
handlers.  A new instance can be created by @code{make} method.
@c JP
ディスパッチャのインスタンスで、ハンドラを携えてI/Oポートを監視します。
@code{make}メソッドで新しいインスタンスを作れます。
@c COMMON
@end deftp


@deffn {Method} selector-add! (self <selector>) port-or-fd proc flags
@c EN
Add a handler @var{proc} to the selector.  @var{proc} is called
when @var{port-or-fd}, which should be a port object or an integer
that specifies a system file descriptor,  meets a certain condition
specified by @var{flags}.
@var{flags} must be a list of one or more of the following symbols.
@c JP
セレクタにハンドラ@var{proc}を追加します。@var{proc}は、@var{port-or-fd}
(ポートオブジェクトかシステムのファイルディスクリプタを表す整数)が
@var{flags}で指定された条件に合致した場合に呼ばれます。
@var{flags}は、以下のシンボルの1つ以上のリストでなければなりません。
@c COMMON
@c EN
@table @code
@item r
Calls @var{proc} when data is available at @var{port-or-fd} to read.
@item w
Calls @var{proc} when @var{port-or-fd} is ready to be written.
@item x
Calls @var{proc} when an exceptional condition occurs on @var{port-or-fd}.
@end table
@c JP
@table @code
@item r
@var{port-or-fd}が読み取り可能になった時点で@var{proc}が呼ばれます。
@item w
@var{port-or-fd}が書き込み可能になった時点で@var{proc}が呼ばれます。
@item x
@var{port-or-fd}で例外的な状況が発生した場合に@var{proc}が呼ばれます。
@end table
@c COMMON

@c EN
@var{proc} is called with two arguments.  The first one is @var{port-or-fd}
itself, and the second one is a symbol @code{r}, @code{w} or @code{x},
indicating the condition.
@c JP
@var{proc}は、2引数で呼ばれます。1つ目は@var{port-or-fd}そのもので、
2つ目は条件を表すシンボル、@code{r}、@code{w}あるいは@code{x}です。
@c COMMON

@c EN
If a handler is already associated with @var{port-or-fd} under the
same condition, the previous handler is replaced by @var{proc}.
@c JP
同じ条件の下ですでに@var{port-or-fd}にハンドラが関連付けられていた場合は、
以前のハンドラが@var{proc}で置き換えられます。
@c COMMON
@end deffn

@deffn {Method} selector-delete! (self <selector>) port-or-fd proc flags
@c EN
Deletes the handler entries that matches @var{port-or-fd}, @var{proc}
and @var{flags}.   One or more of the arguments may be @code{#f},
meaning ``don't care''.  For example,
@c JP
@var{port-or-fd}、@var{proc}、@var{flags}にマッチするハンドラエントリを
削除します。引数のいずれかが@code{#f}である場合は、それが何でも良いことを
意味します。例えば、
@c COMMON
@example
(selector-delete! selector the-port #f #f)
@end example
@c EN
deletes all the handlers associated to @var{the-port}, and
@c JP
@var{the-port}に関連付けられた全てのハンドラを削除します。
@c COMMON
@example
(selector-delete! selector #f #f '(w))
@end example
@c EN
delets all the handlers waiting for writable condition.
@c JP
書き込み可能になるのを待っている全てのハンドラを削除します。
@c COMMON
@end deffn


@deffn {Method} selector-select (self <selector>) &optional (timeout #f)
@c EN
Dispatcher body.  Waits for the conditions registered in @var{self},
and when it occurs, calls the associated handler.
@c JP
ディスパッチャのボディです。@var{self}に登録された条件を待ち、条件が合致すると
それに関連付けられたハンドラを呼びます。
@c COMMON
@c EN
If the @var{timeout} argument is omitted or false, this method waits
indefinitely.  Alternatively you can give a timeout value, that can
be a real number in microseconds, or a list of two integers that
represents seconds and microseconds.
@c JP
@var{timeout}引数が省略されるか偽の場合、このメソッドは永久に待ちます。
タイムアウトの値を与える場合は、マイクロ秒を表す実数か、秒とマイクロ秒を
表す2つの整数のリストを与えます。
@c COMMON

@c EN
Returns the number of handlers called.  Zero means the selector has been
timed out.
@c JP
戻り値は、ハンドラが呼ばれた回数です。0(ゼロ)は、セレクタがタイムアウト
したことを意味します。
@c COMMON

@c EN
It is safe to modify @var{self} inside handler.  The change will be
effective from the next call of @code{selector-select}
@c JP
ハンドラの中で@var{self}を変更することは安全です。その変更は、次回の
@code{selector-select}の呼び出し以降に反映されます。
@c COMMON
@end deffn

@c EN
This is a simple example of "echo" server:
@c JP
echoサーバのシンプルな例を示します。
@c COMMON

@example
(use gauche.net)
(use gauche.selector)

(define (echo-server port)
  (let ((selector (make <selector>))
        (server   (make-server-socket 'inet port :reuse-addr? #t)))

    (define (accept-handler sock flag)
      (let* ((client (socket-accept server))
             (output (socket-output-port client)))
        (selector-add! selector
                       (socket-input-port client :buffered? #f)
                       (lambda (input flag)
                         (echo client input output))
                       '(r))))

    (define (echo client input output)
      (let ((str (read-block 4096 input)))
        (if (eof-object? str)
            (begin (selector-delete! selector input #f #f)
                   (socket-close client))
            (begin (display str output)
                   (flush output)))))

    (selector-add! selector
                   (socket-fd server)
                   accept-handler
                   '(r))
    (do () (#f) (selector-select selector))))
@end example

@c ----------------------------------------------------------------------
@node Sequence framework, Syslog, Simple dispatcher, Library modules - Gauche extensions
@section @code{gauche.sequence} - Sequence framework
@c NODE シーケンスフレームワーク, @code{gauche.sequence} - シーケンスフレームワーク

@deftp {Module} gauche.sequence
@mdindex gauche.sequence
@c EN
Provides a generic opertaions on @emph{sequences}.  A sequence is
a collection in which elements can be accessed by integer index,
starting with zero.
@c JP
@emph{シーケンス}に関するジェネリックな操作を提供するモジュールです。
シーケンスとは、コレクションのうち0から始まる整数インデックスで
アクセスできるものです。
@c COMMON

@c EN
This module inherits @code{gauche.collection} (@xref{Collection framework}),
All the collection generic operations can be applied to a sequence as well.
@c JP
このモジュールは@code{gauche.collection}を継承しています
(@ref{Collection framework}参照)。
コレクションに使えるジェネリックな操作は全てシーケンスに対しても適用可能です。
@c COMMON

@c EN
Among Gauche builtin class, lists, vectors and strings are sequences
and the specialized methods are defined for them.   Other extension
types, such as SRFI-4 uniform vector, have the methods as well.
@c JP
Gauche組み込みクラスのうち、リスト、ベクター、そして文字列は
シーケンスであり、このモジュールでメソッドが定義されます。
また@code{gauche.uvector}のユニフォームベクタ等、
いくつかの拡張データタイプはシーケンスとなっています。
@c COMMON
@end deftp

@menu
* Fundamental sequence accessors::  
* Slicing sequence::            
* Mapping over sequences::      
* Selection and searching in sequence::  
* Implementing sequence::       
@end menu

@node Fundamental sequence accessors, Slicing sequence, Sequence framework, Sequence framework
@subsection Fundamental sequence accessors
@c NODE 基本的なシーケンスのアクセサ

@deffn {Method} ref (seq <sequence>) index &optional fallback
@c EN
Returns @var{index}-th element of the sequence @var{seq}.
This method enables uniform access for any sequence types.

When @var{index} is less than zero, or greater than or equal to the
size of the sequence, @var{fallback} is returned if provided, or
an error is signalled if not.
@c JP
シーケンス@var{seq}の@var{index}番目の要素を返します。
このメソッドによって、全てのシーケンスが統一的にアクセスできます。

@var{index}が負値だったりシーケンスのサイズ以上だった場合は、
@var{fallback}が与えられていればそれが返され、
そうでなければエラーとなります。
@c COMMON

@example
(ref '(a b c) 1)  @result{} b
(ref '#(a b c) 1) @result{} b
(ref "abc" 1)     @result{} #\b
@end example
@end deffn

@deffn {Method} {(setter ref)} (seq <sequence>) index value
@c EN
Sets @var{value} to the @var{index}-th element of the sequence @var{seq}.
This is the uniform sequence modifier.
@c JP
統一的なシーケンスの変更メソッドです。
シーケンス@var{seq}の@var{index}番目の要素に@var{value}をセットします。
@c COMMON

@example
(let ((x (list 'a 'b 'c)))
  (set! (ref x 1) 'z)
  x) @result{} (a z c)

(let ((x (vector 'a 'b 'c)))
  (set! (ref x 1) 'z)
  x) @result{} #(a z c)

(let ((x (string #\a #\b #\c)))
  (set! (ref x 1) #\z)
  x) @result{} "azc"
@end example
@end deffn

@deffn {Method} referencer (seq <sequence>)
@end deffn

@deffn {Method} modifier (seq <sequence>)
@end deffn

@node Slicing sequence, Mapping over sequences, Fundamental sequence accessors, Sequence framework
@subsection Slicing sequence
@c NODE シーケンスのスライス

@deffn {Method} subseq (seq <sequence>) &optional start end
@c EN
Retrieve a subsequence of the sequence @var{seq}, from
@var{start}-th element (inclusive) to @var{end}-th element (exclusive).
If @var{end} is omitted, up to the end of sequence is taken.
The type of the returned sequence is the same as @var{seq}.
@c JP
シーケンス@var{seq}の、@var{start}番目の要素から@var{end}番目の要素の直前
までの部分シーケンスを返します。@var{end}が省略された場合はシーケンスの
最後までが取られます。返されるシーケンスの型は@var{seq}と同じになります。
@c COMMON

@example
(subseq '(a b c d e) 1 4)   @result{} (b c d)
(subseq '#(a b c d e) 1 4)  @result{} #(b c d)
(subseq "abcde" 1 4)        @result{} "bcd"

(subseq '(a b c d e) 3)     @result{} (d e)
@end example
@end deffn

@deffn {Method} {(setter subseq)} (seq <sequence>) start end value-seq
@deffnx {Method} {(setter subseq)} (seq <sequence>) start value-seq
@c EN
Sets the elements of @var{value-seq} from the @var{start}-th element
(inclusive) to the @var{end}-th element (exclusive) of the sequence @var{seq}.
@var{Value-seq} can be any sequence, but its size
must be larger than (@var{end} - @var{start}).

In the second form, @var{end} is figured out by the length of @var{value-seq}.
@c JP
@var{value-seq}の各要素を、シーケンス@var{seq}の@var{start}番目から
@var{end}番目の直前まで順にセットします。
@var{value-seq}はどんなシーケンスでも構いませんが、
(@var{end} - @var{start}) よりは長くなくてはなりません。

2番目の形式では、@var{end}が@var{value-seq}の長さから算出されます。
@c COMMON

@example
(define s (vector 'a 'b 'c 'd 'e))
(set! (subseq s 1 4) '(4 5 6))
s @result{} #(a 4 5 6 e)
(set! (subseq s 0)   "ab")
s @result{} #(#\a #\b 5 6 e)
@end example
@end deffn

@node Mapping over sequences, Selection and searching in sequence, Slicing sequence, Sequence framework
@subsection Mapping over sequences
@c NODE シーケンス上のマップ

@c EN
You can use extended @code{fold}, @code{map}, @code{for-each} and other
generic functions on sequences, since a sequence is also a collection.
However, sometimes you want to have index as well as the element itself
during iteration.   There are several generic functions for it.
@c JP
シーケンスはまたコレクションでもあるので、シーケンスについて
@code{fold}、@code{map}、@code{for-each}や他のジェネリック関数を
拡張することができます。しかし、時にはイテレーション中に要素そのものと
そのインデックスを知りたいことでしょう。そのためのジェネリック関数が
いくつかあります。
@c COMMON

@deffn {Method} fold-with-index kons knil (seq <sequence>) @dots{}
@c EN
Like generic @code{fold}, except @var{kons} is given
the index within @var{seq}, as the first argument,
as well as each element from @var{seq}s and the accrued value.
@c JP
ジェネリックな@code{fold}と似ていますが、@var{kons}には@var{seq}の
インデックス内から、第1引数として@var{seq}の要素と増加する値が渡る
点が異なります。
@c COMMON

@example
(fold-with-index acons '() '(a b c))
  @result{} ((2 . c) (1 . b) (0 . a))
@end example
@end deffn

@deffn {Method} map-with-index proc (seq <sequence>) @dots{}
@deffnx {Method} map-to-with-index class proc (seq <sequence>) @dots{}
@deffnx {Method} for-each-with-index proc (seq <sequence>) @dots{}
@c EN
Like @code{map}, @code{map-to} and @code{for-each}, except @var{proc}
receives the index as the first argument.
@c JP
@code{map}、@code{map-to}、@code{for-each}と似ていますが、@var{proc}が
第1引数としてインデックスを受け取る点が違います。
@c COMMON

@example
(map-with-index list '(a b c d) '(e f g h))
  @result{} ((0 a e) (1 b f) (2 c g) (3 d h))

(map-to-with-index <vector> cons '(a b c d))
  @result{} #((0 . a) (1 . b) (2 . c) (3 . d))
@end example
@end deffn

@deffn {Method} find-with-index pred (seq <sequence>)
@c EN
Finds the first element in @var{seq} that satisfies @var{pred}
like @code{find}, but returns two values, the index of the element
and the element itself.   If no element satisfies @var{pred},
two @code{#f}'s are returned.
@c JP
@code{find}のように、@var{seq}の中で@var{pred}を満足する最初の要素を
探しますが、2つの値、要素のインデックスと要素自身を返します。
@var{pred}を満足する要素がなかったら、2つの@code{#f}が返ります。
@c COMMON

@example
(find-with-index char-upper-case? "abraCadabra")
  @result{} 4 and #\C

(find-with-index char-numeric? "abraCadabra")
  @result{} #f and #f
@end example
@end deffn

@deffn {Method} find-index pred (seq <sequence>)
@c EN
Like @code{find}, but returns the index of the first element
that satisfies @var{pred} in @var{seq}, instead of the element itself.
If no element in @var{seq} satisfies @var{pred}, @code{#f} is returned.
@c JP
@code{find}に似ていますが、@var{seq}の中で@var{pred}を満足する最初の、
要素自身ではなくインデックスを返す点が異なります。
@var{seq}の中に@var{pred}を満足する要素がなかったら、@code{#f}が返ります。
@c COMMON

@example
(find-index char-upper-case? "abraCadabra")
  @result{} 4 

(find-index char-numeric? "abraCadabra")
  @result{} #f
@end example

@c EN
See also @code{list-index} in SRFI-1 (@xref{SRFI-1 Searching}).
@c JP
SRFI-1 (@ref{SRFI-1 Searching}参照)の@code{list-index}も見て下さい。
@c COMMON
@end deffn

@node Selection and searching in sequence, Implementing sequence, Mapping over sequences, Sequence framework
@subsection Selection and searching in sequence
@c NODE シーケンスに対する選択と探索

@c EN
Note that selection and searching methods for collections 
can also be applied to sequences.
See @ref{Selection and searching in collection}.
@c JP
コレクションに対する選択と探索はシーケンスにも使えます。
@ref{Selection and searching in collection}を参照して下さい。
@c COMMON

@deffn {Generic function} group-sequence seq &keyword key test
@c EN
Groups consecutive elements in a sequence @var{seq} which
have the common key value.  A key value of an element is
obtained by applying the procedure @var{key} to the element;
the default procedure is @code{identity}.
For each element in @var{seq}, @var{key} is applied exactly once.
The equal-ness of keys are compared by @var{test} procedure,
whose default is @code{eqv?}.
@c JP
シーケンス@var{seq}の連続する要素で、同じキー値を持つもの同士を
グループ化します。
キーの値は要素に手続き@var{key}を適用することで得られます。@var{key}の
デフォルト値は@code{identity}です。@var{sedq}の各要素に対して、
@var{key}は正確に一回だけ呼ばれます。
キーの等価性判定には手続き@var{test}が使われます。デフォルト値は@code{eqv?}です。
@c COMMON

@example
(group-sequence '(1 1 1 2 3 4 4 2 2 3 1 1 3))
  @result{} ((1 1 1) (2) (3) (4 4) (2 2) (3) (1 1) (3))

(group-sequence '(1 1 1 2 3 4 4 2 2 3 1 1 3) 
                :key (cut modulo <> 2)))
  @result{} ((1 1 1) (2) (3) (4 4 2 2) (3 1 1 3))

(group-sequence '#("a" "a" "b" "b" "c" "d" "d") 
                :test string=?)
  @result{} (("a" "a") ("b" "b") ("c") ("d" "d"))

(group-sequence "aabbcdd"
                :test char=?)
  @result{} ((#\a #\a) (#\b #\b) (#\c) (#\d #\d))
@end example

@c EN
This method is similar to Haskell's @code{group}.
If you want to group elements that are not adjacent, 
use @code{group-collection} 
(@xref{Selection and searching in collection}).
@c JP
このメソッドはHaskellの@code{group}と似ています。
隣り合っていない要素もグループ化したい場合は、
@code{group-collection} 
(@ref{Selection and searching in collection}参照)を使って下さい。
@c COMMON

@end deffn




@node Implementing sequence,  , Selection and searching in sequence, Sequence framework
@subsection Implementing sequence
@c NODE シーケンスを実装する



@c ----------------------------------------------------------------------
@c @node Serializer, Termios, Simple dispatcher, Library modules
@c @section @code{gauche.serializer} - Serializer

@c @deftp {Module} gauche.serializer
@c @mdindex gauche.serializer
@c @end deftp

@c ----------------------------------------------------------------------
@node  Syslog, Termios, Sequence framework, Library modules - Gauche extensions
@section @code{gauche.syslog} - Syslog
@c NODE Syslog, @code{gauche.syslog} - Syslog

@deftp {Module} gauche.syslog
@mdindex gauche.syslog
@c EN
This module provides syslog(3) system logger interface.

For the common applications, you might find @code{gauche.logger} module
easier to use (@xref{User-level logging}).  This module is for those
who need direct access to the syslog API.

The procedures are only defined if the undelying system supports them.
@c JP
このモジュールは syslog(3) のシステムロガーのインタフェースを提供します。

一般的なアプリケーションについては、@code{gauche.logger} モジュールの
ほうが使いやすいでしょう(@ref{User-level logging}参照)。
このモジュールは syslog の API に直接アクセスする必要のある人向きです。

手続き群は基盤になっているシステムで syslog がサポートされている場合に
のみ定義されます。
@c COMMON
@end deftp

@defun sys-openlog ident option facility
[POSIX]
@c EN
Opens a connection to the system logger.  A string argument
@var{ident} is used for the prefix of the log, and usually is
the program name.  @var{Option} is an integer flag to control
the behavior of logging, and @var{facility} is an integer
that specify the type of the program.

The flag for @var{option} can be composed by @code{logior}-ing
one or more of the following integer constants:
@code{LOG_CONS}, @code{LOG_NDELAY}, @code{LOG_NOWAIT},
@code{LOG_ODELAY}, @code{LOG_PERROR} and @code{LOG_PID}.
(Some of the constants may not be defined if the underlying system
doesn't support them).

The @var{facility} argument can be one of the following integer
constants: @code{LOG_AUTH}, @code{LOG_AUTHPRIV}, @code{LOG_CRON},
@code{LOG_DAEMON}, @code{LOG_FTP}, @code{LOG_KERN}, @code{LOG_LOCAL0}
through @code{LOG_LOCAL7}, @code{LOG_LPR}, @code{LOG_MAIL}, @code{LOG_NEWS},
@code{LOG_SYSLOG}, @code{LOG_USER} and @code{LOG_UUCP}.
(Some of the constants may not be defined if the underlying system
doesn't support them).

See your system's manpage of openlog(3) for detail description about
these constants.
@c JP
システムロガーへのコネクションをオープンします。文字列の引数 @var{ident}
はログの接頭辞に使われます。通常はプログラムを名前にします。@var{option}
は整数のフラグで、ログの振舞いを制御します。@var{facility} はプログラムの
タイプを指定する整数です。

@var{option}のフラグは以下の整数定数の1つまたは複数を @code{logior} で
合成することができます：
@code{LOG_CONS}、@code{LOG_NDELAY}、@code{LOG_NOWAIT}、
@code{LOG_ODELAY}、@code{LOG_PERROR} および @code{LOG_PID} です
(これらの定数のいくつかは基盤となるシステムがサポートしていなければ
定義されません)。

@var{facility} 引数は以下の整数定数のどれかひとつです。
@code{LOG_AUTH}、@code{LOG_AUTHPRIV}、@code{LOG_CRON},
@code{LOG_DAEMON}、@code{LOG_FTP}、@code{LOG_KERN}、@code{LOG_LOCAL0}、
から @code{LOG_LOCAL7}、@code{LOG_LPR}、@code{LOG_MAIL}、@code{LOG_NEWS},
@code{LOG_SYSLOG}、@code{LOG_USER}、@code{LOG_UUCP} までです。
(これらの定数のいくつかは基盤となるシステムがサポートしていなければ
定義されません)。

これらの定数の詳しい説明については、システムの openlog(3) の
マニュアル・ページを見てください。
@c COMMO
@end defun

@defun sys-syslog priority message
[POSIX]
@c EN
Log the string @var{message}.  Unlike syslog(3), this procedure doesn't
do formatting---you can use @code{format} (@xref{Output}) to create
a formatted message, or use higher-level routine @code{log-format}
(@xref{User-level logging}).

An integer argument @var{priority} can be composed by @code{logior}-ing
one of the @var{facility} constants described above and
the @var{level} constants: @code{LOG_EMERG}, @code{LOG_ALERT},
@code{LOG_CRIT}, @code{LOG_ERR}, @code{LOG_WARNING}, @code{LOG_NOTICE},
@code{LOG_INFO}, @code{LOG_DEBUG}.
@c JP
文字列 @var{message} をログに記録します。syslog(3) とは違って、この手続きは
フォーマットを行いません。フォーマットされた文字列を生成するなら
@code{format} (@ref{Output}参照)が使えます。あるいは、より高水準の
ルーチン @code{log-format} (@ref{User-level logging}参照)
を使うこともできます。

整数の引数 @var{priority} は上述の @var{facility} 定数のどれかひとつ
と、以下の@var{level}定数と@code{logior}して、合成することができます：
@code{LOG_EMERG}、@code{LOG_ALERT}、@code{LOG_CRIT}、@code{LOG_ERR}、
@code{LOG_WARNING}、@code{LOG_NOTICE}、@code{LOG_INFO}、@code{LOG_DEBUG}
@c COMMON

@end defun

@defun sys-closelog
[POSIX]
@c EN
Closes the connection to the logging system.
@c JP
ロギングシステムとのコネクションをクローズします。
@c COMMON
@end defun

@defun sys-setlogmask mask
[POSIX]
@c EN
Sets the process's log priority mask that determines which calls to
@code{sys-syslog} may be logged.
An priority @var{mask} can be composed by @code{logior}-ing
bitmasks corresponding to the @var{level} argument of @code{sys-syslog}.
You can use @code{sys-logmask} below to obtain a bitmask
from the level.
@c JP
どの @code{sys-syslog}への呼び出しを記録できるかを決める、プロセスのログ
優先度マスクを設定します。
優先度マスク@var{mask}は@code{sys-syslog}の@var{level}引数に
対応するビットマスクを@code{logior}することで作成できます。
レベルに対応するビットマスクは下の@code{sys-logmask}から
取得することができます。
@c COMMON
@end defun

@defun sys-logmask level
[POSIX]
@c EN
Returns an integer bitmask for @code{sys-setlogmask} from 
the log level @var{level}.
@c JP
ログレベル @var{level} から @code{sys-setlogmask} に対する
ビットマスク整数を返します。
@c COMMON
@end defun

@c ----------------------------------------------------------------------
@node Termios, Unit testing, Syslog, Library modules - Gauche extensions
@section @code{gauche.termios} - Termios
@c NODE Termios, @code{gauche.termios} - Termios

@deftp {Module} gauche.termios
@mdindex gauche.termios
@c EN
This module defines POSIX termios interface, which
controls terminal attributes.  This module also provides
pseudo tty interface, if the system provides it.
@c JP
このモジュールは端末の属性を制御する POSIX termios インタフェースを
定義しています。さらに、このモジュールでは、システムが提供している場合には
擬似 tty のインタフェースも提供しています。
@c COMMON
@end deftp

@deftp {Builtin Class} <sys-termios>
@clindex sys-termios
@c EN
POSIX termios(7) structure.
@c JP
POSIX termios(7) の構造体です。
@c COMMON

@defivar {<sys-termios>}  iflag
@end defivar
@defivar {<sys-termios>}  oflag
@end defivar
@defivar {<sys-termios>}  cflag
@end defivar
@defivar {<sys-termios>}  lflag
@end defivar
@defivar {<sys-termios>}  cc
@end defivar

@c EN
The slots @code{iflag}, @code{oflag}, @code{cflag} and @code{lflag}
contains non-negative integers representing bitmasks.

The slot @code{cc} contains a @emph{copy} of @code{c_cc} array
of @code{struct termios}, as an u8vector (see @ref{Uniform vectors}
for the details about u8vector).
Since @code{cc} slot is a copy of the internal structure, you have
to @code{set!} an u8vector to the slot explicitly to make
changes to the @code{c_cc} array.
@c JP
@code{iflag}、@code{oflag}、@code{cflag}、@code{lflag}の各スロットは、
対応するビットマスクを非負の整数で表現した値を保持しています。

また、@code{cc}スロットは@code{struct termios}の@code{c_cc}配列の
@emph{コピー}を返します。
@code{c_cc}配列の値を変えたい場合は、変更したu8vectorを明示的に
@code{cc}スロットに@code{set!}して下さい。
@c COMMON

@end deftp

@c EN
Throughout this section, argument @var{port-or-fd} refers to
either a port object or a small integer representing system's file 
descriptor.  If @var{port} is not associated
to the system terminal, an error is signalled.  (You can check if @var{port}
has an associated terminal by @code{sys-isatty?}.
@xref{Other file operations}).
@c JP
このセクションを通じて、引数 @var{port-or-fd} はポートオブジェクトか
システムのファイルディスクリプタを表現する小さい整数かのどちらかです。
@var{port}がシステム端末に結びついていないければ、エラーになります。
(@code{sys-isatty?}を使えば@var{port}が端末と結びついているか
どうかチェックできます。 @ref{Other file operations}参照)
@c COMMON

@defun sys-tcgetattr port-or-fd
@c EN
Returns terminal parameters in a @code{<sys-termios>} object,
associated to @var{port-or-fd}.
@c JP
@var{port-or-fd} と結びついている @code{<sys-termios>}オブジェクトの
端末パラメータを返します。
@c COMMON
@end defun

@defun sys-tcsetattr port-or-fd when termios
@c EN
Sets terminal parameters associated to @var{port-or-fd} by @var{termios},
which must be an instance of @code{<sys-termios>}.

An integer argument @var{when} specifies when the changes take effect.
Three variables are pre-defined for the argument:
@c JP
@var{port-or-fd}と結びついている端末のパラメータを @var{termios} に設定します。
@var{termios} は @code{<sys-termios>} のインスタンスでなければなりません。

整数の引数@var{when}はいつ変更を有効にするかを指定します。
この引数用に3つの変数があらかじめ定義されています。
@c COMMON
@table @code
@item TCSANOW
@vindex TCSANOW 
@c EN
The change is reflected immediately.
@c JP
変更を直ちに反映します。
@c COMMON
@item TCSADRAIN
@vindex TCSADRAIN
@c EN
The change is reflected after all pending output is flushed.
@c JP
変更を、すべてのペンディングになっている出力がフラッシュされた後に反映します。
@c COMMON
@item TCSAFLUSH
@vindex TCSAFLUSH
@c EN
The change is reflected after all pending output is flushed,
and all pending input is discarded.
@c JP
変更を、すべてのペンディングになっている出力がフラッシュされ、かつ、
すべてのペンディングになっている入力が破棄されたあとに反映します。
@c COMMON
@end table
@end defun

@defun sys-tcsendbreak port-or-fd duration
@c EN
Transmits a zero stream for the specified duration
to the terminal associated to @var{port-or-fd}.
The unit of duration depends on the system; see man tcsendbreak(3) of
your system for details.
@c JP
ゼロストリームを指定した時間、@var{port-or-fd}と結びついている端末に
送出します。。時間の単位はシステム依存です。詳しくは、おつかいの
システムのマニュアルページ tcsendbreak(3)を参照してください。
@c COMMON
@end defun

@defun sys-tcdrain port-or-fd
@c EN
Waits until all output written to @var{port-or-fd} is transmitted.
@c JP
@var{port-or-fd}へのすべての出力が送出されるまで待ちます。
@c COMMON
@end defun

@defun sys-tcflush port-or-fd queue
@c EN
Discards data in the buffer of @var{port-or-fd}, specified by 
@var{queue}, which may be one of the following values.
@c JP
@var{port-or-fd}のバッファ内のデータを破棄します。@var{queue}には以下の値の
どれかを指定します。
@c COMMON
@table @code
@item TCIFLUSH
@vindex TCIFLUSH
@c EN
Discards data received but not read.
@c JP
受信データしたが読み込んではいないデータを破棄します。
@c COMMON
@item TCOFLUSH
@vindex TCOFLUSH
@c EN
Discards data written but not transmitted.
@c JP
書き出したが送出していないデータを破棄します。
@c COMMON
@item TCIOFLUSH
@vindex TCIOFLUSH
@c EN
Do both @code{TCIFLUSH} and @code{TCOFLUSH} action.
@c JP
@code{TCIFLUSH} と @code{TCOFLUSH} の両方の動作をします。
@c COMMON
@end table
@end defun

@defun sys-tcflow port-or-fd action
@c EN
Controls data flow of @var{port-or-fd} by @var{action}, which may be
one of the following values:
@c JP
@var{port-or-fd}のデータフローを@var{action}で制御します。@var{action}は
以下の値のうちどれかです。
@c COMMON
@table @code
@item TCOOFF
@vindex TCOOFF
@c EN
Suspends output transmission.
@c JP
出力の送出をサスペンドします。
@c COMMON
@item TCOON
@vindex TCOON
@c EN
Restarts output transmission.
@c JP
出力の送出を再開します。
@c COMMON
@item TCIOFF
@vindex TCIOFF
@c EN
Transmits a STOP character to make the terminal device stop transmitting
data to the system.
@c JP
端末デバイスがシステムへの送出を止めるよう STOP 文字を送出する。
@c COMMON
@item TCION
@vindex TCION
@c EN
Transmits a START character to make the terminal device resume transmitting
data to the system.
@c JP
端末デバイスがシステムへの送出を再開するよう START 文字を送出する。
@c COMMON
@end table
@end defun

@defun sys-tcgetpgrp port-or-fd
@c EN
Returns process group ID of the terminal associated to @var{port-or-fd}.
@c JP
@var{port-or-fd}の結びついている端末のプロセスのグループIDを返します。
@c COMMON
@end defun

@defun sys-tcsetpgrp port-or-fd pgrp
@c EN
Sets process group ID of the terminal associated to @var{port-or-fd}
to @var{pgrp}.
@c JP
@var{port-or-fd}の結びついている端末のプロセスのグループIDを@var{pgrp}に
設定します。
@c COMMON
@end defun

@defun sys-cfgetispeed termios
@defunx sys-cfsetispeed termios speed
@defunx sys-cfgetospeed termios
@defunx sys-cfsetospeed termios speed
@c EN
Gets/sets input/output speed (baud rate) parameter stored in @var{termios}
object.   Speed is represented by the following predefined numbers:
@code{B0}, @code{B50}, @code{B75}, @code{B110}, @code{B134}, 
@code{B150}, @code{B200}, @code{B300}, @code{B600}, @code{B1200}, 
@code{B1800}, @code{B2400}, @code{B4800}, @code{B9600},
@code{B19200}, @code{B38400}.
@c JP
@var{termios}内の入出力スピード(ボーレート)を取得/設定します。スピードは
以下の定義ずみの数値で表現されてます：
@code{B0}、@code{B50}、@code{B75}、@code{B110}、@code{B134}、
@code{B150}、@code{B200}、@code{B300}、@code{B600}、@code{B1200}、
@code{B1800}、@code{B2400}、@code{B4800}、@code{B9600}、
@code{B19200}、@code{B38400}。
@c COMMON

@c EN
Some system may support higher baud rate, such as @code{B57600},
@code{B115200} or @code{B230400}.  You can use @code{symbol-bound?}
to check these options are defined.  @code{B0} is used to
terminate the connection.
@c JP
もっと速いボーレート、たとえば、@code{B57600}、
@code{B115200} あるいは @code{B230400} をサポートしている
システムもあります。@code{symbol-bound?}をつかえば、これらの
オプションが定義されているかどうかをチェックできます。@code{B0}
はコネクションを終了するのに使われます。
@c COMMON
@end defun

@defun sys-openpty &optional term
@c EN
Opens a pair of pseudo ttys, one for master and the other for slave,
then returns two integers which are their file descriptors.
An optional argument @var{term} must be, if passed, a @code{<sys-termios>}
object; it sets the slave pty's parameters.

You can use @code{open-input-fd-port} and/or @code{open-output-fd-port}
to create a port around the returned file descriptor (@xref{File ports}).
To obtain pseudo tty's name, use @code{sys-ttyname}
(@xref{Other file operations}).

This function is available only if the system supports @code{openpty(3)}.
@c JP
擬似 tty のペア、マスターとスレーブをオープンし、2つの
ファイルディスクリプタの整数を返します。オプション引数 @var{term} 
が渡される場合は、@code{<sys-termios>}オブジェクトでなければなりません。
これは、pty パラメータを設定します。

@code{open-input-fd-port}と@code{open-output-fd-port}の両方またはどちらか
を返されたファイルディスクリプタに対するポートを生成するために使うことが
できます(@ref{File ports}参照)。擬似端末の名前を得るには @code{sys-ttyname}
を使います(@ref{Other file operations}参照)。

この関数はシステムが @code{openpty(3)} をサポートしている場合にのみ利用
可能です。
@c COMMON
@end defun

@defun sys-forkpty &optional term
@c EN
Opens a pair of pseudo ttys, one for master and the other for slave,
sets the slave pty suitable for login terminal, then fork(2).

Returns two integers; the first value is a child pid for the parent process,
and 0 for the child process.  The second value is a file descriptor
of the master pty.

An optional argument @var{term} must be, if passed, a @code{<sys-termios>}
object; it sets the slave pty's parameters.

This function is available only if the system supports @code{forkpty(3)}.
@c JP
擬似 ttyのペア、マスターとスレーブをオープンし、スレーブ sty を
ログイン端末になるよう設定し、fork(2) します。

二つの整数、最初の値は親プロセスに対しては子の pid の値で、0ならば
子プロセスです。ふたつ目の値はマスター pty のファイルディスクリプタの
値です。

オプション引数 @var{term}が渡される場合は、それは@code{<sys-termios>}オブジェクト
でなければなりません。これはスレーブ pty のパラメータを設定します。

この関数はシステムが @code{forkpty(3)} をサポートしている場合にのみ利用
可能です。
@c COMMON
@end defun

@c EN
The following example shows how to get a password from the user
without echoing:
@c JP
以下の例は、ユーザからのパスワードをエコーなしで取得する方法を示しています。
@c COMMON

@example
(use gauche.termios)

(define (get-password prompt)
  (let* ((port (current-input-port))
         (attr (sys-tcgetattr port))
         (lflag (slot-ref attr 'lflag)))
    ;; Show prompt
    (display prompt)
    (flush)
    ;; Turn off echo during reading.
    (dynamic-wind
     (lambda ()
       (slot-set! attr 'lflag (logand lflag (lognot ECHO)))
       (sys-tcsetattr port TCSAFLUSH attr))
     (lambda ()
       (read-line port))
     (lambda ()
       (slot-set! attr 'lflag lflag)
       (sys-tcsetattr port TCSANOW attr)))))
@end example

@c ----------------------------------------------------------------------
@node Unit testing, Threads, Termios, Library modules - Gauche extensions
@section @code{gauche.test} - Unit Testing
@c NODE 単体テスト, @code{gauche.test} - 単体テスト

@deftp {Module} gauche.test
@mdindex gauche.test
@c EN
Defines a set of functions to write test scripts.
A test script will look like this:
@lisp
(use gauche.test)
(test-start "my feature")
(load "my-feature")  ; @r{load your program}
(import my-feature)  ; @r{if your program defines a module.}

(test-module 'my-feature) ; @r{tests consistency in your module.}

(test-section "feature group 1")
(test "feature 1-1" EXPECT (lambda () TEST-BODY))
(test "feature 1-2" EXPECT (lambda () TEST-BODY))
 @dots{}

(test-section "feature group 2")
(define test-data ...)
(test "feature 2-1" EXPECT (lambda () TEST-BODY))
(test "feature 2-2" *test-error* (lambda () TEST-THAT-SIGNALS-ERROR))
 @dots{}

(test-end)
@end lisp
@c JP
テストスクリプトを書くための手続きを提供します。
テストスクリプトは次のような形になります。
@lisp
(use gauche.test)
(test-start "my feature")
(load "my-feature")  ; @r{テストすべきプログラムをロード}
(import my-feature)  ; @r{モジュールを定義している場合はインポート}

(test-module 'my-feature) ; @r{モジュールの一貫性チェック}

(test-section "feature group 1")
(test "feature 1-1" EXPECT (lambda () TEST-BODY))
(test "feature 1-2" EXPECT (lambda () TEST-BODY))
 @dots{}

(test-section "feature group 2")
(define test-data ...)
(test "feature 2-1" EXPECT (lambda () TEST-BODY))
(test "feature 2-2" *test-error* (lambda () TEST-THAT-SIGNALS-ERROR))
 @dots{}

(test-end)
@end lisp
@c COMMON

@c EN
With this convention, you can run test both interactively or
in batch.   To run a test interactively, just load the file
and it reports a result of each test, as well as the summary
of failed test at the end.  To run a test in batch, it is
convenient to redirect the stdout to some file
If stdout is redirected to other than tty, all the verbose logs will go
there, and only a small amount of messages go to stderr.
@c JP
このテストスクリプトは、バッチ処理でもインタラクティブセッションからでも
実行できます。インタラクティブセッションの場合はこのテストスクリプトを
ただロードすれば、各テストの結果とサマリーが報告されます。
バッチテストの場合は、標準出力を別のファイルにリダイレクトしておくと良いでしょう。
標準出力が端末でない場合、テスト手続きは詳しい結果をstdoutに出力し、簡単な
メッセージを標準エラー出力に書き出します。
@c COMMON

@c EN
It is recommended to have a "test" target always in Makefile
of your module/program, so that the user of your program can run a
test easily.  The rule may look like this:
@c JP
モジュールやプログラムを書いたら、Makefileに"test"ターゲットを作ることを
お薦めします。ルールはこんな感じになるでしょう：
@c COMMON

@example
test :
        gosh my-feature-test.scm > test.log
@end example

@end deftp

@defun test name expected thunk &optional compare
@c EN
Calls @var{thunk}, and compares its result with @var{expected}.
The comparison predicate is @code{equal?} by default, but you can
specify your own predicate by the argument @var{compare}.
@var{Name} is a name of the test, for logging purpose.

If @var{thunk} signals an uncaptured error, it is catched and
yields a special error object.  A global variable @code{*test-error*}
is bound to the error object, so that you can test an expected error.

The procedure @var{compare} is called as follows:
@example
(@var{compare} @var{expected} @var{result-of-thunk})
@end example
It should return @code{#t} if the given result agrees the 
expected value, or @code{#f} otherwise.
One typical usage of the custom comparison
method is to compare inexact numbers tolerating small error.
@c JP
@var{thunk}を呼び、その結果を@var{expected}と比較します。
比較手続きには、引数@var{compare}が与えられていればそれを用い、
そうでなければ@code{equal?}
を用います。@var{name}はログに残すためのテストの名前です。

@var{thunk}内で捕捉されないエラーが発生した場合、それは捕捉され、
特別なエラーオブジェクトに置き換えられます。グローバル変数@code{*test-error*}
がエラーオブジェクトに束縛されており、エラーが期待される状況もテストすることが
できます。

手続き@var{compare}は次のように呼び出されます。
@example
(@var{compare} @var{expected} @var{result-of-thunk})
@end example
この手続きは、渡された結果が期待する値と合致する場合に@code{#t}を、
そうでなければ@code{#t}を返さなければなりません。
特別な比較手続きのひとつの用法は、不正確な数値を、多少の誤差を許して
比較するような場合です。
@c COMMON

@example
(test "test 1" (/ 3.141592653589 4)
      (lambda () (atan 1))
      (lambda (expected result)
        (< (abs (- expected result)) 1.0e-10)))
@end example
@end defun

@defvar *test-error*
@c EN
Bound to a special error object, which can be used as an expected
value if the test thunk is supposed to signal an error.
@c JP
特別なエラーオブジェクトに束縛されています。
テストのthunkがエラーを起こすことが期待されている状況で、
エラーオブジェクトを@var{expected}引数に渡すことができます。
@c COMMON

@example
(test "test if car signals an error" *test-error*
      (lambda () (car 5)))
@end example
@end defvar

@defvar *test-report-error*
@c EN
If this variable is true, the @code{test} routine prints stack trace
to the current error port when it captures an error.  It is useful
when you got an unexpected test-error object and want to check out
where the error is occurring.

This variable is initialized by the environment variable
@code{GAUCHE_TEST_REPORT_ERROR} when the @code{gauche.test} module
is loaded.  For example, you can use the environment variable to check out
an unexpected error from your test script as follows (the value
of the environment variable doesn't matter).
@c JP
この変数が真であれば、@code{test}ルーチンはエラーを捕捉した際に
スタックトレースをカレントエラーポートに出力します。
期待しない状況でtest-errorオブジェクトが返された際に、そのエラーが
どこで起こったかを知るのに役立つでしょう。

この変数は@code{gauche.test}モジュールが読み込まれた時点で
環境変数@code{GAUCHE_TEST_REPORT_ERROR}の値により初期化されます。
例えば、テストスクリプト中の予期せぬエラーを調べるのに、
次のようにすることができるでしょう (環境変数がセットされていれば、値は関係ありません)。
@c COMMON

@example
env GAUCHE_TEST_REPORT_ERROR=1 gosh mytest.scm
@end example
@end defvar


@defmac test* name expected expr &optional compare
@c EN
A convenience macro that wraps @var{expr} by lambda.
@c JP
@var{expr}をlambdaでくるんでくれる便利なマクロです。
@c COMMON

@example
(test* name expected expr)
  @equiv{} (test name expected (lambda () expr))
@end example
@end defmac

@defun test-module module
@c EN
@var{Module} must be a symbol module name or a module.
This procedure performs some heuristic consistency check of
the given module: (1) whether symbols set as autoload
in @var{module} can actually be loaded, and (2) whether
the symbols declared in export list is actually defined
in the module.   Although not perfect, this test can catch
some careless typo in symbol names.
@c JP
@var{Module}はモジュール名のシンボルかモジュールでなければなりません。
この手続きはモジュール@var{module}に関していくつかの経験的な一貫性チェックを
行います：(1) autoloadに設定されたシンボルがちゃんとロードできるか、
(2) exportにリストされたシンボルがモジュール内で定義されているか。
この手続きは完璧ではないものの、
ケアレスミスによる名前の綴り間違いを発見することができます。
@c COMMON
@end defun

@defun test-start module-name
@c EN
Initializes internal state and prints a log header.
This should be called before any tests.
@var{Module-name} is used only for logging purpose.
@c JP
テストの状態を初期化して、ヘッダをログに書き出します。テストを呼ぶ前に呼んで下さい。
@var{module-name}はログのために使われる文字列です。
@c COMMON
@end defun

@defun test-section section-name
@c EN
Marks beginning of the group of tests.  This is just for logging.
@c JP
一群のテストの開始をマークします。単にログに使われるだけです。
@c COMMON
@end defun

@defun test-end
@c EN
Prints out list of failed tests.
@c JP
失敗したテストのリストを報告します。
@c COMMON
@end defun

@c ----------------------------------------------------------------------
@node Threads, Measure timings, Unit testing, Library modules - Gauche extensions
@section @code{gauche.threads} - Threads
@c NODE スレッド, @code{gauche.threads} - スレッド

@c EN
If enabled at compilation time, Gauche can use threads
built on top of POSIX threads (pthreads).
@c JP
Gaucheでは、コンパイル時に有効にしていれば、POSIXスレッド(pthreads)の
上に構築されるスレッドを使うことができます。
@c COMMON

@deftp {Module} gauche.threads
@mdindex gauche.threads
@c EN
Provides thread API.   You can 'use' this module regardless
whether the thread support is compiled in or not; if threads are not
supported, many thread-related procedures simply signals a 
"not supported" error.
@c JP
スレッドを扱うAPIを提供します。コンパイル時にスレッドのサポートを
指定したか否かに関わらず、このモジュールを'usr'することができます。
スレッドがサポートされていない場合は、多くのスレッド関連の手続きは
単に``not supported''エラーを通知するだけです。
@c COMMON
@end deftp

@c EN
To check if threads are available in the running Gauche program,
use the following procedure.
@c JP
動作中のGaucheプログラムの中でスレッドが有効かどうかをチェックするためには、
次の手続きを使います。
@c COMMON

@defun gauche-thread-type
@c EN
Returns a symbol that indicates the supported thread type.
In the current version, the return value may be @code{pthread}
when threads on top of POSIX threads are available, or
@code{none} when threads are not available.
@c JP
サポートされているスレッドのタイプを表すシンボルを返します。
現在のバージョンでは、POSIXスレッドの上に構築されるスレッドが
有効な場合は@code{pthread}を返し、スレッドが有効でない場合は
@code{none}を返します。
@c COMMON
@end defun

@c EN
Scheme-level thread API conforms SRFI-18, "Multithreading support"
(@ref{srfi-18,,[SRFI-18]}), wrapped around Gauche's object interface.
@c JP
SchemeレベルのスレッドAPIはSRFI-18、``マルチスレッドサポート''
(@ref{srfi-18,,[SRFI-18]})を満たし、Gaucheのオブジェクトの
インターフェースでラップされます。
@c COMMON

@menu
* Thread programming tips::     
* Thread procedures::           
* Synchronization primitives::  
* Thread exceptions::           
@end menu

@node Thread programming tips, Thread procedures, Threads, Threads
@subsection Thread programming tips
@c NODE スレッドプログラミングTips

@c EN
Although the surface API of threads looks simple and portable,
you need to know how the threads are implemented in order to utilize
the feature's potential.   Some languages support threads as
language's built-in construct and encourage programmers
to express the calculation in terms of threads.
However, it should be noted that in many cases there are
alternative ways than threads to implement the desired
algorithm, and you need to compare advantages and
disadvantages of using threads depending on how the threads
are realized in the underlying system.
@c JP
スレッドのAPIは外見上シンプルでポータブルに見えますが、
その機能の潜在的な力を活用するためには、スレッドがどのように
実装されているかを知る必要があります。
いくつかの言語では言語組み込みの機能としてスレッドをサポートし、
プログラマによるスレッドの利用を推奨しています。
しかし、多くの場合、実現したいアルゴリズムをスレッドを使わずに
実装する方法があります。
スレッドを使うことの利点と欠点を、そのスレッドがシステムによってどのように
実現されているかを考慮した上で比較する必要があります。
@c COMMON

@c EN
In Gauche, the primary purpose of threads is to write programs
that @emph{require} preemptive scheduling, therefore are
difficult to express in other ways.  Preemptive threads may
be required, for example, when you have to call a module that 
does blocking I/O which you can't intercept, or may spend
nondeterministic amount of calculation time that you want
to interrupt.
@c JP
Gaucheでは、スレッドを使う一番の目的は、他の方法で表現することが
難しい、プリエンプティブなスケジューリングを@emph{必要}とする
プログラムを書くことです。プリエンプティブなスレッドは、
例えば、中断できないブロッキングI/Oを行うモジュールを
使わなければならないときや、実行時間の分からない計算に
割り込みを行いたいときなどに必要となります。
@c COMMON

@c EN
For each Gauche's thread, an individual VM is allocated
and it is run by the dedicated POSIX thread.  Thus there
is not much overhead in context switch than the native
thread, but the creation of threads costs much higher than,
say, lightweight threads built on top of call/cc.
So Gauche's preemptive threads are @emph{not} designed for
applications that want to create thousands of threads
for fine-grained calculation.
@c JP
それぞれのGaucheのスレッドには、個別の仮想マシンが割り当てられ、
専用のPOSIXスレッドにより実行されます。したがって、コンテキスト
スイッチのオーバヘッドは、ネイティブスレッドとほとんど変わりません。
しかし、スレッドの生成は、例えばcall/ccによる軽量スレッドよりは
ずっとコストのかかる処理です。
このように、Gaucheのプリエンプティブなスレッドは、
きめ細かい計算のために幾千ものスレッドを生成したいアプリケーション
向けでは@emph{ありません}。
@c COMMON

@c EN
The recommended usage is the technique so called "thread pool",
that you create a set of threads and keep them around for
long time and dispatch jobs to them as needed.
@c JP
推奨される使用方法は、いわゆる``スレッドプール''と呼ばれる
テクニックです。つまり、スレッドの集合を作って長時間それを
保持し、必要になったときにジョブをそこへディスパッチする
というものです。
@c COMMON

@c EN
Preemptive threads have other difficulties
(e.g. see @ref{fairthreads,[FairThreads],FairThreads}),
and sometimes the alternatives may be a better fit
than the native preemptive threads.
@c JP
プリエンプティブなスレッドには他にも難しい点があり
(@ref{fairthreads,[FairThreads],FairThreads}参照)、
しばしばネイティブなプリエンプティブスレッドよりも
より良くフィットする代替策があります。
@c COMMON

@itemize @bullet
@item
@c EN
If what you need is just a concurrent calculation, you
might be able to use cooperative thread technique built
on top of @code{call/cc}.   Creating call/cc-based threads
is much faster than creating native threads.
@c JP
単に同時実行が必要なだけなら、@code{call/cc}による協調スレッド
テクニックが使えるでしょう。call/ccベースのスレッドの生成は、
ネイティブスレッドを生成するよりも高速です。
@c COMMON

@item
@c EN
If what you need is to deal with blocking I/O, and you have
all your code at hand, it is sometimes easier to use good old
@code{select}-based dispatching (@xref{Simple dispatcher},
for example).
@c JP
ブロッキングI/Oを扱う必要があり、全てのコードが手元にある場合は、
古き良き@code{select}ベースのディスパッチ(@ref{Simple dispatcher}に
例があります)を使うほうが簡単なことがあります。
@c COMMON

@item
@c EN
If what you need is to control the resouce consumption in the
subsystem, and the subsystem works fairly independently from
the main system, you may be able to use Unix processes instead of threads.
It may sound to go backward, but Unix process does provide
higher "shield" between the subsystem and the main system
(e.g. the main system can keep running even if subsystem segfaults).
@c JP
サブシステムにおけるリソースの消費をコントロールする必要がある場合で、
サブシステムがメインシステムとほとんど独立に動作する場合は、
スレッドの代わりにUnixプロセスが使えることでしょう。
時代に逆行するように聞こえますが、Unixプロセスはサブシステムと
メインシステムの間に高度な``防御壁''を提供します。
(例えば、サブシステムがセグメンテーション違反を起こしても、
メインシステムは実行しつづけられます。)
@c COMMON

@end itemize

@c EN
Of course, these technique are not mutually exclusive with
native threads.  You can use dispatcher with "thread pool" technique,
for example.   Just keep it in your mind that the native threads
are not only but one of the ways to realize those features.
@c JP
もちろん、これらのテクニックはネイティブスレッドとは相互排他ではありません。
例えば、``スレッドプール''テクニックと一緒にディスパッチャを使うこともできます。
それらの機能を実現するために、ネイティブスレッドが唯一の方法ではないということを
心に留め置いて下さい。
@c COMMON


@node Thread procedures, Synchronization primitives, Thread programming tips, Threads
@subsection Thread procedures
@c NODE スレッド手続き

@deftp {Builtin Class} <thread>
@clindex thread
@c EN
A thread.  Each thread has an associated thunk which is evaluated by
a POSIX thread.  When thunk returns normally, the result is stored
in the internal 'result' slot, and can be retrieved by @code{thread-join!}.
When thunk terminates abnormally, either by raising an exception or
terminated by @code{thread-terminate!}, the exception condition is
stored in their internal 'result exception' slot, and will be passed
to the thread calling @code{thread-join!} on the terminated thread.
@c JP
スレッドを表すクラスです。それぞれのスレッドは、POSIXスレッドにより
評価される関連付けられた手続きを持ちます。手続きが正常に戻ると、
その結果は内部的な``結果''スロットに格納され、@code{thread-join!}により
取得することができます。例外が投げられるか
@code{thread-terminate!}により終了されるかで、手続きが異常終了すると、
例外条件が内部的な``結果としての例外''スロットに格納され、
その例外条件は終了したスレッドに対して@code{thread-join!}を
呼ぶスレッドへと渡されます。
@c COMMON

@c EN
Each thread has its own dynamic environment and dynamic handler stack.
When a thread is created, its dynamic environment is initialized by
the creator's dynamic environment.  The thread's dynamic handler
stack is initially empty.
@c JP
それぞれのスレッドは独自の動的環境と動的なハンドラスタックを持っています。
あるスレッドが生成されると、その動的な環境は生成者の動的な環境によって
初期化されます。そのスレッドの動的なハンドラスタックは初期においては空です。
@c COMMON

@c EN
Access to the resouces shared by multiple threads must be protected
explicitly by synchronization primitives.
@xref{Synchronization primitives}.
@c JP
複数のスレッドで共有されるリソースへのアクセスは、同期化プリミティブにより
明示的に保護されなければなりません。@ref{Synchronization primitives}参照。
@c COMMON

@c EN
Access to ports are serialized by Gauche. If multiple threads attempt
to write to a port, their output may be interleaved but no output
will be lost, and the state of the port is kept consistent.
If multiple threads attempt to read from a port, a single read
primitive (e.g. @code{read}, @code{read-char} or @code{read-line})
works atomically.
@c JP
ポートへのアクセスはGaucheによりシリアライズされます。
複数のスレッドが1つのポートへの書き込みを試みた場合、それらの出力は
混じることもありますが、失われる出力はなく、そのポートのステータスは
一貫性が保たれます。複数のスレッドが1つのポートからの読み込みを試みた
場合、1つの読み込みプリミティブ(例えば、@code{read}や@code{read-char}、
@code{read-line}など)がアトミックに実行されます。
@c COMMON

@c EN
Signal handlers are shared by all threads, but each thread has
its own signal mask.  @xref{Signals and threads}, for details.
@c JP
シグナルハンドラは全てのスレッドで共有されますが、それぞれのスレッドは
独自のシグナルマスクを持ちます。詳細は、@ref{Signals and threads}を参照。
@c COMMON

@c EN
A thread object has the following external slots.
@c JP
スレッドオブジェクトは以下の外部スロットを持ちます。
@c COMMON

@defivar <thread> name
@c EN
A name can be associated to a thread.
This is just for the convenience of the application.
The primordial thread has the name "@code{root}".
@c JP
スレッドに関連付けられる名前。
これは単にアプリケーションにとっての便宜を図るためのものです。
原始となるスレッドは``@code{root}''という名前を持ちます。
@c COMMON
@end defivar

@defivar <thread> specific
@c EN
A thread-local slot for use of the application.
@c JP
アプリケーションが使うスレッドローカルなスロット。
@c COMMON
@end defivar
@end deftp

@defun current-thread
@c EN
[SRFI-18], [SRFI-21]
Returns the current thread.
@c JP
[SRFI-18]、[SRFI-21]
現在のスレッドを返します。
@c COMMON
@end defun

@defun thread? obj
@c EN
[SRFI-18], [SRFI-21]
Returns @code{#t} if @var{obj} is a thread, @code{#f} otherwise.
@c JP
[SRFI-18]、[SRFI-21]
@var{obj}がスレッドなら@code{#t}、そうでなければ@code{#f}を返します。
@c COMMON
@end defun

@defun make-thread thunk &optional name
@c EN
[SRFI-18], [SRFI-21]
Creates and returns a new thread.  To run the thread, you need to
call @code{thread-start!}.
@c JP
[SRFI-18]、[SRFI-21]
新しいスレッドを生成して返します。そのスレッドを実行するためには、
@code{thread-start!}を呼ぶ必要があります。
@c COMMON

@c EN
You can provide the name of the thread by the optional argument @var{name}.
@c JP
オプション引数@var{name}を与えることで、そのスレッドに名前を与えることができます。
@c COMMON

@c EN
Internally, this procedure just allocates and initializes a Scheme
thread object; the POSIX thread is not created until @code{thread-start!}
is called.
@c JP
内部的に、この手続きは単にSchemeスレッドオブジェクトを割り当て初期化している
だけです。POSIXスレッドは@code{thread-start!}が呼ばれるまで生成されません。
@c COMMON
@end defun

@defun thread-name thread
@c EN
[SRFI-18], [SRFI-21]
Returns the value of @var{name} slot of @var{thread}.
@c JP
[SRFI-18]、[SRFI-21]
@var{thread}のスロット@var{name}の値を返します。
@c COMMON
@end defun

@defun thread-specific thread
@defunx thread-specific-set! thread value
@c EN
[SRFI-18], [SRFI-21]
Gets/sets the value of the @var{thread}'s specific slot.
@c JP
[SRFI-18]、[SRFI-21]
@var{thread}のし呈したスレッドの値を取得/設定します。
@c COMMON
@end defun

@defun thread-start! thread
@c EN
[SRFI-18], [SRFI-21]
Starts the @var{thread}.  It is an error if @var{thread} is already started.
Returns @var{thread}.
@c JP
[SRFI-18]、[SRFI-21]
@var{thread}を開始します。@var{thread}がすでに開始されていればエラーになります。
@var{thread}を返します。
@c COMMON
@end defun

@defun thread-yield!
@c EN
[SRFI-18], [SRFI-21]
Suspends the execution of the calling thread and yields CPU to other
waiting runnable threads, if any.
@c JP
[SRFI-18]、[SRFI-21]
呼び出しているスレッドの実行を中断し、他に待機中の実行可能なスレッドがあれば、
CPUにそれを処理させます。
@c COMMON
@end defun

@defun thread-sleep! timeout
@c EN
[SRFI-18], [SRFI-21]
Suspends the calling thread for the period specified by @var{timeout},
which must be either a @code{<time>} object (@xref{Time}) that
specifies absolute point of time, or a real number that specifies
relative point of time from the time this procedure is called
in number of seconds.
@c JP
[SRFI-18]、[SRFI-21]
呼び出しているスレッドを@var{timeout}に指定した時間だけ中断します。
@var{timeout}は絶対的な時間を表す@code{<time>}オブジェクト(@ref{Time}参照)か、
この手続きが呼ばれた時刻からの相対的な秒数を表す実数でなければなりません。
@c COMMON

@c EN
After the specified time passes, @code{thread-sleep!} returns with
unspecified value.
@c JP
指定された時間が経過すると、@code{thread-sleep!}は未定義値を返します。
@c COMMON

@c EN
If @var{timeout} points a past time, @code{thread-sleep!} returns
immediately.
@c JP
@var{timeout}が過去の時間を指していたら、@code{thread-sleep!}はすぐに戻ります。
@c COMMON
@end defun

@defun thread-terminate! thread
@c EN
[SRFI-18], [SRFI-21]
Terminates the specified thread @var{thread}.
The @var{thread} is terminated and an instance of 
@code{<terminated-thread-exception>} is stored in the result exception
field of @var{thread}.
@c JP
[SRFI-18]、[SRFI-21]
指定されたスレッド@var{thread}を終了します。
@var{thread}は終了され、@code{<terminated-thread-exception>}のインスタンスが
@var{thread}の結果例外のフィールドに格納されます。
@c COMMON

@c EN
If @var{thread} is the same as the calling thread, this procedure
won't return.  Otherwise, this procedure returns unspecified value.
@c JP
@var{thread}が呼び出しているスレッドと同じ場合、この手続きは戻りません。
そうでなければ、この手続きは未定義値を返します。
@c COMMON

@c EN
This procedure should be used with care, since
@var{thread} won't have a chance to call cleanup
procedures (such as 'after' thunks of @code{dynamic-wind})
If @var{thread} is in the critical section, it leaves some state
inconsistent.  However, once a thread is terminated, any mutex
that the thread has kept becomes 'abandoned' state, and an attempt
to lock such a mutex by other thread raises an 'abandoned mutex exception',
so that you will know the situation.  @xref{Synchronization primitives}.
@c JP
@var{thread}には(@code{dynamic-wind}での'after'手続きのような)クリーンアップ手続きを
呼ぶチャンスがないので、この手続きは注意して使って下さい。
@var{thread}がクリティカルセクションにあるならば、一貫性のない状態を残すことに
なります。
しかし、あるスレッドが一旦終了すると、そのスレッドが保持していたmutexは
'abandoned'(放棄された)状態になり、そのようなmutexをロックしようとするスレッドは
'abandoned mutex exception'を投げるので、その状況を知ることができます。
@ref{Synchronization primitives}参照。
@c COMMON
@end defun


@defun thread-join! thread &optional timeout timeout-val
@c EN
[SRFI-18], [SRFI-21]
Waits termination of @var{thread}, or until the timeout is reached
if @var{timeout} is given.
@c JP
[SRFI-18]、[SRFI-21]
@var{thread}の終了、あるいは@var{timeout}が与えられていればtimeoutが
それに達するのを待ちます。
@c COMMON

@c EN
@var{Timeout} must be either a @code{<time>} object (@xref{Time})
that specifies absolute point of time, or a real number that specifies
relative point of time from the time this procedure is called
in number of seconds, or @code{#f} that indicates no timeout (default).
@c JP
@var{Timeout}は絶対的な時間を表す@code{<time>}オブジェクト(@ref{Time}参照)か、
この手続きが呼ばれた時刻からの相対的な時間を秒数で表した実数でなければなりません。
タイムアウトが指定されていない(デフォルト)は@code{#f}です。
@c COMMON

@c EN
If @var{thread} terminates normally, @code{thread-join!} returns
a value which is stored in the result field of @var{thread}.
If @var{thread} terminates abnormally, @code{thread-join!} raises
an exception which is stored in the result exception field of @var{thread}.
@c JP
@var{thread}が正常に終了したら、@code{thread-join!}は@var{thread}の
結果フィールとに格納されている値を返します。
@var{thread}が異常終了したら、@code{thread-join!}は@var{thread}の結果例外
フィールドに格納されている例外を投げます。
@c COMMON

@c EN
If the timeout is reached, @var{thread-join!} returns @var{timeout-val}
if given, or raises @code{<join-timeout-exception>}.
@c JP
タイムアウトに達すると、@var{timeout-val}が与えられていれば@var{thread-join!}を返し、
与えられていなければ@code{<join-timeout-exception>}を投げます。
@c COMMON
@end defun

@node Synchronization primitives, Thread exceptions, Thread procedures, Threads
@subsection Synchronization primitives
@c NODE 同期プリミティブ

@deftp {Builtin Class} <mutex>
@clindex mutex
@c EN
A primitive synchronization device.  It can take one of four states:
locked/owned, locked/not-owned, unlocked/abandoned and unlocked/not-abandoned.
A mutex can be locked (by @code{mutex-lock!}) only if it is in unlocked state.
An 'owned' mutex keeps a thread that owns it.
Typically an owner thread is the one that locked the mutex,
but you can make a thread other than the locking thread own a mutex.
A mutex becomes unlocked either by @code{mutex-unlock!} or the owner
thread terminates.  In the former case, a mutex becomes unlocked/not-abandoned
state.  In the latter case, a mutex becomes unlocked/abandoned state.
@c JP
同期のための基本的デバイスです。次の4つの状態のいずれかを持ちます:
locked/owned、locked/not-owned、unlocked/abandoned、unlocked/not-abandoned。
Mutexは、それがunlocked(ロックされていない状態)であるときのみ、
(@code{mutex-lock!}により)ロックされます。
所有されている(owned) mutexは、そのmutexを所有しているスレッドを記憶しています。
通常、所有者となるスレッドはmutexをロックしたスレッドですが、
ロックしたのとは別のスレッドがmutexを所有するようにすることもできます。
ロックは@code{mutex-unlock!}によるか、所有するスレッドが終了すると解放されます。
前者の場合、mutexはunlocked/not-abandoned(ロックされておらず、放棄されていない状態)
になります。
後者の場合、mutexはunlocked/abandoned(ロックされておらず、放棄された状態)になります。
@c COMMON

@c EN
A mutex has the following external slots.
@c JP
Mutexは、以下の外部スロットを持ちます。
@c COMMON

@defivar <mutex> name
@c EN
The name of the mutex.
@c JP
Mutexの名前。
@c COMMON
@end defivar

@defivar <mutex> state
@c EN
The state of the mutex.  This is a read-only slot.
See the descrption of @code{mutex-state} below.
@c JP
Mutexの状態。これは読み取りのみ可能なスロットです。
下記の@code{mutex-state}の説明を参照して下さい。
@c COMMON
@end defivar

@defivar <mutex> specific
@c EN
A slot an application can keep arbitrary data.  For example, an application
can implement a 'recursive' mutex using the specific field.
@c JP
アプリケーションが任意のデータを保持することのできるスロットです。
例えば、アプリケーションはこの固有フィールドで'再帰的な' mutexを
実装することができます。
@c COMMON
@end defivar
@end deftp

@defun mutex? obj
@c EN
[SRFI-18], [SRFI-21]
Returns @code{#t} if @var{obj} is a mutex, @code{#f} otherwise.
@c JP
[SRFI-18]、[SRFI-21]
@var{obj}がmutexであれば@code{#t}、そうでなければ@code{#f}を返します。
@c COMMON
@end defun

@defun make-mutex &optional name
@c EN
[SRFI-18], [SRFI-21]
Creates and returns a new mutex object.
When created, the mutex is in unlocked/not-abandoned state.
Optionally, you can give a name to the mutex.
@c JP
[SRFI-18]、[SRFI-21]
新しいmutexオブジェクトを生成して返します。
生成時には、mutexの状態は、unlocked/not-abandoned(ロックされておらず、
放棄されていない状態)です。オプションで、このmutexに名前を付けることができます。
@c COMMON
@end defun

@defun mutex-name mutex
@c EN
[SRFI-18], [SRFI-21]
Returns the name of the mutex.
@c JP
[SRFI-18]、[SRFI-21]
Mutexの名前を返します。
@c COMMON
@end defun

@defun mutex-specific mutex
@defunx mutex-specific-set! mutex value
@c EN
[SRFI-18], [SRFI-21]
Gets/sets the specific value of the mutex.
@c JP
[SRFI-18]、[SRFI-21]
Mutexの固有の値を取得/セットできます。
@c COMMON
@end defun

@defun mutex-state mutex
@c EN
[SRFI-18], [SRFI-21]
Returns the state of @var{mutex}, which may be one of the followings:
@c JP
[SRFI-18]、[SRFI-21]
@var{mutex}の状態を返します。状態は以下のうちの1つです。
@c COMMON

@table @asis
@c EN
@item a thread
The mutex is locked/owned, and the owner is the returned thread.
@item symbol @code{not-owned}
The mutex is locked/not-owned.
@item symbol @code{abandoned}
The mutex is unlocked/abandoned.
@item symbol @code{not-abandoned}
The mutex is unlocked/not-abandoned.
@c JP
@item あるスレッド
Mutexはlocked/owned(ロックされ所有されている)で、所有者は返されたスレッド。
@item シンボル @code{not-owned}
Mutexはlocked/not-owned(ロックされているが所有されていない)。
@item シンボル @code{abandoned}
Mutexはunlocked/abandoned(ロックされておらず、放棄されている)。
@item シンボル @code{not-abandoned}
Mutexはunlocked/not-abandoned(ロックされておらず、放棄されていない)。
@c COMMON
@end table
@end defun

@defun mutex-lock! mutex &optional timeout thread
@c EN
[SRFI-18], [SRFI-21]
Locks @var{mutex}.  If @var{mutex} is in unlocked/not-abandoned
state, this procedure changes its state to locked state exclusively.
By default, @var{mutex} becomes locked/owned state, owned by the
calling thread.  You can give other owner thread as @var{thread} argument.
If @var{thread} argument is given and @code{#f}, the mutex becomes
locked/not-owned state.
@c JP
[SRFI-18]、[SRFI-21]
@var{mutex}をロックします。@var{mutex}がunlocked/not-abandoned(
ロックされておらず放棄されていない状態)なら、
この手続きはその状態を排他的なlocked(ロックされた状態)に変更します。
デフォルトでは、@var{mutex}はlocked/owned(ロックされ、所有された状態)になり、
所有者は呼び出したスレッドです。
他の所有しているスレッドを、引数@var{thread}を与えることもできます。
引数@var{thread}に@code{#f}が与えられると、mutexはlocked/not-owned
(ロックされ所有されていない状態)になります。
@c COMMON

@c EN
If @var{mutex} is in unlocked/abandoned state, that is, some other
thread has been terminated without unlocking it, this procedure
signals 'abandoned mutex exception' (@xref{Thread exceptions})
after changing the state of @var{mutex}.
@c JP
@var{mutex}がunlocked/abandoned(ロックされておらず放棄された状態)ならば、それはつまり、
他の何らかのスレッドがそのロックを解放せずに終了した場合、
この手続きは@var{mutex}の状態を変更した後に、'abandoned mutex exception'
(@ref{Thread exceptions}参照)を通知します。
@c COMMON

@c EN
If @var{mutex} is in locked state and
@var{timeout} is omitted or @code{#f}, this procedure blocks until
@var{mutex} becomes unlocked.   If @var{timeout} is specified,
@code{mutex-lock!} returns when the specified time reaches in
case it couldn't obtain a lock.  You can give @var{timeout}
an absolute point of time (by @code{<time>} object, @xref{Time}),
or a relative time (by a real number).
@c JP
@var{mutex}がlocked(ロックされた状態)で、@var{timeout}が省略されるか@code{#f}ならば、
この手続きは@var{mutex}のロックが解放されるまでブロックします。
@var{timeout}が指定されている場合は、ロックが獲得できなかったケースでは
指定された時間に達した時に@code{mutex-lock!}は戻ります。
@var{timeout}には、絶対的な時間(@code{<time>}オブジェクト、@ref{Time}参照)か、
相対的な時間を(実数で)指定できます。
@c COMMON

@c EN
@code{Mutex-lock!} returns @code{#t} if @var{mutex} is successfully
locked, or @code{#f} if timeout reached.
@c JP
@var{mutex}のロックが成功すると@code{mutex-lock!}は@code{#t}を返し、
タイムアウトに達すると@code{#f}が返ります。
@c COMMON

@c EN
Note that @var{mutex} itself doesn't implements a 'recursive lock'
feature; that is, if a thread that has locked @var{mutex} tries to lock
@var{mutex} again, the thread blocks.  It is not difficult, however,
to implement a recursive lock semantics on top of this mutex.
The following example is taken from SRFI-18 document:
@c JP
@var{mutex}それ自身は'再帰的なロック'の機能は実装していません。
つまり、@var{mutex}をロックしたスレッドが再度@var{mutex}をロックしようと
すると、そのスレッドはブロックします。しかし、このmutexに
基づいて再帰的なロックをセマンティクスを実装することは難しくありません。
次の例は、SRFI-18のドキュメントから引用したものです。
@c COMMON

@example
(define (mutex-lock-recursively! mutex)
  (if (eq? (mutex-state mutex) (current-thread))
      (let ((n (mutex-specific mutex)))
        (mutex-specific-set! mutex (+ n 1)))
      (begin
        (mutex-lock! mutex)
        (mutex-specific-set! mutex 0))))

(define (mutex-unlock-recursively! mutex)
  (let ((n (mutex-specific mutex)))
    (if (= n 0)
        (mutex-unlock! mutex)
        (mutex-specific-set! mutex (- n 1)))))
@end example
@end defun

@defun mutex-unlock! mutex &optional condition-variable timeout
@c EN
[SRFI-18], [SRFI-21]
Unlocks @var{mutex}.  The state of @var{mutex} becomes unlocked/not-abandoned.
It is allowed to unlock a mutex that is not owned by the calling thread.
@c JP
[SRFI-18]、[SRFI-21]
@var{mutex}をアンロックします。@var{mutex}の状態は、unlocked/not-abandoned
(ロックされておらず、放棄されていない状態)となります。
呼び出しているスレッドにより所有されていないmutexをアンロックすることは
許されています。
@c COMMON

@c EN
If optional @var{condition-variable} is given, @code{mutex-unlock!}
serves the "condition variable wait" operation (e.g. @code{pthread_cond_wait}
in POSIX threads).   The current thread atomically wait on
@var{condition-variable} and unlocks @var{mutex}.
The thread will be unblocked when other thread signals on
@var{condition-variable} (see @code{condition-variable-signal!}
and @code{condition-variable-broadcast!} below), or @var{timeout}
reaches if it is supplied.  The @var{timeout} argument can be either
a @code{<time>} object to represent an absolute time point (@xref{Time}),
a real number to represent a relative time in seconds, or @code{#f} which
means never.  The calling thread may be unblocked prematurely,
so it should reacquire the lock of @var{mutex} and checks the
condition, as in the follwing example (it is taken from SRFI-18 document):
@c JP
オプショナル引数の@var{conditional-variable}が与えられている場合、
@code{mutex-unlock!}は``条件変数待機''の動作も行います(例えば、POSIXスレッドの
@code{pthread_cond_wait})。
現在のスレッドは@var{mutex}をアンロックし、
@var{condition-variable}の待ち状態に入る動作をアトミックに行います。
スレッドは、他のスレッドが@var{condition-variable}にシグナルを通知するか
(下記の@code{condition-variable-signal!}と@code{condition-variable-broadcast!}を
見て下さい)、
@var{timeout}が与えられていてそれに達すると、ブロックが解除されます。
引数@var{timeout}は、絶対的な時間を表す@code{<time>}オブジェクト(@ref{Time}参照)、
相対的な時間を秒数で表す実数、タイムアウトしないことを表す@code{#f}のいずれかです。
ブロックが解除された時に、必ずしも条件が満たされているとは限らないので、
次に挙げる例(SRFI-18のドキュメントより引用)のように、
呼び出したスレッドは@var{mutex}のロックを再獲得して条件を検査するべきです。
@c COMMON

@example
(let loop ()
  (mutex-lock! m)
  (if (condition-is-true?)
      (begin
        (do-something-when-condition-is-true)
        (mutex-unlock! m))
      (begin
        (mutex-unlock! m cv)
        (loop))))
@end example
@end defun

@defun with-locking-mutex mutex thunk
@c EN
Calls @var{thunk} with locking a mutex @var{mutex}.  This is defined as
follows.
@c JP
@var{mutex}をロックして@var{thunk}を呼びます。次のように実装されています。
@c COMMON
@example
(define (with-locking-mutex mutex thunk)
  (dynamic-wind
   (lambda () (mutex-lock! mutex))
   thunk
   (lambda () (mutex-unlock! mutex))))
@end example
@end defun

@deftp {Builtin Class} <condition-variable>
@clindex condition-variable
@c EN
A condition variable keeps a set of threads that are waiting for
a certain condition to be true.  When a thread modifies the state 
of the concerned condition, it can call @code{condition-variable-signal!}
or @code{condition-variable-broadcast!}, which unblock one or more
waiting threads so that they can check if the condition is satisfied.
@c JP
条件変数は、ある条件が真になるのを待っているスレッドの集合を保持します。
あるスレッドがその条件を変更する時、@code{condition-variable-signal!}あるいは
@code{condition-variable-broadcast!}が呼ばれ、それは1つ以上の待機中の
スレッドのブロックを解除するため、それらのスレッドは条件が満足するかどうか
検査できます。
@c COMMON

@c EN
A condition variable object has the following slots.
@c JP
条件変数オブジェクトは以下のスロットを持ちます。
@c COMMON

@defivar <mutex> name
@c EN
The name of the condition variable.
@c JP
条件変数の名前。
@c COMMON
@end defivar

@defivar <mutex> specific
@c EN
A slot an application can keep arbitrary data.
@c JP
アプリケーションが任意のデータを保持できるスロット。
@c COMMON
@end defivar

@c EN
Note that SRFI-18 doesn't have a routine equivalent to pthreads'
@code{pthread_cont_wait}.  If you want to wait on condition variable,
you can pass a condition variable to @code{mutex-unlock!} as an
optional argument (see above), then acquire mutex again by
@code{mutex-lock!}.  This design is for flexibility; see 
SRFI-18 document for the details.
@c JP
SRFI-18は、pthreadの@code{pthread_cond_wait}に相当する手続きを
持たないことに注意してください。条件変数を待つのは、
@code{mutex-unlock!}の省略可能引数に条件変数を渡し、
その後mutexを再び@code{mutex-lock!}で得ることで行います。
この設計は柔軟性のためです。詳しくはSRFI-18を参照して下さい。
@c COMMON

@c EN
This is the common usage of pthreads' condition variable:
@c JP
このような、pthreadで条件変数を使う定石は：
@c COMMON
@example
while (some_condition != TRUE) @{
  pthread_cond_wait(condition_variable, mutex);
@}
@end example
@c EN
And it can be translated to SRFI-18 as follows:
@c JP
SRFI-18では次のようなコードになります。
@c COMMON
@example
(let loop ()
  (unless some-condition
    (mutex-unlock! mutex condition-variable)
    (mutex-lock! mutex)
    (loop)))
@end example
@end deftp

@defun condition-variable? obj
@c EN
[SRFI-18], [SRFI-21]
Returns @code{#t} if @var{obj} is a condition variable,
@code{#f} otherwise.
@c JP
[SRFI-18]、[SRFI-21]
@var{obj}が条件変数なら@code{#t}、そうでなければ@code{#f}を返します。
@c COMMON
@end defun

@defun make-condition-variable &optional name
@c EN
[SRFI-18], [SRFI-21]
Returns a new condition variable.  You can give its name by
optional @var{name} argument.
@c JP
[SRFI-18]、[SRFI-21]
新しい条件変数を返します。オプショナル引数@var{name}で
その名前を与えることができます。
@c COMMON
@end defun

@defun condition-variable-name cv
@c EN
[SRFI-18], [SRFI-21]
Returns the name of the condition variable.
@c JP
[SRFI-18]、[SRFI-21]
条件変数の名前を返します。
@c COMMON
@end defun

@defun condition-variable-specific cv
@defunx condition-variable-specific-set! cv value
@c EN
[SRFI-18], [SRFI-21]
Gets/sets the specific value of the condition variable.
@c JP
[SRFI-18]、[SRFI-21]
条件変数の固有の値を取得/セットします。
@c COMMON
@end defun

@defun condition-variable-signal! cv
@c EN
[SRFI-18], [SRFI-21]
If there are threads waiting on @var{cv}, causes the scheduler to select
one of them and to make it runnable.
@c JP
[SRFI-18]、[SRFI-21]
@var{cv}で待機しているスレッドがある場合は、それらのうちの1つがスケジューラに
より選択され、実行可能にされます。
@c COMMON
@end defun

@defun condition-variable-broadcast! cv
@c EN
[SRFI-18], [SRFI-21]
Unblocks all the threads waiting on @var{cv}.
@c JP
[SRFI-18]、[SRFI-21]
@var{cv}で待機している全てのスレッドのブロックを解除します。
@c COMMON
@end defun

@node Thread exceptions,  , Synchronization primitives, Threads
@subsection Thread exceptions
@c NODE スレッド例外

@c EN
Some types of exceptions may be thrown from thread-related procedures.
These exceptions can be handled by Gauche's exception mechanism
(@xref{Exceptions}).
@c JP
例外のいくつかのタイプは、スレッド関連の手続きから投げられます。
これらの例外は、Gaucheの例外メカニズム(@ref{Exceptions}参照)により
扱われます。
@c COMMON

@deftp {Builtin Class} <thread-exception>
@clindex thread-exception
@c EN
A base class of thread-related exceptions.  Inherits @code{<exception>} class.
It has one slot.
@c JP
スレッド関連の例外の基底クラスです。@code{<exception>}クラスを継承しています。
スロットを1つ持っています。
@c COMMON

@defivar <thread-exception> thread
@c EN
A thread that threw this exception.
@c JP
この例外を投げたスレッド。
@c COMMON
@end defivar
@end deftp

@deftp {Builtin Class} <join-timeout-exception>
@clindex join-timeout-exception
@c EN
An exception thrown by @code{thread-join!} when a timeout reaches
before the waited thread returns.  Inherits @code{<thread-exception>}.
@c JP
待機していたスレッドが戻る前にタイムアウトに達した時に@code{thread-join!}によって
投げられる例外。@code{<thread-exception>}を継承しています。
@c COMMON
@end deftp

@deftp {Builtin Class} <abandoned-mutex-exception>
@clindex abandoned-mutex-exception
@c EN
An exception thrown by @code{mutex-lock!} when a @var{mutex} to be
locked is in unlocked/abandoned state.  Inherits @code{<thread-exception>}.
It has one additional slot.
@c JP
ロックされる@var{mutex}が、unlocked/abandoned(ロックされておらず、放棄された状態)
であるときに@code{mutex-lock!}により投げられる例外。
@code{<thread-exception>}を継承しています。スロットを1つ持ちます。
@c COMMON

@defivar <abandoned-mutex-exception> mutex
@c EN
A mutex that caused this exception.
@c JP
この例外の原因となったmutex。
@c COMMON
@end defivar
@end deftp

@deftp {Builtin Class} <terminated-thread-exception>
@clindex terminated-thread-exception
@c EN
An exception thrown by @code{thread-join!} when the waited thread
is terminated abnormally (by @code{thread-terminate!}).
Inherits @code{<thread-exception>}.  It has one additional slot.
@c JP
待機していたスレッドが(@code{thread-terminate!}により)異常終了した
場合に(@code{thread-join!}により)投げられる例外。
@code{<thread-exception>}を継承し、スロットを1つ持ちます。
@c COMMON

@defivar <terminated-thread-exception> terminator
@c EN
A thread that terminated the thread that causes this exception.
@c JP
この例外の原因となったスレッドを終了したスレッド。
@c COMMON
@end defivar
@end deftp

@deftp {Builtin Class} <uncaught-exception>
@clindex uncaught-exception
@c EN
An exception thrown by @code{thread-join!} when the waited thread
is terminated by an uncaught exception.
Inherits @code{<thread-exception>}.  It has one additional slot.
@c JP
待機していたスレッドが捕捉されない例外により終了された場合に
@code{thread-join!}により投げられる例外。
@code{<thread-exception>}を継承し、スロットを1つ持ちます。
@c COMMON

@defivar <uncaught-exception> reason
@c EN
An exception that caused the termination of the thread.
@c JP
そのスレッドの終了の原因となった例外。
@c COMMON
@end defivar
@end deftp

@defun join-timeout-exception? obj
@defunx abandoned-mutex-exception? obj
@defunx terminated-thread-exception? obj
@defunx uncaught-exception? obj
@c EN
[SRFI-18], [SRFI-21]
These procedures checks if @var{obj} is a certain type of exception.
Provided for the compatibility to SRFI-18.
@c JP
[SRFI-18]、[SRFI-21]
これらの手続きは、@var{obj}が特定のタイプの例外かどうかを検査します。
SRFI-18との互換性のために提供されています。
@c COMMON
@end defun

@defun uncaught-exception-reason exc
@c EN
[SRFI-18], [SRFI-21]
Returns the value of @code{reason} slot of @code{<uncaught-exception>}
object.
Provided for the compatibility to SRFI-18.
@c JP
[SRFI-18]、[SRFI-21]
@code{<uncaught-exception>}オブジェクトの@code{reason}スロットの値を
返します。
SRFI-18との互換性のために提供されています。
@c COMMON
@end defun


@c ----------------------------------------------------------------------
@node Measure timings, Uniform vectors, Threads, Library modules - Gauche extensions
@section @code{gauche.time} - Measure timings
@c NODE 時間の計測, @code{gauche.time} - 時間の計測

@deftp {Module} gauche.time
@mdindex gauche.time
@c EN
Provides two simple ways to measure execution time of Scheme code.
A macro @code{time}, which is convenient for interactive use,
and @code{<time-counter>} objects which are useful to be embedded
in the program.
@c JP
Schemeコードの実行時間を測る2つの単純な方法を提供します。
インタラクティブな使用に便利な@code{time}マクロ及び、
プログラム中に埋め込んで使える@code{<time-counter>}オブジェクトです。
@c COMMON
@end deftp

@defmac time expr expr2 @dots{}
@c EN
Evaluates @var{expr} @var{expr2} @dots{} sequentially, as @code{begin},
and returns the result(s) of the last expression.
Before returning the value(s), the macro reports the elapsed (real) time
and CPU times in the user space and the kernel space to the current
error port, much like the bourne shell's time command.
@c JP
式@var{expr} @var{expr2} @dots{} を順に評価し、最後の式の結果を返します。
結果が返される前に、全ての式の評価にかかった実(経過)時間および
ユーザースペース、カーネルスペースで費されたCPU時間がカレントエラーポートに
報告されます。
@c COMMON

@c EN
The current version uses @code{sys-gettimeofday} (@xref{Time}) to
calculate the elapsed time, and @code{sys-times} (@xref{System Inquiry})
to calculate user and system CPU times.  So the resolution of these numbers
depends on these underlying system calls.  Usually the CPU
time has 10ms resolution, while the elapsed time might have higher
resolution.  On the systems that doesn't have gettimeofday(2) support,
however, the elapsed time resolution can be as bad as a second.
@c JP
現在の実装は、経過時間に対しては@code{sys-gettimeofday}
(@ref{Time}参照)を、CPU時間に対しては@code{sys-times}
(@ref{System Inquiry}参照)を用いています。従って、
それぞれの数値の分解能はこれらの手続きが用いているシステムコールに依存します。
CPU時間は10ms単位で、経過時間はそれより細かいことが多いです。
但しgettimeofday(2)コールをサポートしていないOSでは経過時間が最悪の場合
秒単位になります。
@c COMMON

@example
gosh> (time (length (sort (call-with-input-file "/usr/share/dict/words" port->string-list))))
;(time (length (sort (call-with-input-file "/usr/share/dict/words" port- ...
; real   0.357
; user   0.350
; sys    0.000
45427
@end example
@end defmac

@deftp {Class} <time-counter>
@clindex time-counter
@c EN
An abstract class of time counters.  Time counter is a kind of timer
whose value is incremented as the time passes.  The counting
can be started and stopped any number of times.
The value of the counter can be read
when the timer is stopping.
You can have multiple time counters.  It is useful, for example,
to measure the time in two parts inside a loop independently.
@c JP
時間カウンタの抽象クラスです。時間カウンタは
時間の経過と共にその値が増加してゆく一種のタイマーです。
何度でもカウントを止めたり開始したりできます。
カウンタの値はカウントが止まっている時に読み出すことができます。
複数の時間カウンタを使えば、
例えばループ中の二つの部分について費される時間を別々に計測することもできます。
@c COMMON

@c EN
The concrete subclass determines which time it is counting.
You have to instantiate one of those subclasses described below
to use the time counter.
@c JP
具体的なサブクラスが、どの時間をカウントするかを決定します。
時間カウンタを使うには、下に挙げるサブクラスのいずれかを
インスタンシエイトしなければなりません。
@c COMMON
@end deftp

@deftp {Class} <real-time-counter>
@deftpx {Class} <user-time-counter>
@deftpx {Class} <system-time-counter>
@deftpx {Class} <process-time-counter>
@clindex real-time-counter
@clindex user-time-counter
@clindex system-time-counter
@clindex process-time-counter
@c EN
Classes for time counters that count real (elapsed) time, user-space CPU time,
kernel-space CPU time, and total CPU time (user + system), respectively.
@c JP
それぞれ、実経過時間、ユーザースペースCPU時間、カーネルスペースCPU時間、
総CPU時間 (ユーザー+カーネル)を計測する時間カウンタのクラスです。
@c COMMON
@end deftp

@deffn {Method} time-counter-start! (counter <time-counter>)
@deffnx {Method} time-counter-stop! (counter <time-counter>)
@c EN
Starts and stops the @var{counter}.  The time during the counter is
running is accumulated to the counter value when the counter is stopped.
@c JP
時間カウンタ@var{counter}を開始/停止します。カウンタが走っている間の時間が、
カウンタが停止した時点でカウンタの値に加算されます。
@c COMMON

@c EN
Start/stop pairs can be nested,
but only the outermost pair takes the effect.  That is, if you call
@code{time-counter-start!} on the counter that is already started,
it doesn't have any effect except that to stop such a counter
you have to call @code{time-counter-stop!} one more time.  It is useful
when you want to measure the time spent in the larger block that
may already contain timer start/stop pairs.
@c JP
開始/停止の対はネストすることができます。その場合は、一番外側の対のみが
有効です。
つまり、既に走っているカウンタに対し@code{time-counter-start!}を呼んでも
何も起こりませんが、一度余分に@code{time-counter-stop!}を呼ばないと
カウンタは止まりません。
これは、内部に既に開始/停止の対を含んでいるかもしれない大きなコードブロックの
全体の時間を計測したいというような場合に便利です。
@c COMMON

@c EN
Calling @code{time-counter-stop!} on the already stopped counter
has no effect.
@c JP
既に停止しているカウンタに対して@code{time-counter-stop!}を呼んでも
何も起こりません。
@c COMMON
@end deffn

@deffn {Method} time-counter-reset! (counter <time-counter>)
@c EN
Resets the value of @var{counter}.  If @var{counter} is already
running, it is forced to stop before being reset.
@c JP
カウンタ@var{counter}の値をリセットします。既に@var{counter}が走っている
場合は、リセットの前にカウンタは停止させられます。
@c COMMON
@end deffn

@deffn {Method} time-counter-value (counter <time-counter>)
@c EN
Returns the current value of the counter as the number of seconds,
in a real number.  The resolution depends on the source of the counter.
@c JP
カウンタ@var{counter}の現在の値(秒数)を実数で返します。
分解能はそれぞれのカウンタが用いているシステムコールに依存します。
@c COMMON
@end deffn

@defmac with-time-counter counter expr @dots{}
@c EN
A convenience macro to run the @var{counter} while @var{expr} @dots{}
are evaluated.  Returns the result(s) of the last expression.
It is defined as follows.
@c JP
式@var{expr} @dots{}が評価される間だけ@var{counter}を走らせる、
便利なマクロです。最後の式の結果を返します。このマクロは次のように
定義されます。
@c COMMON
@example
(define-syntax with-time-counter
  (syntax-rules ()
    ((_ counter . exprs)
     (dynamic-wind
      (lambda () (time-counter-start! counter))
      (lambda () . exprs)
      (lambda () (time-counter-stop! counter))))
    ))
@end example
@end defmac

@c EN
The following example measures approximate times
spend in process-A and process-B inside a loop.
@c JP
下の例では、ループ内でのprocess-Aとprocess-Bにて費された
概略の時間をそれぞれ計測します。
@c COMMON

@example
(let ((ta (make <real-time-counter>))
      (tb (make <real-time-counter>)))
  (dotimes (i 100000)
    (with-time-counter ta
      (process-A))
    (with-time-counter tb
      (process-B)))
  (format #t "Time spent in process-A: ~s\n" (time-counter-value ta))
  (format #t "Time spent in process-B: ~s\n" (time-counter-value tb))
  )
@end example


@c ----------------------------------------------------------------------
@node Uniform vectors, Comparing version numbers, Measure timings, Library modules - Gauche extensions
@section @code{gauche.uvector} - Uniform vectors
@c NODE ユニフォームベクタ, @code{gauche.uvector} - ユニフォームベクタ

@deftp {Module} gauche.uvector
@mdindex gauche.uvector
@c EN
Provides vectors whose elements are of the same numeric type,
as defined in SRFI-4 (@ref{srfi-4,,SRFI-4}).

Gauche's implementation is a superset of SRFI-4 in a few ways:
@itemize @bullet
@item
Some routines takes optional parameters: @code{@var{TAG}vector->list}
takes optional start and end indices, and @code{@var{TAG}vector-ref}
takes optional fallback value.
@item
Additional functions: copy procedures (@code{@var{TAG}vector-copy} and
@code{@var{TAG}vector-copy!}), conversion procedures
(@code{@var{TAG}vector->vector} and @code{vector->@var{TAG}vector}),
and some arithmetic functions (@code{@var{TAG}vector-add}, etc.)
@item
Implements the collection framework (@xref{Collection framework})
and the sequence framework (@xref{Sequence framework}).  So the
methods like @code{map}, @code{for-each}, @code{ref} or @code{subseq}
can be used on the SRFI-4 vector types.
@end itemize
@c JP
SRFI-4(@ref{srfi-4,,SRFI-4})に定義されている、
要素が同一の数値型であるようなベクタを提供します。

Gaucheの実装は、SRFI-4の仕様を次のように拡張しています。
@itemize @bullet
@item
いくつかの手続きはSRFI-4に無い省略可能な引数を取ります。
@code{@var{TAG}vector->list}は省略可能なstartとendのインデックスを取り、
@code{@var{TAG}vector-ref}は省略可能なデフォルト値を取ります。
@item
追加の手続き： コピー(@code{@var{TAG}vector-copy},
@code{@var{TAG}vector-copy!})、
変換 (@code{@var{TAG}vector->vector}, @code{vector->@var{TAG}vector})、
及び各種算術演算(@code{@var{TAG}vector-add}等)。
@item
コレクションフレームワーク (@ref{Collection framework}参照)と
シーケンスフレームワーク (@ref{Sequence framework}参照)の実装。
例えば @code{map}, @code{for-each}, @code{ref}, @code{subseq}等の
メソッドがSRFI-4ベクタに対して使えます。
@end itemize
@c COMMON

@c EN
There are some advantages of using SRFI-4 vectors over normal
(heterogeneous) vectors.  It may be more compact than the normal
vectors.  Some operations (especially Gauche's extension of vector
arithmetic operations) can bypass type check and conversion of
individual elements, thus be more efficient.  And it is much easier
and efficient to communicate with external libraries that require
homogeneous array of numbers; for example, OpenGL binding of Gauche
uses SRFI-4 vectors extensively.
@c JP
通常のベクタではなくSRFI-4ベクタを使うことにより得られる利点がいくつかあります。
まず、SRFI-4ベクタは通常のベクタよりもコンパクトです。
いくつかのオペレーション(特に、Gaucheの拡張仕様であるベクタ上の数値演算)では、
型検査と型変換を個々の要素に対して行わなくても良いため、
極めて効率の良い演算が可能です。さらに、
数値の配列を扱う外部のライブラリとのインタフェースが容易です。
例えば、GaucheのOpenGLバインディングではSRFI-4ベクタを多用しています。
@c COMMON
@end deftp
@c EN
The following ten types of vectors are defined.
@table @emph
@item s8vector
Elements are exact integers in the range between -2^7 and 2^7-1
@item u8vector
Elements are exact integers in the range between 0 and 2^8-1
@item s16vector
Elements are exact integers in the range between -2^15 and 2^15-1
@item u16vector
Elements are exact integers in the range between 0 and 2^16-1
@item s32vector
Elements are exact integers in the range between -2^31 and 2^31-1
@item u32vector
Elements are exact integers in the range between 0 and 2^32-1
@item s64vector
Elements are exact integers in the range between -2^63 and 2^63-1
@item u64vector
Elements are exact integers in the range between 0 and 2^64-1
@item f32vector
Elements are inexact real numbers representable in the @code{float} of
C compiler that compiles Gauche.  Usually it is a single precision
IEEE floating point number.
@item f64vector
Elements are inexact real numbers representable in the @code{double} of
C compiler that compiles Gauche.  Usually it is a double precision
IEEE floating point number.
@end table
@c JP
以下の10タイプのベクタが定義されます。
@table @emph
@item s8vector
要素が -2^7 から 2^7-1 の間の正確な整数であるベクタ
@item u8vector
要素が 0 から 2^8-1 の間の正確な整数であるベクタ
@item s16vector
要素が -2^15 から 2^15-1 の間の正確な整数であるベクタ
@item u16vector
要素が 0 から 2^16-1 の間の正確な整数であるベクタ
@item s32vector
要素が -2^31 から 2^31-1 の間の正確な整数であるベクタ
@item u32vector
要素が 0 から 2^32-1 の間の正確な整数であるベクタ
@item s64vector
要素が -2^63 から 2^63-1 の間の正確な整数であるベクタ
@item u64vector
要素が 0 から 2^64-1 の間の正確な整数であるベクタ
@item f32vector
要素が、GaucheをコンパイルしたCコンパイラの@code{float}で表現し得るような
不正確な実数(通常IEEE単精度浮動少数点数)であるベクタ
@item f64vector
要素が、GaucheをコンパイルしたCコンパイラの@code{double}で表現し得るような
不正確な実数(通常IEEE倍精度浮動少数点数)であるベクタ
@end table
@c COMMON

@c EN
When you try to store a number out of the range of the vector type,
an error is signalled by default.  However, some procedures take
an optional argument @var{clamp} that specifies alternative behavior
in such a case.  @var{Clamp} argument may take one of the following values.
@c JP
ベクタの型が許す範囲外の値を格納しようとした場合、通常はエラーとなります。
いくつかの手続きは省略可能な引数@var{clamp}によって、
そのような場合に別のふるまいを指定することができます。
@var{clamp}には以下のいずれかの値を与えることが出来ます。
@c COMMON
@table @code
@item #f
@c EN
Default behavior (signals an error).
@c JP
デフォルト (エラーを通知)
@c COMMON
@item high
@c EN
Clamps high bound; i.e. if the value to be stored is beyond the higher bound
of the range, the maximum value is stored instead.
@c JP
高い方の値をクランプ、すなわち、格納しようとする値が許される値の最大値より大きかった
場合は、可能な最大値を代わりに格納します。
@c COMMON
@item low
@c EN
Clamps low bound; i.e. if the value to be stored is below the lower bound
of the range, the minimum value is stored instead.
@c JP
低い方の値をクランプ、すなわち、格納しようとする値が許される値の最小値より大きかった
場合は、可能な最小値を代わりに格納します。
@c COMMON
@item both
@c EN
Clamps both sides; does both @code{high} and @code{low}.
@c JP
高いほうと低いほうの両方の値をクランプします。
@c COMMON
@end table

@example
(list->u8vector '(-1))         @result{} @r{error}
(list->u8vector '(-1) 'low)    @result{} #u8(0)
(list->u8vector '(-1) 'high)   @result{} @r{error}
(list->u8vector '(3000) 'high) @result{} #u8(255)
(list->u8vector '(-100 20 300) 'both) @result{} #u8(0 20 255)
@end example

@c EN
In the following description, @code{@var{TAG}} can be replaced
for any of @code{s8}, @code{u8}, @code{s16}, @code{u16}, 
@code{s32}, @code{u32}, @code{s64}, @code{u64}, @code{f32}, @code{f64}.
@c JP
以下の記述では、@code{@var{TAG}}は
@code{s8}, @code{u8}, @code{s16}, @code{u16}, 
@code{s32}, @code{u32}, @code{s64}, @code{u64}, @code{f32}, @code{f64}
のいずれにも置き換えて読むことができるものとします。
@c COMMON

@menu
* Uvector basic operations::    
* Uvector conversion operations::  
* Uvector numeric operations::  
* Uvector block I/O::           
@end menu

@node Uvector basic operations, Uvector conversion operations, Uniform vectors, Uniform vectors
@subsection Uvector basic operations
@c NODE ユニフォームベクタの基本操作

@deftp {Builtin Class} <@var{TAG}vector>
@clindex s8vector
@clindex u8vector
@clindex s16vector
@clindex u16vector
@clindex s32vector
@clindex u32vector
@clindex s64vector
@clindex u64vector
@clindex f32vector
@clindex f64vector
@c EN
A class for @var{TAG}vector.  It inherits @code{<sequence>}.
@c JP
@var{TAG}vectorのクラス。@code{<sequence>}を継承します。
@c COMMON
@end deftp

@deftp {Reader Syntax} @code{#@var{TAG}(@var{n} @dots{})}
@c EN
Denotes a literal homogeneous vector.
@c JP
リテラルの単一型のベクタを記述します。
@c COMMON
@example
#s8(3 -2 4)
#u32(4154 88357 2 323)
#f32(3.14 0.554525 -3.342)
@end example
@end deftp

@deftp {Function} {@var{TAG}vector?} @r{@var{obj}}
@findex s8vector?
@findex u8vector?
@findex s16vector?
@findex u16vector?
@findex s32vector?
@findex u32vector?
@findex s64vector?
@findex u64vector?
@findex f32vector?
@findex f64vector?
[SRFI-4]
@c EN
Returns @code{#t} if @var{obj} is a @var{TAG}vector, @code{#f} otherwise.
@c JP
@var{obj}が@var{TAG}vectorなら@code{#t}を、そうでなければ@code{#f}を返します。
@c COMMON
@end deftp

@deftp {Function} {@var{TAG}vector} @r{@var{x} @dots{}}
@findex s8vector 
@findex u8vector
@findex s16vector
@findex u16vector
@findex s32vector
@findex u32vector
@findex s64vector
@findex u64vector
@findex f32vector
@findex f64vector
[SRFI-4]
@c EN
Constructs @var{TAG}vector whose elements are numbers @var{x} @dots{}.
The numbers must be exact integer for exact integer vectors, 
and in the valid range of the vector.
@c JP
数値@var{x} @dots{} を要素に持つ@var{TAG}vectorを作成して返します。
正確な整数のベクタに対しては、数値は正確な整数でなければならず、
また有効な範囲内の値でなければなりません。
@c COMMON
@example
(s8vector 1 2 3) @result{} #s8(1 2 3)
@end example
@end deftp

@deftp {Function} make-@var{TAG}vector @r{@var{len} @var{&optional} @var{fill}}
@findex make-s8vector
@findex make-u8vector
@findex make-s16vector
@findex make-u16vector
@findex make-s32vector
@findex make-u32vector
@findex make-s64vector
@findex make-u64vector
@findex make-f32vector
@findex make-f64vector
[SRFI-4]
@c EN
Constructs a @var{TAG}vector of length @var{len}.  The elements are
initialized by a number @var{fill}.   For exact integer vectors,
@var{fill} must be an exact integer and in the valid range.
If @var{fill} is omitted, the content of the vector is undefined.
@c JP
長さ@var{len}の@var{TAG}vectorを作成して返します。各要素は@var{fill}で
初期化されます。正確な整数のベクタに対しては、@var{fill}は正確な整数でなければならず、
また有効な範囲内の値でなければなりません。
@var{fill}が省略された場合、各要素の初期値は不定です。
@c COMMON
@example
(make-u8vector 4 0) @result{} #u8(0 0 0 0)
@end example
@end deftp

@deftp {Function} @var{TAG}vector-length @r{@var{vec}}
@findex s8vector-length 
@findex u8vector-length
@findex s16vector-length
@findex u16vector-length
@findex s32vector-length
@findex u32vector-length
@findex s64vector-length
@findex u64vector-length
@findex f32vector-length
@findex f64vector-length
[SRFI-4]
@c EN
Returns the length of the @var{TAG}vector @var{vec}.

Note that the generic function @code{size-of} can be used 
to obtain the length of @var{vec} as well,
if you import @code{gauche.collection}
(@xref{Collection framework}).
@c JP
@var{TAG}vector @var{vec}の長さを返します。

モジュール@code{gauche.collection}をインポートしていれば、
@var{vec}の長さを知るのに、総称関数@code{size-of}を使うこともできます
(@ref{Collection framework}参照)。
@c COMMON
@example
(s16vector-length '#s16(111 222 333)) @result{} 3

(use gauche.collection)
(size-of '#s16(111 222 333)) @result{} 3
@end example
@end deftp

@deftp {Function} @var{TAG}vector-ref @r{@var{vec} @var{k} &optional @var{fallback}}
@findex s8vector-ref
@findex u8vector-ref
@findex s16vector-ref
@findex u16vector-ref
@findex s32vector-ref
@findex u32vector-ref
@findex s64vector-ref
@findex u64vector-ref
@findex f32vector-ref
@findex f64vector-ref
[SRFI-4+]
@c EN
Returns the @var{k}-th element of @var{TAG}vector @var{vec}.

If the index @var{k} is out of the valid range, an error is signalled
unless an optional argument @var{fallback} is given; in that case,
@var{fallback} is returned.

Note that the generic function @code{ref} can be used as well,
if you import @code{gauche.collection}.
@c JP
@var{TAG}vector @var{vec}の@var{k}番目の要素を返します。

@var{k}が有効な範囲外であった場合、通常はエラーが通知されますが、
省略可能な引数@var{fallback}が与えられている場合はそれが返されます。

モジュール@code{gauche.collection}をインポートしていれば、
総称関数@code{ref}を使うこともできます。
@c COMMON

@example
(u16vector-ref '#u16(111 222 333) 1) @result{} 222

(use gauche.collection)
(ref '#u16(111 222 333) 1) @result{} 222
@end example
@end deftp

@deftp {Function} @var{TAG}vector-set! @r{@var{vec} @var{k} @var{n} &optional @var{clamp}}
@findex s8vector-set!
@findex u8vector-set!
@findex s16vector-set!
@findex u16vector-set!
@findex s32vector-set!
@findex u32vector-set!
@findex s64vector-set!
@findex u64vector-set!
@findex f32vector-set!
@findex f64vector-set!
[SRFI-4+]
@c EN
Sets a number @var{n} to the @var{k}-th element of @var{TAG}vector @var{vec}.
Optional @var{clamp} argument specifies the behavior when
@var{n} is out of valid range.   Default is to signal an error.

Note that the setter of the generic function @code{ref} can be used as well,
if you import @code{gauche.collection}.
@c JP
@var{TAG}vector @var{vec}の@var{k}番目の要素に数値@var{n}をセットします。
省略可能な引数@var{clamp}が、@var{n}が正しい範囲外の数であった場合の動作を指定します。
デフォルトではエラーが通知されます。

モジュール@code{gauche.collection}をインポートしていれば、
総称関数@code{ref}のsetter手続きを使うこともできます。
@c COMMON
@example
(let ((v (s32vector -439 852 8933)))
  (s32vector-set! v 1 4)
  v)
 @result{} #s32vector(-439 4 8933)

(use gauche.collection)
(let ((v (s32vector -439 852 8933)))
  (set! (ref v 1) 4)
  v)
 @result{} #s32vector(-439 4 8933)
@end example
@end deftp

@deftp {Function} @var{TAG}vector-copy @r{@var{vec} &optional @var{start} @var{end}}
@findex s8vector-copy
@findex u8vector-copy
@findex s16vector-copy
@findex u16vector-copy
@findex s32vector-copy
@findex u32vector-copy
@findex s64vector-copy
@findex u64vector-copy
@findex f32vector-copy
@findex f64vector-copy
@c EN
Copies the srfi-4 vector @var{vec}.
If @var{start} and/or @var{end} are given, they limit the range of
@var{vec} to be copied.
@c JP
ベクタ@var{vec}をコピーします。
省略可能な引数@var{start}と@var{end}が与えられた場合、
それらは取り出される要素の範囲を制限します。
@c COMMON

@example
(u8vector-copy '#u8(1 2 3 4))     @result{} #u8(1 2 3 4)
(u8vector-copy '#u8(1 2 3 4) 2)   @result{} #u8(3 4)
(u8vector-copy '#u8(1 2 3 4) 1 3) @result{} #u8(2 3)
@end example
@end deftp

@deftp {Function} @var{TAG}vector-copy! @r{@var{target} @var{tstart} @var{source} &optional @var{sstart} @var{send}}
@findex s8vector-copy!
@findex u8vector-copy!
@findex s16vector-copy!
@findex u16vector-copy!
@findex s32vector-copy!
@findex u32vector-copy!
@findex s64vector-copy!
@findex u64vector-copy!
@findex f32vector-copy!
@findex f64vector-copy!
@c EN
Both @var{target} and @var{source} must be @i{TAG}vectors, and
@var{target} must be mutable.
This procedure copies the elements of @var{start}, beginning from index
@var{sstart} (inclusive) and up to @var{send}, into @var{target},
beginning from index @var{tstart}.  @var{Sstart} and @var{tstart}
may be omitted, and in that case 0 and the length of @var{source}
are assumed, respectively.
@c JP
@var{target} および @var{source} はともに @i{TAG}vector でなければ
なりません。さらに、@var{target} は変更可能でなければなりません。
この手続きは、@var{start}の要素を、インデックス@var{sstart}から(これを含み)
@var{send} までを、@var{target} へインデックス @var{tstart}からコピーします。
@var{sstart}および@var{tstart}は省略可能で、その場合には、それぞれ、
0 および @var{source}の長さが仮定されます。
@c COMMON

@example
(let ((target (u8vector 0 1 2 3 4 5 6)))
  (u8vector-copy! target 2 '#u8(10 11 12 13 14) 1 4)
  target)
 @result{} #u8(0 1 11 12 13 6)
@end example

@c EN
If the number of elements in the source vector between @var{sstart}
and @var{send} is larger than the target vector beginning from @var{tstart},
the excess elements are silently discarded.
@c JP
もし、コピー元のベクタの @var{sstart} と @var{send} の間にある要素の
数がコピー先のベクタの@var{tstart}以降の部分よりも大きければ、超過分の
ベクタはだまって捨てられます。
@c COMMON

@c EN
@emph{Note:} This procedure used to take just two uniform vectors, @var{target}
and @var{source}, and just copies contents of @var{source} to @var{target}.
Both vectors had to be the same type and same length.  The API is revised
to the current form to make it parallel with @code{string-copy!} (SRFI-13)
and @code{vector-copy!} (SRFI-43).  The old interface is still supported
for the backward compatibility, but it is deprecated and will be gone
in the future releases.
@c JP
@emph{注意事項:} この手続きは以前はユニフォームベクタ @var{target} および
@var{source} のみを引数としてとり、@var{source} の内容を @var{target} へ
コピーするためだけに使われました。両方のベクタは同じ型で、同じ長さでなけ
ればなりませんでした。この API は @code{string-copy!} (SRFI-13) および
@code{vector-copy!} (SRFI-43)にあわせて現在の形式に改訂されています。
旧来のインタフェースもバックワードコンパチビリティのためにサポートされて
いますが、これは廃止予定で、将来のリリースではサポートされなくなります。
@c COMMON
@end deftp

@c EN
Using collection and sequence framework, you can perform
various operations on the homogeneous vectors.
@c JP
コレクションやシーケンスフレームワークを使うと、さらに様々な操作を
行うことができます。
@c COMMON

@example
(use gauche.collection)
(use gauche.sequence)

(fold + 0 '#s32(1 2 3 4)) @result{} 10

(map-to <f32vector> * '#f32(3.2 1.1 4.3) '#f32(-4.3 2.2 9.4))
  @result{} #f32(-13.760001 2.420000 40.420002)

(subseq #u32(1 4 3 4 5) 2 4) @result{} #u32(3 4)
@end example


@node Uvector conversion operations, Uvector numeric operations, Uvector basic operations, Uniform vectors
@subsection Uvector conversion operations
@c NODE ユニフォームベクタの変換

@deftp {Function} @var{TAG}vector->list @r{@var{vec} &optional @var{start} @var{end}}
@findex s8vector->list
@findex u8vector->list
@findex s16vector->list
@findex u16vector->list
@findex s32vector->list
@findex u32vector->list
@findex s64vector->list
@findex u64vector->list
@findex f32vector->list
@findex f64vector->list
[SRFI-4+]
@c EN
Converts @var{TAG}vector @var{vec} to a list.
If @var{start} and/or @var{end} are given, they limit the range of
@var{vec} to be extracted.

Note that the generic function @code{coerce-to} can be used as well,
if you import @code{gauche.collection}.
@c JP
@var{TAG}vector @var{vec}をリストに変換します。
省略可能な引数@var{start}と@var{end}が与えられた場合、
それらは取り出される要素の範囲を制限します。

モジュール@code{gauche.collection}をインポートしていれば、
総称関数@code{coerce-to}を使うこともできます。
@c COMMON
@example
(u32vector->list '#u32(9 2 5)) @result{} (9 2 5)

(use gauche.collection)
(coerce-to <list> '#u32(9 2 5)) @result{} (9 2 5)
@end example
@end deftp

@deftp {Function} @var{TAG}vector->vector @r{@var{vec} &optional @var{start} @var{end}}
@findex s8vector->vector
@findex u8vector->vector
@findex s16vector->vector
@findex u16vector->vector
@findex s32vector->vector
@findex u32vector->vector
@findex s64vector->vector
@findex u64vector->vector
@findex f32vector->vector
@findex f64vector->vector
@c EN
Converts @var{TAG}vector @var{vec} to a vector.
If @var{start} and/or @var{end} are given, they limit the range of
@var{vec} to be copied.

Note that the generic function @code{coerce-to} can be used as well,
if you import @code{gauche.collection}.
@c JP
@var{TAG}vector @var{vec}をベクタに変換します。
省略可能な引数@var{start}と@var{end}が与えられた場合、
それらは取り出される要素の範囲を制限します。

モジュール@code{gauche.collection}をインポートしていれば、
総称関数@code{coerce-to}を使うこともできます。
@c COMMON
@example
(f32vector->vector '#f32(9.3 2.2 5.5))   @result{} #(9.3 2.2 5.5)
(f32vector->vector '#f32(9.3 2.2 5.5) 2) @result{} #(5.5)

(use gauche.collection)
(coerce-to <vector> '#f32(9.3 2.2 5.5)) @result{} #(9.3 2.2 5.5)
@end example
@end deftp

@deftp {Function} list->@var{TAG}vector @r{@var{list} &optional @var{clamp}}
@findex list->s8vector
@findex list->u8vector
@findex list->s16vector
@findex list->u16vector
@findex list->s32vector
@findex list->u32vector
@findex list->s64vector
@findex list->u64vector
@findex list->f32vector
@findex list->f64vector
[SRFI-4+]
@c EN
Converts a list @var{list} to a @var{TAG}vector.
Optional argument @var{clamp} specifies the behavior when
the element of @var{list} is out of the valid range.

Note that the generic function @code{coerce-to} can be used as well,
if you import @code{gauche.collection}.
@c JP
リスト@var{list}を@var{TAG}vectorに変換します。
省略可能な引数@var{clamp}が、リスト内の要素が正しい範囲外の数であった場合の
動作を指定します。

モジュール@code{gauche.collection}をインポートしていれば、
総称関数@code{coerce-to}を使うこともできます。
@c COMMON
@example
(list->s64vector '(9 2 5)) @result{} #s64(9 2 5)

(use gauche.collection)
(coerce-to <s64vector> '(9 2 5)) @result{} #s64(9 2 5)
@end example
@end deftp

@deftp {Function} vector->@var{TAG}vector @r{@var{vec} &optional @var{start} @var{end} @var{clamp}}
@findex vector->s8vector
@findex vector->u8vector
@findex vector->s16vector
@findex vector->u16vector
@findex vector->s32vector
@findex vector->u32vector
@findex vector->s64vector
@findex vector->u64vector
@findex vector->f32vector
@findex vector->f64vector
@c EN
Converts a vector @var{vec} to a @var{TAG}vector.
If @var{start} and/or @var{end} are given, they limit the range of
@var{vec} to be copied.
Optional argument @var{clamp} specifies the behavior when
the element of @var{vec} is out of the valid range.

Note that the generic function @code{coerce-to} can be used as well,
if you import @code{gauche.collection}.
@c JP
ベクタ@var{vec}を@var{TAG}vectorに変換します。
省略可能な引数@var{start}と@var{end}が与えられた場合、
それらは取り出される要素の範囲を制限します。
省略可能な引数@var{clamp}が、ベクタ内の要素が正しい範囲外の数であった場合の
動作を指定します。

モジュール@code{gauche.collection}をインポートしていれば、
総称関数@code{coerce-to}を使うこともできます。
@c COMMON
@example
(vector->f64vector '#(3.1 5.4 3.2)) @result{} #f64(3.1 5.4 3.2)

(use gauche.collection)
(coerce-to <f64vector> '#(3.1 5.4 3.2)) @result{} #f64(3.1 5.4 3.2)
@end example
@end deftp

@defun string->s8vector string &optional start end
@defunx string->u8vector string &optional start end
@c EN
Returns an s8vector or u8vector whose byte sequence is the same
as the internal representation of the given string.
Optional range arguments @var{start} and @var{end} specifies
the @emph{character position} inside @var{string} to be
converted.

These procedures are useful when you want to access byte
sequence of the string randomly.
@c JP
与えられた文字列の内部表現のバイト列と同じバイト列を持つs8vectorもしくは
u8vectorを返します。省略可能な範囲引数@var{start}、@var{end}は、
変換される文字列中の文字位置を指定します。

これらの手続きは、文字を構成するバイト列をランダムにアクセスしたい場合などに
有用です。
@c COMMON

@example
(string->u8vector "abc") @result{} #u8(97 98 99)

@c JP
;; 内部コードがEUCの場合
(string->u8vector "いろは") @result{} #u8(164 164 164 237 164 207)
@c COMMON
@end example
@end defun

@defun string->s8vector! target tstart string &optional start end
@defunx string->u8vector! target tstart string &optional start end
@c EN
@var{Target} must be an s8vector or a u8vector, respectively.
@var{Target} must be mutable.
Like copies the raw byte representation of @var{string}
into @var{target} beginning from index @var{tstart}.
@c JP
@var{target} は、それぞれ s8vector あるいは u8vector でなければなりません。
@var{target} は、変更可能でなければなりません。
@var{string} の生バイト表現を @var{target} へインデックス @var{tstart}
からコピーします。
@c COMMON

@c EN
Returns @var{target}.
@c JP
@var{target} を返します。
@c COMMON

@example
(let ((target (make-u8vector 10 0)))
  (string->u8vector! target 3 "abcde"))
 @result{} #u8(0 0 0 97 98 99 100 101 0 0)
@end example

@end defun

@defun s8vector->string vec &optional start end
@defunx u8vector->string vec &optional start end
@c EN
Converts a byte sequence in s8vector or u8vector to a string that
has the same byte sequence.  Optional range arguments @var{start} and
@var{end} specifies the byte position in @var{vec} to be converted.

Note that these procedure may result an incomplete string if
@var{vec} contains a byte sequence invalid as the internal encoding
of the string.
@c JP
与えられたs8vectorもしくはu8vector @var{vec}のバイト列と同じ内部バイト列を
持つ文字列を作成して返します。省略可能な範囲引数@var{start}、@var{end}は、
@var{vec}中の変換されるべき範囲をバイト位置で指定します。

@var{vec}中のバイト列が文字列の内部表現として不正な値を持っていた場合は、
不完全な文字列が返されます。
@c COMMON
@end defun

@defun string->s32vector string &optional start end
@defunx string->u32vector string &optional start end
@c EN
Returns an s32vector or u32vector whose elements are
the internal codes of the characters in the string.
Optional range arguments @var{start} and @var{end} specifies
the @emph{character position} inside @var{string} to be
converted.

These procedures are useful when you want to access
the characters in the string randomly.
@c JP
与えられた文字列@var{string}の各文字の内部コードを値として持つ
s32vectorもしくはu32vectorを返します。
省略可能な範囲引数@var{start}、@var{end}は、
変換される文字列中の文字位置を指定します。

これらの手続きは、文字列中の文字をランダムにアクセスする場合に便利です。
@c COMMON
@end defun

@defun s32vector->string vec &optional start end
@defunx u32vector->string vec &optional start end
@c EN
Without @var{start} and @var{end}, these procedures work like this:
@c JP
@var{start}と@var{end}を考えなければ、
これらの手続きは次のコードのような動作をします：
@c COMMON
@example
(lambda (vec) (map-to <string> integer->char vec)))
@end example
@c EN
Optional range arguments @var{start} and @var{end} limits
the range of conversion between them.
@c JP
省略可能な範囲引数@var{start}、@var{end}は、
@var{vec}中の変換されるべき範囲を指定します。
@c COMMON
@end defun

@defun uvector-alias uvector-class vec &optional start end
@c EN
This procedure creates an uvector of class @var{uvector-class}
that shares the storage of the given uniform vector @var{vec}.
If optional @var{start} and @var{end} arugments are given,
only the specified range of @var{vec} is used for the new vector.
Since the storage is shared, modification of the original vector
can be seen from the new vector, or vice versa.
@c JP
この手続きは、クラスが@var{uvector-class}であり、
ユニフォームベクタ@var{vec}のメモリ領域を共有するような
新しいユニフォームベクタを作成して返します。
省略可能な引数@var{start}と@var{end}が与えられた場合は
@var{vec}の内容のうちそれらのインデックスで指定される範囲のみが使われます。
メモリ領域が共有されているので、@var{vec}に加える変更は
新しいベクタから見えますし、その逆も可能です。
@c COMMON

@c EN
The class @var{uvector-class} must be either one of the uniform
vector class, but is not necessary match the class of the
source vector @var{vec}.   In such case, the new vector looks at the same
region of @var{vec}'s memory, but interpretes it differently.
For example, the following code determines whether Gauche
is running on big-endian or little-endian machine:
@c JP
クラス@var{uvector-class}はユニフォームベクタのクラスでなければなりませんが、
@var{vec}のクラスと一致している必要はありません。
そのような場合は、新しいベクタは@var{vec}と同じメモリ領域の値を
異なる値と解釈するかもしれません。
例えば、次のコードはGaucheが走っているマシンが
リトルエンディアンであるかビッグエンディアンであるかを判定します。
@c COMMON

@example
(let ((u8v (uvector-alias <u8vector> #u32(1))))
  (if (zero? (u8vector-ref u8v 0))
      'big-endian 
      'little-endian))
@end example

@c EN
If the @var{uvector-class} is other than s8vector or u8vector,
the region the new vector points has to meet the alignment
requirement.  You can assume the beginning of the source vector
is aligned suitable for any uniform vectors.  So, for example,
if you're creating u32vector from u8vector, the @var{start} and
@var{end} must be multiple of 4 (or, if they're omitted, the length
of the original u8vector must be multiple of 4).
An error is signalled when the given parameters doesn't satisfy
alignment constraint.
@c JP
@var{uvector-class}がs8vectorかu8vector以外の場合、
新しいベクタが指す領域は、そのベクタの要素のアラインメントの要請に
したがっていなければなりません。
ユニフォームベクタの開始点は常に全てのユニフォームベクタのアラインメント要請を
満たします。したがって、例えばu8vectorからu32vectorを作成する場合、
@var{start}および@var{end}は4の倍数でなければなりません
(あるいは、@var{start}/@var{end}が省略された場合、@var{vec}の長さが
4の倍数でなければなりません)。
与えられたパラメータでアラインメントの要請が満たせない場合はエラーが通知されます。
@c COMMON
@end defun


@node Uvector numeric operations, Uvector block I/O, Uvector conversion operations, Uniform vectors
@subsection Uvector numeric operations
@c NODE ユニフォームベクタの数値演算

@deftp {Function} @var{TAG}vector-add @r{@var{vec} @var{val} &optional @var{clamp}}
@deftpx {Function} @var{TAG}vector-add! @r{@var{vec} @var{val} &optional @var{clamp}}
@deftpx {Function} @var{TAG}vector-sub @r{@var{vec} @var{val} &optional @var{clamp}}
@deftpx {Function} @var{TAG}vector-sub! @r{@var{vec} @var{val} &optional @var{clamp}}
@deftpx {Function} @var{TAG}vector-mul @r{@var{vec} @var{val} &optional @var{clamp}}
@deftpx {Function} @var{TAG}vector-mul! @r{@var{vec} @var{val} &optional @var{clamp}}
@findex s8vector-add
@findex s8vector-add!
@findex s8vector-sub
@findex s8vector-sub!
@findex s8vector-mul
@findex s8vector-mul!
@findex u8vector-add
@findex u8vector-add!
@findex u8vector-sub
@findex u8vector-sub!
@findex u8vector-mul
@findex u8vector-mul!
@findex s16vector-add
@findex s16vector-add!
@findex s16vector-sub
@findex s16vector-sub!
@findex s16vector-mul
@findex s16vector-mul!
@findex u16vector-add
@findex u16vector-add!
@findex u16vector-sub
@findex u16vector-sub!
@findex u16vector-mul
@findex u16vector-mul!
@findex s32vector-add
@findex s32vector-add!
@findex s32vector-sub
@findex s32vector-sub!
@findex s32vector-mul
@findex s32vector-mul!
@findex u32vector-add
@findex u32vector-add!
@findex u32vector-sub
@findex u32vector-sub!
@findex u32vector-mul
@findex u32vector-mul!
@findex s64vector-add
@findex s64vector-add!
@findex s64vector-sub
@findex s64vector-sub!
@findex s64vector-mul
@findex s64vector-mul!
@findex u64vector-add
@findex u64vector-add!
@findex u64vector-sub
@findex u64vector-sub!
@findex u64vector-mul
@findex u64vector-mul!
@findex f32vector-add
@findex f32vector-add!
@findex f32vector-sub
@findex f32vector-sub!
@findex f32vector-mul
@findex f32vector-mul!
@findex f64vector-add
@findex f64vector-add!
@findex f64vector-sub
@findex f64vector-sub!
@findex f64vector-mul
@findex f64vector-mul!
@c EN
Element-wise arithmetic.  @var{Vec} must be a @var{TAG}vector,
and @var{val} must be either a @var{TAG}vector, a vector, or a list
of the same length as @var{vec}, or a number
(an exact integer for integer vectors, 
and a real number for f32- and f64-vectors).
@c JP
要素毎の計算手続きです。@var{vec}は@var{TAG}vectorでなければなりません。
また、@var{val}は@var{vec}と同じ長さの@var{TAG}vectorかベクタかリスト、
あるいは数値(整数ベクタに対しては正確な整数、実数ベクタに対しては実数)
でなければなりません。
@c COMMON

@c EN
If @var{val} is a @var{TAG}vector, its elements are 
added to, subtracted from, or multiplied by the corresponding
elements of @var{vec}, respectively,
and the results are gathered to a @var{TAG}vector 
and returned.  The destructive version (those have bang `!' in the name)
reuses @var{vec} to store the result.
If the result of calculation goes out of the range of @var{TAG}vector's
element, the behavior is specified by @var{clamp} optional argument.
(For f32vector and f64vector, @var{clamp} argument is ignored and
the result may contain infinity).
@c JP
@var{val}が@var{TAG}vectorの場合、
@var{vec}と対応する要素毎に加算、減算、乗算が行われ、
結果が@var{TAG}vectorとして返されます。
破壊的なバージョン(名前に`!'がついているもの)では、@var{vec}が
結果を格納するために再利用されます。
演算の結果が@var{TAG}vectorの要素の値域外になった場合の動作は
省略可能な引数@var{clamp}によって指定されます。
(f32vectorとf64vectorでは、値域外になった要素にはinfinityが格納され、
@var{clamp}の値は無視されます)。
@c COMMON

@c EN
If @var{val} is a number, it is added to, subtracted from, or
multiplied by each element of @var{vec}, respectively.
@c JP
@var{val}が数値である場合、@var{vec}の各要素とその数値の間で演算が行われます。
@c COMMON

@example
(s8vector-add '#s8(1 2 3 4) '#s8(5 6 7 8)) @result{} #s8(6 8 10 12)
(u8vector-sub '#u8(1 2 3 4) '#u8(2 2 2 2)) @result{} @r{error}
(u8vector-sub '#u8(1 2 3 4) '#u8(2 2 2 2) 'both) @result{} #u8(0 0 1 2)

(f32vector-mul '#f32(3.0 2.0 1.0) 1.5) @result{} #f32(4.5 3.0 1.5)
@end example
@end deftp

@deftp {Function} @var{TAG}vector-div @r{@var{vec} @var{val}}
@deftpx {Function} @var{TAG}vector-div! @r{@var{vec} @var{val}}
@findex f32vector-div
@findex f32vector-div!
@findex f64vector-div
@findex f64vector-div!
@c EN
Element-wise division of flonum vectors.   These are only defined
for f32vector and f64vector.  @var{val} must be a @var{TAG}vector,
a vector or a list of the same length as @var{vec}, or a real number.
@c JP
要素毎の除算です。これらはf32vectorとf64vectorのみに対して定義されます。
@var{val}は@var{vec}と同じ大きさの@var{TAG}vectorかベクタかリスト、
あるいは実数でなければなりません。
@c COMMON

@example
(f32vector-div '#f32(1.0 2.0 3.0) 2.0) @result{} #f32(0.5 1.0 1.5)
@end example
@end deftp


@deftp {Function} @var{TAG}vector-and @r{@var{vec} @var{val}}
@deftpx {Function} @var{TAG}vector-and! @r{@var{vec} @var{val}}
@deftpx {Function} @var{TAG}vector-ior @r{@var{vec} @var{val}}
@deftpx {Function} @var{TAG}vector-ior! @r{@var{vec} @var{val}}
@deftpx {Function} @var{TAG}vector-xor @r{@var{vec} @var{val}}
@deftpx {Function} @var{TAG}vector-xor! @r{@var{vec} @var{val}}
@findex s8vector-and
@findex s8vector-and!
@findex s8vector-ior
@findex s8vector-ior!
@findex s8vector-xor
@findex s8vector-xor!
@findex u8vector-and
@findex u8vector-and!
@findex u8vector-ior
@findex u8vector-ior!
@findex u8vector-xor
@findex u8vector-xor!
@findex s16vector-and
@findex s16vector-and!
@findex s16vector-ior
@findex s16vector-ior!
@findex s16vector-xor
@findex s16vector-xor!
@findex u16vector-and
@findex u16vector-and!
@findex u16vector-ior
@findex u16vector-ior!
@findex u16vector-xor
@findex u16vector-xor!
@findex s32vector-and
@findex s32vector-and!
@findex s32vector-ior
@findex s32vector-ior!
@findex s32vector-xor
@findex s32vector-xor!
@findex u32vector-and
@findex u32vector-and!
@findex u32vector-ior
@findex u32vector-ior!
@findex u32vector-xor
@findex u32vector-xor!
@findex s64vector-and
@findex s64vector-and!
@findex s64vector-ior
@findex s64vector-ior!
@findex s64vector-xor
@findex s64vector-xor!
@findex u64vector-and
@findex u64vector-and!
@findex u64vector-ior
@findex u64vector-ior!
@findex u64vector-xor
@findex u64vector-xor!
@c EN
Element-wise logical (bitwise) operation.
These procedures are only defined for integral vectors.
@var{val} must be a @var{TAG}vector, a vector or a list
of the same length as @var{vec},
or an exact integer.  Bitwise and, inclusive or or exclusive or
is calculated between each element in @var{vec} and the corresponding
element of @var{val} (when @var{val} is a non-scalar value),
or @var{val} itself (when @var{val} is an integer).
The result is returned in a @var{TAG}vector.
The destructive version reuses @var{vec} to store the result.
@c JP
要素毎の論理(ビット)演算です。
これらの手続きは整数ベクタに対してのみ定義されています。
@var{val}は@var{vec}と同じ大きさの@var{TAG}vectorかベクタかリスト、
あるいは正確な整数でなければなりません。@var{vec}の各要素と、対応する@var{val}の要素
(@var{val}が非スカラー値の場合)もしくは@var{val}自身
(@var{val}が整数の場合)とのビット毎のand, inclusive orまたはexclusive or
が計算され、結果が@var{TAG}vectorで返されます。
破壊的なバージョン(名前に`!'がついているもの)では、@var{vec}が
結果を格納するために再利用されます。
@c COMMON
@end deftp

@deftp {Function} @var{TAG}vector-dot @r{@var{vec0} @var{vec1}}
@findex s8vector-dot
@findex s16vector-dot
@findex s32vector-dot
@findex s64vector-dot
@findex u8vector-dot
@findex u16vector-dot
@findex u32vector-dot
@findex u64vector-dot
@findex f32vector-dot
@findex f64vector-dot
@c EN
Calculates the dot product of two @var{TAG}vectors.
The length of @var{vec0} and @var{vec1} must be the same.
@c JP
ふたつの@var{TAG}vectorの内積を計算します。
@var{vec0}と@var{vec1}の長さは等しくなければなりません。
@c COMMON
@end deftp

@deftp {Function} @var{TAG}vector-range-check @r{@var{vec} @var{min} @var{max}}
@findex s8vector-range-check
@findex s16vector-range-check
@findex s32vector-range-check
@findex s64vector-range-check
@findex u8vector-range-check
@findex u16vector-range-check
@findex u32vector-range-check
@findex u64vector-range-check
@findex f32vector-range-check
@findex f64vector-range-check
@c EN
@var{Vec} must be a @var{TAG}vector, and each of @var{min} and @var{max}
must be either a @var{TAG}vector, a vector or a list of the same length
as @var{vec}, or a number, or @code{#f}.

For each element in @var{vec}, this procedure checks if the value
is between @var{minval} and @var{maxval} inclusive, where
@var{minval} and @var{maxval} are the corresponding values of
@var{min} and @var{max} (when @var{min} and/or @var{max} is/are
non-scalar value) or @var{min} and @var{max} themselves (when
@var{min} and/or @var{max} is/are a number).
When @var{min} is @code{#f}, negative infinity is assumed.
When @var{max} is @code{#f}, positive infinity is assumed.

If all the elements in @var{vec} are within the range, @code{#f} is
returned.  Otherwise, the index of the leftmost element of @var{vec}
that is out of range is returned.
@c JP
@var{vec}は@var{TAG}vectorでなければなりません。
@var{min}と@var{max}はそれぞれ、@var{vec}と同じ長さの@var{TAG}vector、
ベクタ、リストのいずれかか、実数もしくは@code{#f}でなければなりません。

@var{vec}の各要素に対して、この手続きはそれが対応する@var{minval}と@var{maxval}
の間にあるかどうかを検査します。@var{minval}と@var{maxval}も範囲に含みます。
ここで、@var{minval}と@var{maxval}は、@var{min}/@var{max}が非スカラー値
であれば@var{vec}の要素に対応するそれぞれの要素、
@var{min}/@var{max}が数値であればその数値そのものです。
@var{min}が@code{#f}の場合、最小値はマイナス無限大と考えられます。
@var{max}が@code{#f}の場合、最大値はプラス無限大と考えられます。

@var{vec}の全ての要素が範囲内であった場合は@var{#f}が返されます。
そうでなければ、範囲を外れた要素のうちもっとも左のものの@var{vec}内での
インデックスが返されます。
@c COMMON

@example
(u8vector-range-check '#u8(3 1 0 2) 0 3)  @result{} #f
(u8vector-range-check '#u8(3 1 0 2) 1 3)  @result{} 2

(u8vector-range-check '#u8(4 32 64 98) 0 '#u8(10 40 70 90))
  @result{} 3

;; Range check in a program
(cond
 ((u8vector-range-check u8v 1 31)
  => (lambda (i)
      (errorf "~sth vector element is out of range: ~s"
              i (u8vector-ref u8v i))))
 (else (do-something u8v)))
@end example
@end deftp

@deftp {Function} @var{TAG}vector-clamp @r{@var{vec} @var{min} @var{max}}
@deftpx {Function} @var{TAG}vector-clamp! @r{@var{vec} @var{min} @var{max}}
@findex s8vector-clamp
@findex s16vector-clamp
@findex s32vector-clamp
@findex s64vector-clamp
@findex u8vector-clamp
@findex u16vector-clamp
@findex u32vector-clamp
@findex u64vector-clamp
@findex f32vector-clamp
@findex f64vector-clamp
@findex s8vector-clamp!
@findex s16vector-clamp!
@findex s32vector-clamp!
@findex s64vector-clamp!
@findex u8vector-clamp!
@findex u16vector-clamp!
@findex u32vector-clamp!
@findex u64vector-clamp!
@findex f32vector-clamp!
@findex f64vector-clamp!
@c EN
@var{Vec} must be a @var{TAG}vector, and each of @var{min} and @var{max}
must be either a @var{TAG}vector, a vector or a list of the same length
as @var{vec}, or a number, or @code{#f}.

Like @var{TAG}vector-range-check, these procedures check if
each element of @var{vec} are within the range between @var{minval}
and @var{maxval} inclusive, which are defived from @var{min} and @var{max}.
If the value is less than @var{minval}, it is replaced by @var{minval}.
If the value is grater than @var{maxval}, it is replaced by @var{maxval}.

@var{TAG}vector-clamp creates a copy of @var{vec} and do clamp
operation on it, while @var{TAG}vector-clamp! modifies @var{vec}.
Both return the clamped vector.
@c JP
@var{vec}は@var{TAG}vectorでなければなりません。
@var{min}と@var{max}はそれぞれ、@var{vec}と同じ長さの@var{TAG}vector、
ベクタ、リストのいずれかか、実数もしくは@code{#f}でなければなりません。

@var{TAG}vector-range-checkと同じように、この手続きは@var{vec}の各要素が
@var{min}および@var{max}で指定される最小値と最大値の間にあるかどうかを
検査します。要素が最小値より小さかった場合はそれが最小値に置き換えられます。
要素が最大値より大きかった場合はそれが最大値に置き換えられます。

@var{TAG}vector-clampは@var{vec}のコピーを作ってそれに対して
クランプ操作を行います。@var{TAG}vector-clamp!は@var{vec}を直接
変更します。どちらもクランプ操作が行われた後の@var{TAG}vectorを返します。
@c COMMON

@example
(s8vector-clamp '#s8(8 14 -3 -22 0) -10 10) @result{} #s8(8 10 -3 -10 0)
@end example
@end deftp

@node Uvector block I/O,  , Uvector numeric operations, Uniform vectors
@subsection Uvector block I/O
@c NODE ユニフォームベクタのブロック入出力

@c EN
A uniform vector can be seen as an abstraction of a chunk of memory.
So you might want to use it for binary I/O.  Yes, you can do it.
@c JP
ユニフォームベクタは、メモリの固まりを抽象化しているものと考えることも
できます。それなら、それをバイナリI/Oに使えないでしょうか。もちろんできます。
@c COMMON

@defun read-block! vec &optional iport start end
@c EN
Reads a chunk of data from the given input port @var{iport},
and stores it to the uniform vector @var{vec}.
You can give any uniform vector.
If optional @var{start} and @var{end}
arguments are given, they specify the index range in @var{vec}
that is to be filled, and the rest of the vector remains untouched.
Otherwise, entire vector is used.
If @var{iport} is omitted, the current input port is used.
@c JP
与えられた入力ポート@var{iport}からデータの固まりを読みだし、それを
ユニフォームベクタ@var{vec}に格納します。
どんな種類のユニフォームベクタでも与えることができます。
省略可能な引数@var{start}と@var{end}が与えられた場合は、
それらが@var{vec}中でデータが格納されるべき領域のインデックスの範囲を
示します。その範囲外の@var{vec}の値は変更されません。
@var{start}、@var{end}が与えられなかった場合は@var{vec}全体が使われます。
@var{iport}が省略された場合はカレント入力ポートが使われます。
@c COMMON

@c EN
If the input reached EOF before the required region of @var{vec}
is filled, the rest of the vector is untouched.
@c JP
要求された領域を埋め終る前に入力がEOFに達した場合は、ベクタの残りの部分は
変更されません。
@c COMMON

@c EN
If @var{iport} is already reached EOF when @code{read-block!} is
called, an EOF object is returned.  Otherwise,
the procedure returns the number of @emph{elements} read (not bytes).
@c JP
@code{read-block!}が呼ばれた時既に@var{iport}がEOFに達していた場合は
EOFが、そうでなければ読まれた要素の数 (バイト数ではありません) が返されます。
@c COMMON

@c EN
If the @var{iport} is a buffered port with `modest' or `none'
buffering mode (@xref{File ports}), @code{read-block!} may return
before all the elements in @var{vec} is filled, even if @var{iport}
hasn't reached EOF.  The ports connected to a pipe or a network socket
behave so by default.  If you know there will be enough data arriving and
want to make sure @var{vec} is filled, change the buffering mode of
@var{iport} to `full'.
@c JP
@var{iport}がバッファードポートであり、そのバッファリングモードが
`modest' か `none' であった場合、@code{read-block!}は@var{iport}が
EOFに達していなくても、@var{vec}を埋める前に戻ることがあります
(バッファリングモードについては@ref{File ports})を参照して下さい。
パイプやネットワークに接続されたポートはデフォルトでそのように振舞います。
もし、十分なデータが到着することがわかっており、@var{vec}を確実に埋めたい場合は
ポートのバッファリングモードを`full'に変更して下さい。
@c COMMON

@c EN
The data is read as a byte stream, so if you give uniform vectors
other than s8vector or u8vector, your result may affected by
the endianness of the platform.    Suppose the input stream
has a byte sequence @code{#x01, #x02, #x03, #x04}.  If you read
it into u32vector, the first element you'll get may be
@code{#x01020304} if you're using big-endian architecture,
or @code{#x04030201} if you're using little-endian architecture.
@c JP
データはバイトストリームとして読まれるので、
s8vectorとu8vector以外のユニフォームベクタを与えた場合は
結果がプラットフォームのエンディアンに影響を受けることに注意して下さい。
例えば入力が@code{#x01, #x02, #x03, #x04}というバイトシーケンスだったと
します。これをu32vectorに読み込んだ場合、最初の要素は
ビッグエンディアンアーキテクチャでは@code{#x01020304}になりますが、
リトルエンディアンアーキテクチャでは@code{#x04030201}となるでしょう。
@c COMMON
@end defun


@defun write-block vec &optional oport start end
@c EN
Writes out the content of the uniform vector @var{vec} 'as is'
to the output port @var{oport}.   If @var{oport} is omitted,
the current output port is used.
If optional @var{start} and @var{end} arguments are given,
they specify the index range in @var{vec} to be written out.
This procedure returns an unspecified value.
@c JP
ユニフォームベクタ@var{vec}の内容を「そのまま」@var{oport}に書き出します。
@var{oport}が省略された場合はカレント出力ポートが使われます。
省略可能な引数@var{start}と@var{end}が与えられた場合は、
それらのインデックスの範囲が示す@var{vec}の内容のみが出力されます。
この手続きの返す値は未定義です。
@c COMMON

@c EN
If you write out a uniform vector except s8vector and u8vector, the 
care should be taken about the endianness, as in @code{read-block!}.
The number @code{#x01020304} in your u32vector may be written out
as the byte sequence @code{#x01, #x02, #x03, #x04} or
@code{#x04, #x03, #x02, #x01}, depending on your architecture.
@c JP
@code{s8vector}と@code{u8vector}以外のユニフォームベクタを与えた場合、
@code{read-block!}と同じようにエンディアンの影響を受けることに注意して
下さい。u32vector中の数値@code{#x01020304}は、
プラットフォームによってバイトシーケンス@code{#x01, #x02, #x03, #x04}と
なるかもしれませんし、@code{#x04, #x03, #x02, #x01}となるかもしれません。
@c COMMON
@end defun

@c ----------------------------------------------------------------------
@node Comparing version numbers, Virtual ports, Uniform vectors, Library modules - Gauche extensions
@section @code{gauche.version} - Comparing version numbers
@c NODE バージョン番号の比較, @code{gauche.version} - バージョン番号の比較

@deftp {Module} gauche.version
@mdindex gauche.version
@c EN
This module provides a convenient procedure to compare
@emph{version numbers} or @emph{revision numbers},
such as "@code{0.5.1}", "@code{3.2-3}" or "@code{8.2pl1}".
Usually each release of software component has
a version number, and you can define order between them.
For example, version "1.2.3" is newer than "1.2" and
older than "2.1".   You can compare those version numbers like this:
@c JP
このモジュールは、バージョン番号(リリース番号)を比較する便利な手続きを提供します。
ここでのバージョン番号とはソフトウェアのリリースにつけられる
"@code{0.5.1}"、"@code{3.2-3}"、"@code{8.2pl1}"といった文字列で、
通常これらの番号間には順序関係が定義できます。
例えば "1.2.3" は "1.2" より新しいが "2.1" より古い、といった具合です。
以下のようにこれらの文字列の順序を比較することができるようになります。
@c COMMON

@example
(version<? "2.2.3" "2.2.11")     @result{} #t
(version<? "2.3.1" "2.3")        @result{} #f
(version<? "2.3.1-1" "2.3.1-10") @result{} #t
(version<? "13a" "5b")           @result{} #f
@end example

@c EN
There are no standard way to name versions, so I chose
one convention.   This won't work for all possible
variations, but I think it covers typical cases.
@c JP
バージョン番号の付け方には特に標準というものはありませんが、
よく使われている方法を採用しました。全ての場合に使えるとはいきませんが、
大抵の場合はカバーできるのではないかと思います。
@c COMMON

@c EN
Strictly speaking, you can only define partial order between
version numbers, for there can be branches.   This module
uses simple measure and just assumes the version numbers
can be fully ordered.
@c JP
厳密に言えば、分岐などの場合があるのでバージョン番号間の関係は半順序関係にしかなりません。
このモジュールでは単純な定義を使って、全順序関係があるものとして扱います。
@c COMMON

@c EN
The version number here is defined by the following syntax.
@c JP
まず、ここでのバージョン番号は以下の構文に従うものとします。
@c COMMON
@example
 <version> : <principal-release>
           | <version> <post-subrelease>
           | <version> <pre-subrelease>
 <principal-release> : <relnum>
 <post-subrelease>   : [.-] <relnum>
 <pre-subrelease>    : _ <relnum>
 <relnum>            : [0-9A-Za-z]+
@end example

@c EN
Typically @code{<relnum>} is composed by numeric part and extension part.
For example, "23a" is composed by an integer 23 and extension "a".
If @code{<relnum>} doesn't begins with digits, we assume its
numeric part is -1.
@c JP
通常@code{<relnum>}は数字部分と、それに続く省略可能な拡張部分とからなります。
例えば "@code{23a}" は数字部分23と拡張部分"@code{a}"からなります。
もし@code{<relnum>}が数字で始まらない場合、その数字部分は-1であると考えることにします。
@c COMMON

@c EN
Then, the order of @code{<relnum>} is defined as follows:
@c JP
@code{<relnum>}の順序関係を次のように定義します。
@c COMMON
@enumerate
@item
@c EN
If relnum A and relnum B have different numeric part, we ignore the
extension and order them numerically, e.g.  "@code{3b}" < "@code{4a}".
@c JP
relnum Aとrelnum Bが異なる数字部分を持っている場合、拡張部分を無視して
数字部分を数値として比較します。例："@code{3b}" < "@code{4a}"。
@c COMMON
@item
@c EN
If relnum A and relnum B have the same numeric part, we compare
extension by alphabetically, e.g.  "@code{4c}" < "@code{4d}"
and "@code{5}" < "@code{5a}".
@c JP
relnum Aとrelnum Bの数字部分が等しい場合、拡張部分を辞書順に比較します。
例："@code{4c}" < "@code{4d}"、"@code{5}" < "@code{5a}"。
@c COMMON
@end enumerate

@c EN
Given the order of @code{<relnum>}, the order of version numbers
are defined as follows:
@c JP
@code{<relnum>}間の順序が定義できたところで、バージョン番号の順序を次のように定義します。
@c EN
@enumerate
@item
Decompose each version number into a list of @code{<principal-release>} and
subsequence subrelease components.   We call each element of
the list "release components".
@item
If the first release component of both lists are the same,
remove it from both.  Repeat this until the head of the lists differ.
@item
Now we have the following cases.
@enumerate
@item
Both lists are empty: versions are the same.
@item
One list (A) is empty and the other list (B) has post-subrelease
at head: A is prior to B
@item
One list (A) is empty and the other list (B) has pre-subrelease
at head: B is prior to A
@item
List A's head is post-subrelease and list B's head is
pre-subrelease: B is prior to A
@item
Both lists have post-subrelease or pre-subrelease at head:
compare their relnums.
@end enumerate
@end enumerate
Here are some examples:
@c JP
@enumerate
@item
各々のバージョン番号を分解して @code{<principal-release>} とそれに続く
サブリリース部品のリストに入れる。このリストの各要素のことを「リリース部品」
と呼びます。
@item
もし両方のリストの最初のリリース部品が同じなら、それを両方のリストから
取り除きます。これをリストの先頭が異るまでくりかえします。
@item
そうすると次のような場合に分られます。
@enumerate
@item
両方のリストが空： バージョンは同じ。
@item
一方のリスト (A) が空で、他方のリスト (B) の先頭がポストサブリリース：
A が B より前のバージョン。
@item
一方のリスト (A) が空で、他方のリスト (B) の先頭がプリサブリリース：
B が A より前のバージョン
@item
リスト A の先頭がポストサブリリースで、リスト B の先頭がプリサブリリース：
B が A より前のバージョン
@item
両方のリストとも先頭がポストサブリリースであるかプリサブリリース：
relnum を比較する。
@end enumerate
@end enumerate

以下はいくつかの例です。
@c COMMON
@example
"1" < "1.0" < "1.1" < "1.1.1" < "1.1.2" < "1.2" < "1.11"
"1.2.3" < "1.2.3-1" < "1.2.4"
"1.2.3" < "1.2.3a" < "1.2.3b"
"1.2_rc0" < "1.2_rc1" < "1.2" < "1.2-pl1" < "1.2-pl2"
"1.1-patch112" < "1.2_alpha"
@end example

@c EN
The reason of having @code{<pre-subrelease>} is to allow
"release candidate" or "pre-release" version.
@c JP
@code{<pre-subrelease>} があるのは、「リリース候補」あるいは
「プリリリース」のバージョンをつかえるようにするためです。
@c COMMON
@end deftp

@defun version=? ver1 ver2
@defunx version<? ver1 ver2
@defunx version<=? ver1 ver2
@defunx version>? ver1 ver2
@defunx version>=? ver1 ver2
@c EN
Returns a boolean value depending on the order of two version number
string @var{ver1} and @var{ver2}.  If the arguments contain invalid
strings as the defined version number, an error is signalled.
@c JP
ふたつのバージョン番号文字列 @var{ver1} と @var{ver2} の順序関係によって
真偽値を返します。もし引数が、バージョン番号を定義するのに不正な文字列を
含んでいたばあい、エラーが上ります。
@c COMMON
@end defun

@defun version-compare ver1 ver2
@c EN
Compares two version number strings @var{ver1} and @var{ver2},
and returns either -1, 0, or 1, depending whether @var{ver1} is
prior to @var{ver2}, @var{ver1} is the same as @var{ver2}, or
@var{ver1} is after @var{ver2}, respectively.
@c JP
ふたつのバージョン番号文字列 @var{ver1} と @var{ver2} を比較し、
@var{ver1} のほうが @var{ver2} より前、@var{ver1} と @var{ver2} は同じ、
@var{ver1} が @var{ver2} の後、の3つの場合によって、それぞれ、
-1、0、1 を返します。
@c COMMON
@end defun

@defun relnum-compare rel1 rel2
@c EN
This is lower-level procedure of @code{version-compare}.  Compares
two release numbers (relnums) @var{rel1} and @var{rel2}, 
and returns either -1, 0, or 1 depending whether  @var{rel1} is
prior to @var{rel2}, @var{rel1} is the same as @var{rel2}, or
@var{rel1} is after @var{rel2}, respectively.
@c JP
これは @code{version-compare}の下位レベルの手続きです。
ふたつのリリース番号 (relnum) @var{rel1} と @var{rel2} を比較し、
@var{rel1} が @var{rel2} より前、@var{rel1} と @var{rel2} が同じ、
@var{rel1} が @var{rel2} より後、の3つの場合によって、それぞれ、
-1、0、1 を返します。
@c COMMON
@end defun

@c ----------------------------------------------------------------------
@node Virtual ports,  , Comparing version numbers, Library modules - Gauche extensions
@section @code{gauche.vport} - Virtual ports
@c NODE 仮想ポート, @code{gauche.vport} - 仮想ポート

@deftp {Module} gauche.vport
@mdindex gauche.vport
@c EN
@emph{Virtual ports}, or procedural ports, are the ports
whose behavior can be programmed in Scheme.
@c JP
@emph{仮想ポート}あるいは手続き的ポートとは、その振舞いを
Scheme でプログラム可能なポートです。
@c COMMON

@c EN
This module provides two kinds of virtual ports:
Fully virtual ports, in which every I/O operation invokes
user-provided procedures, and virtual buffered ports,
in which I/O operations are done on an internal buffer and
user-provided procedures are called only when the buffer
needs to be filled or flushed.
@c JP
このモジュールは 2 種類の仮想ポートを提供します。ひとつは、
完全仮想ポートで、すべての I/O 操作でユーザが提供する手続きが
呼出されるものです。もうひとつは、仮想バッファポートで、
I/O 操作は内部バッファ上で行われ、ユーザが提供する手続きは
バッファを一杯にするかフラッシュする必要がある場合にのみ
呼出されます。
@c COMMON

@c EN
This module also provides virtual buffered ports backed up
by a uniform vector, as an example of the feature.
@c JP
このモジュールはさらに、ユニフォームベクタにより
バックアップされる仮想バッファポートも提供します。
これは仮想ポートの使用例でもあります。
@c COMMON
@end deftp

@c EN
@subsubheading Fully virtual ports
@c JP
@subsubheading 完全仮想ポート
@c COMMON

@c EN
This type of virtual ports are realized by classes
@code{<virtual-input-port>} and @code{<virtual-output-port>}.
You can customize the port behavior by setting 
appropriate slots with procedures.
@c JP
このタイプの仮想ポートは、@code{<virtual-input-port>} クラス
および @code{<virtual-output-port>} クラスで実現されています。
適切なスロットに手続きをセットすることでポートの振舞いをカスタマイズ
可能です。
@c COMMON

@deftp {Class} <virtual-input-port>
@clindex virtual-input-port
@c EN
An instance of this class can be used as an input port.
The behavior of the port depends on the settings of the
instance slot values.
@c JP
このクラスのインスタンスは入力ポートとして使えます。
このポートの振舞いはインスタンスのスロットに設定された値に依存します。
@c COMMON

@c EN
To work as a meaningful input port, at least either one of
@code{getb} or @code{getc} slot must be set.  Otherwise,
the port returns EOF for all input requests.
@c JP
まともな入力ポートとして動かすためには、少くとも、@code{getb} スロット
あるいは @code{getc} スロットのどちらか一方は設定しなければなりません。
さもなければ、このポートはすべての入力要求に対して EOF を返します。
@c COMMON

@defivar {<virtual-input-port>} getb
@c EN
If set, the value must be a proceture that takes no arguments.
Every time binary input is required, the procedure is called.
@c JP
設定されているのなら、その値は、引数を取らない手続きでなければなりません。
バイナリ入力の要求のたびに、この手続きが呼ばれます。
@c COMMON

@c EN
The procedure must return an exact integer between 0 and 255
inclusive, or @code{#f} or an EOF object.  If it returns an
integer, it becomes the value read from the port.  If it returns
other values, the port returns EOF.
@c JP
この手続きは、0 から 255 までの正確な整数を返すか、@code{#f}あるいは
EOF オブジェクトを返さなければなりません。整数を返す場合には、
それがこのポートから読みとられる値となります。それ以外の値を返す
場合は、このポートは EOF を返します。
@c COMMON

@c EN
If the port is requested a character input and it doesn't have
the @code{getc} procedure, the port calls this procedure, possibly
multiple times, to construct a whole character.
@c JP
このポートが文字入力を要求され、かつ、@code{getc} 手続きを持たない場合、
このポートはこの手続きを呼び(複数回の可能性もある)文字全体を構築します。
@c COMMON
@end defivar

@defivar {<virtual-input-port>} getc
@c EN
If set, the value must be a proceture that takes no arguments.
Every time character input is required, the procedure is called.
@c JP
設定されているのなら、その値は、引数を取らない手続きでなければなりません。
文字入力の要求のたびに、この手続きが呼ばれます。
@c COMMON

@c EN
The procedure must return a character,
@code{#f} or an EOF object.  If it returns a character,
it becomes the value read from the port.  If it returns
other values, the port returns EOF.
@c JP
この手続きは文字を返すか、または@code{#f}あるいはEOFオブジェクトを返さなければ
なりません。文字を返した場合には、それがこのポートから読みとられる値と
なります。それ以外の値を返す場合は、このポートは EOF を返します。
@c COMMON

@c EN
If the port is requested a binary input and it doesn't have
the @code{getb} procedure, the port calls this procedure, then converts
a character into a byte sequence, and use it as the binary
value(s) read from the port.
@c JP
このポートがバイナリ入力を要求され、かつ、@code{getb} 手続きを持たない場合、
このポートはこの手続きを呼び、文字をバイト列に変換し、それをこのポートから
読みだされる値として使います。
@c COMMON
@end defivar

@defivar {<virtual-input-port>} gets
@c EN
If set, the value must be a procedure that takes one argument,
a positive exact integer.  It is called when the block binary
input, such as @code{read-block}, is requested.
@c JP
設定されているなら、その値は、正の正確な整数の引数をひとつだけとる手続き
でなければなりません。ブロックバイナリ入力、たとえば、
@code{read-block}などが要求された場合に、呼出されます。
@c COMMON

It must return a (maybe incomplete) string up to the specified size, 
or @code{#f} or EOF object.  If it returns a null string, @code{#f}
or EOF object, 
the port thinks it reached EOF.  If it returns other string,
it is used as the result of block read.
It shouldn't return a string larger than the given size
(Note: you must count size (bytes), not the number of characters).

@c EN
The reason of this procedure is efficiency; if this procedure
is not provided, the port calls @code{getb} procedure repeatedly
to prepare the block of data.  In some cases, providing block input
can be much more efficient (e.g. suppose you're reading from
a block of memory chunk).
@c JP
この手続きは効率のためにあります。もし、この手続きが用意されて
いなければ、このポートは、データブロックを準備するのに @code{getb}を
繰り返し呼びます。場合によっては、ブロック入力を用意するほうが
はるかに効率的です。(たとえば、メモリチャンクのブロックからの読みだし
を行なうような場合です。)
@c COMMON

@c EN
You can leave this slot unset if you don't need to take such
advantage.
@c JP
こうした利点を必要としないのなら、このスロットは未設定のままにして
おいてもかまいません。
@c COMMON
@end defivar

@defivar {<virtual-input-port>} ready
@c EN
If set, the value must be a procedure that takes one boolean argument.
It is called when @code{char-ready?} or @code{byte-ready?} is
called on the port.   The value returned from your procedure will
be the result of these procedures.
@c JP
設定されているなら、その値は、真偽値をひとつだけとる手続きでなければ
なりません。この手続きは、このポートに対して、@code{char-ready?}
あるいは @code{byte-ready?} が呼ばれたときに呼出されます。設定した手続き
が返す値が、これらの手続きの結果になります。
@c COMMON

@c EN
The boolean argument is @code{#t} if
@code{char-ready?} is called, or @code{#f} if @code{byte-ready?} is called.
@c JP
@code{char-ready?} が呼ばれたのなら、真偽値引数は @code{#t} です。
@code{byte-ready?} が呼ばれたのなら、真偽値引数は @code{#f} になります。
@c COMMON

@c EN
If unset, @code{char-ready?} and @code{byte-ready?}
always return @code{#t} on the port
@c JP
未設定なら、@code{char-ready?} および @code{byte-ready?} は
このポートに対して常に、@code{#t} を返します。
@c COMMON
@end defivar

@defivar {<virtual-input-port>} close
@c EN
If set, the value must be a procedure that takes no arguments.
It is called when the port is closed.  Return value is discarded.
You can leave this unset
if you don't need to take an action when the port is closed.
@c JP
設定されているのなら、その値は引数を取らない手続きでなければなりません。
その手続きはこのポートがクローズされるときに呼びだされ、返り値は
捨てられます。このポートをクローズするときになんらかのアクションが
必要でないのなら、未設定にしておけます。
@c COMMON

@c EN
This procedure may be called from a finalizer, so you have to be
careful to write it.   See the note on finalization below.
@c JP
この手続きはファイナライザから呼ばれることもあり得ます。したがって、
この手続きは慎重に書く必要があります。後述のファイナライズに
関する注意を参照してください。
@c COMMON
@end defivar

@defivar {<virtual-input-port>} seek
@c EN
If set, the value must be a procedure that takes two arguments,
offset and whence.  The meaning of them is the same as the arguments
to @code{port-seek} (@xref{Common port operations}).
The procedure must adjust the port's internal read pointer
so that the next read begins from the new pointer.
It should return the updated pointer (the byte offset from the
beginning of the port).
@c JP
設定されているのなら、その値は、オフセット引数とそれがどこからかを示す引数
の 2つの引数をとる手続きでなければなりません。これらの引数の意味は、
@code{port-seek} (@ref{Common port operations} 参照) のそれと同じです。
この手続きは、次の読み出しが新しい位置から始められるように
内部のリードポインタを調整しなければなりません。そして
更新されたポインタ(ポート先頭からのバイトオフセット)
を返さなければなりません。
@c COMMON

@c EN
If unset, call of @code{port-seek} and @code{port-tell} on this
port will return @code{#f}.
@c JP
未設定なら、このポートに対する @code{port-seek} および @code{port-tell}
の呼び出しは @code{#f} になります。
@c COMMON

@c EN
Note that this procedure may be called for the purpose of merely
querying the current position, with 0 as @code{offset} and @code{SEEK_CUR}
as @code{whence}.  If your port knows the read pointer but cannot move it,
you can still provide this procedure, which returns the current pointer
position for such queries and returns @code{#f} for other arguments.
@c JP
この手続きは単に現在の位置を問合せるために、
@code{offset} として 0 を、@code{whence} として @code{SEEK_CUR} を与えて
呼び出すこともあることに注意してください。リードポインタの位置は知って
いるが、動かすことができないという場合にも、この手続きを提供することが
できます。上のような問合せには、現在位置を返し、そうでない場合には、
@code{#f} を返します。
@c COMMON
@end defivar

@end deftp


@deftp {Class} <virtual-output-port>
@clindex virtual-output-port
@c EN
An instance of this class can be used as an output port.
The behavior of the port depends on the settings of the
instance slot values.
@c JP
このクラスのインスタンスは出力ポートとして使えます。
このポートの振舞いはインスタンスのスロットに設定された値に依存します。
@c COMMON

@c EN
To work as an output port, at least either one of @code{putb} or
@code{putc} slot has to be set.
@c JP
まともな出力ポートとして動かすためには、少くとも、@code{putb} スロット
あるいは @code{putc} スロットのどちらか一方は設定しなければなりません。
@c COMMON

@defivar {<virtual-output-port>} putb
@c EN
If set, the value must be a procedure that takes one argument,
a byte value (exact integer between 0 and 255, inclusive).
Every time binary output is required, the procedure is called.
The return value of the procedure is ignored.
@c JP
設定されているなら、その値は、バイト値(0 から 255までの正確な整数)を
ひとつだけ引数としてとる手続きでなければなりません。バイナリ出力
の要求のたびに、この手続きが呼ばれます。この手続きの返り値は無視
されます。
@c COMMON

@c EN
If this slot is not set and binary output is requested,
the port may signal an @code{<io-unit-error>} error.
@c JP
このスロットが未設定の場合、バイナリ出力を要求されると、このポートは
@code{<io-unit-error>} エラーを発生させることがあります。
@c COMMON
@end defivar

@defivar {<virtual-output-port>} putc
@c EN
If set, the value must be a procedure that takes one argument,
a character.
Every time character output is required, the procedure is called.
The return value of the procedure is ignored.
@c JP
設定されているなら、それは文字をひとつ引数にとる手続きでなければなりません。
文字出力の要求があるたびにこの手続きがよばれます。この手続きの返り値は
無視されます。
@c COMMON

@c EN
If this slot is not set but @code{putb} slot is set,
the virtual port decomposes the character into a sequence of bytes
then calls @code{putb} procedures.
@c JP
このスロットが未設定であっても、@code{putb} スロットが設定されていれば、
この仮想ポートは文字をバイト列に展開してから、@code{putb} を呼びだします。
@c COMMON
@end defivar

@defivar {<virtual-output-port>} puts
@c EN
If set, the value must be a procedure that takes a
(possibly incomplete) string.
The return value of the procedure is ignored.
@c JP
設定されていれば、その値は、文字列(不完全なものである可能性もある)を
ひとつ引数としてとる手続きでなければなりません。この手続きの返り値は
無視されます。
@c COMMON

@c EN
This is for efficiency.  If this slot is not set, the virtual port
calls @code{putb} or @code{putc} repeatedly to output a chunk of data.
But if your code can perform chunked output efficiently, 
you can provide this procedure.
@c JP
これは、効率のためにあります。このスロットが未設定であれば、この
仮想ポートは、データのかたまりを出力するために、@code{putb} 
あるいは @code{putc} を繰り返し呼びます。もし、ひとかたまりの
出力を効率的に実行可能なコードであれば、この手続きを提供できます。
@c COMMON
@end defivar

@defivar {<virtual-output-port>} flush
@c EN
If set, the value must be a procedure that takes no arguments.
It is called when flushing a port is required (e.g. @code{flush}
is called on the port, or the port is being closed).
@c JP
設定されていれば、その値は引数をとらない手続きでなければなりません。
ポートのフラッシュを要求されたときに呼ばれます(たとえば、@code{flush}
がこのポートに対して呼ばれたとき、あるいは、このポートがクローズ
されるとき)。
@c COMMON

@c EN
This procedure is useful that your port does some sort of buffering,
or needs to keep some state.  If your port doesn't do stateful operation,
you can leave this unset.
@c JP
この手続きは、ポートが何らかのバッファリングをおこなうか、なんらかの
状態を持つような場合に便利です。ポートが状態をともなう操作を行わない
のなら、これは未設定にしておけます。
@c COMMON

@c EN
This procedure may be called from a finalizer, and needs a special
care.  See notes on finalizers below.
@c JP
この手続きはファイナライザから呼ばれることがあります。したがって、
特別な注意が必要です。後述のファイナライザに関する注意を
参照してください。
@c COMMON

@end defivar

@defivar {<virtual-output-port>} close
@c EN
The same as @code{<virtual-input-port>}'s @code{close} slot.
@c JP
@code{<virtual-input-port>} の @code{close} スロットと同様です。
@c COMMON
@end defivar

@defivar {<virtual-output-port>} seek
@c EN
The same as @code{<virtual-input-port>}'s @code{seek} slot.
@c JP
@code{<virtual-input-port>} の @code{seek} スロットと同様です。
@c COMMON
@end defivar

@end deftp

@c EN
@subsubheading Virtual buffered ports
@c JP
@subsubheading 仮想バッファポート
@c COMMON

@c EN
This type of virtual ports are realized by classes
@code{<buffered-input-port>} and @code{<buffered-output-port>}.
You can customize the port behavior by setting 
appropriate slots with procedures.
@c JP
このタイプの仮想ポートは @code{<buffered-input-port>} クラス
および @code{<buffered-output-port>} クラスで実現されています。
適切なスロットに手続きを設定するこでポートの振舞いをカスタマイズ
することができます。
@c COMMON

@c EN
Those ports have internal buffer and only calls Scheme procedures
when the buffer needs to be filled or flushed.  Generally it is 
far more efficient than calling Scheme procedures for every
I/O operation.   Actually, the internal buffering mechanism is
the same as Gauche's file I/O ports.
@c JP
これらのポートは、内部バッファを持っており、そのバッファを満たすか
フラッシュするかの必要があるときにのみ、Scheme の手続きが呼ばれます。
通常、I/O毎に Scheme の手続きを呼ぶよりも遥かに効率がいいものです。
実際の内部バッファリング機構は、GaucheのファイルI/Oポートと同じです。
@c COMMON

@c EN
These ports uses @code{u8vector} as a buffer.  See @ref{Uniform vectors}
for the details.
@c JP
これらのポートはバッファとして @code{u8vector} を使います。詳細は、
@ref{Uniform vectors} を参照してください。
@c COMMON

@deftp {Class} <buffered-input-port>
@clindex buffered-input-port

@c EN
An instance of this class behaves as an input port.
It has the following instance slots.  For a meaningful input
port, you have to set at least @code{fill} slot.
@c JP
このクラスのインスタンスは、入力ポートとして振舞います。
これは以下のようなインスタンススロットを持ちます。
意味のある入力ポートとして使うには少くとも、@code{fill} スロットを
設定しなければなりません。
@c COMMON

@defivar {<buffered-input-port>} fill
@c EN
If set, it must be a procedure that takes one argument,
a @code{u8vector}.  It must fill the data from the
beginning of the vector.  It doesn't need to fill the entire
vector if there's not so many data.  However, if there are remaining
data, it must fill at least one byte; if the data isn't readily
available, it has to wait until some data becomes available.
@c JP
設定されているなら、@code{u8vector} の引数を一つとる手続きでなければ
なりません。そのベクタの最初からデータを満たさなければなりません。
要求されたものよりデータの残りが少ない場合には、
ベクタ全体を満たす必要はありません。しかしながら、
データが残っている場合には少くとも1バイトは満たさなければなりません。
もしデータがまだ利用可能になっていなければ、なにがしかのデータが利用可能に
なるまで待たなければなりません。
@c COMMON

@c EN
The procedure must return a number of bytes it actually filled.
It may return 0 or an EOF object to indicate the port has reached EOF.
@c JP
この手続きは実際に満されたバイト数を返さなければなりません。ポートが
EOFに達したことを示すために、0 または EOFオブジェクトを返すこともできます。
@c COMMON
@end defivar

@defivar {<buffered-input-port>} ready
@c EN
If set, it must be a procedure that takes no arguments.
The procedure must return a true value if there are some data
readily available to read, or @code{#f} otherwise.
Unlike fully virtual ports, you don't need to distinguish
binary and character I/O.
@c JP
設定されているなら、引数をとらない手続きでなければなりません。
この手続きは、なにがしかの読み込み用データが利用可能になっていれば
真の値を返し、そうでなければ、@code{#f}を返します。完全仮想ポートとはちがい、
バイナリI/Oと文字I/Oを区別する必要はありません。
@c COMMON

@c EN
If this slot is not set, the port is regarded as it always has data ready.
@c JP
このスロットが未定義の場合、このポートは常にデータが利用可能になっている
とみなされます。
@c COMMON
@end defivar

@defivar {<buffered-input-port>} close
@c EN
If set, it must be a procedure that takes no arguments.
The procedure is called when the virtual buffered port is closed.
You don't need to set this slot unless you need some cleaning up
when the port is closed.
@c JP
設定されていれば、引数をとらない手続きでなければなりません。この手続きは
仮想バッファポートがクローズされるときに呼出されます。ポートがクローズ
されるときに、なにがしかのクリーンアップを行うのでなければ、設定する必要
はありません。
@c COMMON

@c EN
This procedure may be called from a finalizer, and
needs special care.  See the note on finalization below.
@c JP
この手続きは、ファイナライザから呼ばれる可能性がありますので、特別な
注意が必要です。後述のファイナライズに関する注意書きを参照してください。
@c COMMON
@end defivar

@defivar {<buffered-input-port>} filenum
@c EN
If set, it must be a procedure that returns underlying
file descriptor number (exact nonnegative integer).
The procedure is called when @code{port-file-number} is called
on the port.
@c JP
設定されているなら、このポートの使っているファイルディスクリプタ番号(正確な非負整数)
を返す手続きでなければなりません。この手続きは @code{port-file-number}
をこのポートに対して呼出したときに呼ばれます。
@c COMMON

@c EN
If there's no such underlying file descriptor, you can
return @code{#f}, or you can leave this slot unset.
@c JP
そのようなファイルディスクリプタが存在していなければ、
@code{#f} を返すことができます。
あるいは、このスロットを未設定にしておくこともできます。
@c COMMON
@end defivar

@defivar {<buffered-input-port>} seek
@c EN
If set, it must be a procedure that takes two arguments,
@var{offset} and @var{whence}.
It works the same way as @code{<virtual-input-port>}'s seek procedure;
see above.
@c JP
設定されているなら、オフセット引数とどこからかを示す引数の2つをとる
手続きでなければなりません。これは、前述の
@code{<virtual-input-port>}のseek 手続きと同じように動作します。
@c COMMON

@c EN
This procedure may be called from a finalizer, and
needs special care.  See the note on finalization below.
@c JP
この手続きはファイナライザから呼ばれる可能性があり、特別な注意が
必要です。後述のファイナライズに関する注意を参照してください。
@c COMMON
@end defivar

@end deftp

@deftp {Class} <buffered-output-port>
@clindex buffered-output-port

@c EN
An instance of this class behaves as an output port.
It has the following instance slots.
You have to set at least @code{flush} slot.
@c JP
このクラスのインスタンスは出力ポートして振舞います。これは、以下のような
インスタンススロットを持ちます。少くとも @code{flush} は設定しなければ
なりません。
@c COMMON

@defivar {<buffered-output-port>} flush
@c EN
If set, it must be a procedure that takes two arguments,
an @code{u8vector} buffer and a flag.
The procedure must output data in the buffer to somewhere,
and returns the number of bytes actually output.
@c JP
設定されているなら、@code{u8vector}のバッファとフラグという2つの
引数をとる手続きでなければなりません。手続きはバッファ内のデータを
どこかへ出力しなければならず、実際に出力したバイト数を返します。
@c COMMON

@c EN
If the flag is false, the procedure may output less
than entire buffer (but at least one byte).  If the flag
is true, the procedure must output entire buffer.
@c JP
フラグが偽なら、この手続きはバッファ全体よりも少い(ただし、最低でも
1バイト)の出力を行ってもかまいません。もしフラグが真ならば、この手続きは、
バッファの内容をすべて出力しなければなりません。
@c COMMON
@end defivar

@defivar {<buffered-output-port>} close
@c EN
Same as @code{<buffered-input-port>}'s @code{close} slot.
@c JP
@code{<buffered-input-port>} の @code{close} スロットと同様です。
@c COMMON
@end defivar

@defivar {<buffered-output-port>} filenum
@c EN
Same as @code{<buffered-input-port>}'s @code{filenum} slot.
@c JP
@code{<buffered-input-port>} の @code{filenum} スロットと同様です。
@c COMMON
@end defivar

@defivar {<buffered-output-port>} seek
@c EN
Same as @code{<buffered-input-port>}'s @code{seek} slot.
@c JP
@code{<buffered-input-port>} の @code{seek} スロットと同様です。
@c COMMON
@end defivar

@end deftp

@c EN
@subsubheading Uniform vector ports
@c JP
@subsubheading ユニフォームベクタポート
@c COMMON

@c EN
The following two procedures returns a bufferd input/output port
backed up by a uniform vector.    The source or destination vector
can be any type of uniform vector, but they are aliased
to @code{u8vector} (see @code{uvector-alias} in
@ref{Uvector conversion operations}).
@c JP
以下の 2つの手続きは、ユニフォームベクタでバックアップされた、
バッファ入/出力ポートを返します。読み込み元のベクタあるいは
書き出し相手のベクタはどのようなユニフォームベクタであってもかまいませんが、
実際の入出力時には@code{u8vector} にaliasされます
(@ref{Uvector conversion operations} の @code{uvector-alias} 参照)。
@c COMMON

@c EN
If used together with @code{pack}/@code{unpack} 
(see @ref{Packing Binary Data}), it is useful to parse
or construct binary data structure.  It is also an
example of using virtual ports; read @file{gauche/vport.scm}
(or @file{ext/vport/vport.scm} in the source tree) if you're
curious about the implementation.
@c JP
@code{pack}/@code{unpack}(@ref{Packing Binary Data}参照) と一緒に使うと
バイナリのデータ構造をパースしたり、構築したりするのに便利です。
また、仮想ポートの使い方の例でもあります。実装法に興味があれば、
ソースツリーの @file{gauche/vport.scm}(あるいは @file{ext/vport/vport.scm})
を読んでください。 
@c COMMON

@defun open-input-uvector uvector
@c EN
Returns an input port that reads the content of the given
uniform vector @var{uvector} from its beginning.  If reading
operation reaches the end of @var{uvector}, EOF is returned.
Seek operation is also implemented.
@c JP
与えられたユニフォームベクタ @var{uvector}の最初からその内容を読む
入力ポートを返します。読み込み動作が、@var{uvector}の終端に到達したら
EOFが返されます。シーク操作も実装されています。
@c COMMON
@end defun

@defun open-output-uvector uvector
@c EN
Returns an output port that fills the given uvector by the
data output to the port.  If @var{uvector} is completely
filled, more data are silently discarded.
Seek operation is also implemented.
@c JP
与えられた uvector をポートへのデータ出力で満たす出力ポートを返します。
@var{uvector}が満杯になれば、それ以上のデータは黙って廃棄されます。
シーク操作も実装されています。
@c COMMON
@end defun

@c EN
@subsubheading Note on finalization
@c JP
@subsubheading ファイナライズに関する注意
@c COMMON

@c EN
If an unclosed virtual port is garbage collected, its close procedure
is called (in case of virtual buffered ports, its flush procedure
may also be called before close procedure).  It is done by
a finalizer of the port.  Since it is a part of garbage-collection
process (although the Scheme procedure itself is called outside of
the garbage collector main part), it requires special care.
@c JP
クローズされていない仮想ポートがガベージ・コレクションされると、
クローズ手続きが呼ばれます(仮想バッファポートの場合は、
フラッシュ手続きがクローズ手続きの前に呼ばれます)。これは、
そのポートのファイナライザによって行われます。これはガベージ・コレクション
処理の一部ですから(Scheme 手続きそのものはガーベッジ・コレクタの
メインパートの外側で呼ばれているのですが、それでも)特別な注意が必要です。
@c COMMON

@itemize @bullet
@item
@c EN
It is possible that the object the virtual port has a reference
may already be finalized.  For example, if a virtual port @var{X} 
holds the only reference to a @emph{sink} port @var{Y}, to which
the output goes.  @var{X}'s @code{flush} procedure sends its output to
@var{Y}.  However, if @code{flush} procedure can be called from a
finalizer, it may be possible that @var{Y}'s finalizer has already been
called and @var{Y} is closed.   So @var{X}'s @code{flush} procedure
has to check if @var{Y} has not been closed.
@c JP
仮想ポートが参照しているオブジェクトが既にファイナライズされて
しまっているということがあり得ます。たとえば、仮想ポート @var{X}
は、@emph{流し込み用}のポート @var{Y} への唯一の参照を保持しており、それに
出力するものとします。@var{X}の @code{flush} 手続きは、その出力を
@var{Y}へ送ります。もし@code{flush} 手続きがファイナライザから
呼ばれた場合、@var{Y} のファイナライザが既に
呼ばれていて、@var{Y} がクローズしてしまっていることがあるのです。
従って @var{X} の @code{flush} 手続きは、@var{Y} が既にクローズして
いるかどうかをチェックする必要があります。
@c COMMON

@item
@c EN
You cannot know when and in which thread the finalizer runs.  
So if the procedure like @code{close} or @code{flush} of virtual ports
need to lock or access the global resource, it needs to take
extra care of avoiding dead lock or conflict of access.
@c JP
いつ、どのスレッドでファイナライザが走るかを知ることはできません。
それゆえ、仮想ポートの @code{close} あるいは @code{flush} などの
手続きが、グローバルなリソースをロックしたり、アクセスしたりする
必要のある場合には、デッドロックやアクセスの衝突を回避するために
特に注意する必要があります。
@c COMMON

@c EN
Even in single thread programs, the finalizer can run anywhere
in Scheme programs, so effectively it should be considered as
running in a different thread.
@c JP
単一スレッドのプログラムにおいても、ファイナライザは、Schemeの
プログラムのいたるところで走る可能性があります。したがって、実質的に
それは別のスレッドで走っていると考えておくべきです。
@c COMMON
@end itemize
