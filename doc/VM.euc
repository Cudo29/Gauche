VMの実装

フレームの実装

* 最も簡単なのは、環境もコンティニュエーションもヒープに置いてしまう方針。
  Appelによれば、コンパイラが賢ければこれでも速いそうな。
  Pythonでフレームをヒープに置いた例もあり <http://www.stackless.com/spcpaper.htm>
  効率は悪くなかったとされている。

  この方法のメリットは実装が簡単なことと、コンティニュエーションの捕捉に
  ペナルティが全く無いこと。

  しかしフレームは最も頻繁に作られるオブジェクトであり、そのほとんどは一時的に
  しか使われない。Clinger88 や Hieb90、Kelsey93 等ではスタックベースの
  アプローチの優位性が示されている

  (但し、Kelsey93でも示唆されているように、インタプリタの効率が悪ければ
  フレームをヒープに置くペナルティは相対的に目立たなくなる)

* スタックを用いる場合、クロージャの作成やコンティニュエーションの作成または
  リストアの際にスタックエリアのコピーが必要になる。Burson94に示される方法は
  コピーの必要が無いので興味深いが、戻り値の置き方を工夫しないとならない。

* スタックはまたmultiple return valueと相性が良い。
   
* どのアプローチを取るにせよ、Cスタックには手をつけたく無い、つまり
  Scheme->C->Schemeというコールはなるべく避け、さらにそういう場合を
  検出可能にする。

* どの方法が良いのかというのは実際に使ってみなくてはわからない面も多分に
  あるので、vmだけ後ですげ替えられるように実装しておくのが良かろう。

* 一つの関数の「環境」は、引数及びローカル変数。引数の数はcallerが知っていて、
  ローカル変数の数はcalleeしか知らない。Cなんかだと単一のフレームポインタで
  両方にアクセスしている。スタックモデルなら同様にできるんだが、環境をヒープに
  置く場合はどないする?

  特にCLOSライクなメソッドディスパッチを行う場合、引数全てが確定しないと呼び出し
  関数が分からないから、引数の評価を開始する前にフレームをアロケートすることは
  出来ない。

  スタックエリアに積んどいてコピーするって手はあるけどそれもいやーんだな。
  それならスタックモデルを素直に使った方が良い。

  最もプリミティブな方法は引数もローカル変数もリストを使うというもの。
  フレームの大きさに縛られることはないし、コンスセルのアロケーションは
  最適化できる。でもなあ…

  o 固定長フレーム使用(オーバーしたら別途alloc)
  o 引数フレームとローカルフレームは分ける
  o 関数は引数ポインタを受け取る

  引数フレーム： numargs, env, arg0 ... argN

  ローカル変数が必要になったらローカルフレームを作成


  VMは envp, argp, 


* いっそのこと、スタックモデルに徹してみるか。

  通常の呼び出しシーケンスは何にも問題はない。

  呼び出し側は引数を積み、コンティニュエーションを積み、関数を呼ぶ。
  呼ばれた側はローカル変数分の領域を確保してボディの評価を行う。

  呼び出しの中間結果 (例： (F a (G b)) における(G b) の結果) は
  スタックにそのまま残しておけるのがこの方法のメリット。

  ところで、呼ばれた側でクロージャの作成が起きたらどうなるか。
  素直なのは、この時点での自分のフレームをヒープにコピーすることである。
  それ以降にフレームを拡張する必要がある場合は、スタック上に拡張して
  リンクを張る。

* さてさて。コンティニュエーションである。Burson94 の方法では、一度
  捕捉されたコンティニュエーションフレームはポップできないので、
  途中まで引数が積まれた状態で捕まった継続を再開するのが難しい。

