#! /bin/sh
#
# Generate uvector.h
#
#  $Id: uvector.h.sh,v 1.2 2001-02-19 14:48:49 shiro Exp $
#

cat <<EOF
/*
 * uvector - uniform (homogeneous) numeric vector types (SRFI-4)
 *
 *  Copyright(C) 1999-2001 by Shiro Kawai (shiro@acm.org)
 *
 *  Permission to use, copy, modify, distribute this software and
 *  accompanying documentation for any purpose is hereby granted,
 *  provided that existing copyright notices are retained in all
 *  copies and that this notice is included verbatim in all
 *  distributions.
 *  This software is provided as is, without express or implied
 *  warranty.  In no circumstances the author(s) shall be liable
 *  for any damages arising out of the use of this software.
 *
 *  This file is automatically generated.  DO NOT EDIT.
 *  \$Id: uvector.h.sh,v 1.2 2001-02-19 14:48:49 shiro Exp $
 */

#ifndef GAUCHE_UVECTOR_H
#define GAUCHE_UVECTOR_H

#include <gauche.h>

/*
 * This header file is for other extension modules which need
 * to access uniform vectors in C level.
 */
EOF

#
# emit vecttype itemtype
#
emit() {
    vecttype=$1
    itemtype=$2
    extrafns=$3
    VECTTYPE=`echo $vecttype | tr '[a-z]' '[A-Z]'`
    cat <<EOF

/* ${vecttype} */

typedef struct Scm${vecttype}Rec {
    SCM_HEADER;
    u_long length;
    $itemtype data[1];
} Scm${vecttype};

extern ScmClass Scm_${vecttype}Class;
#define SCM_CLASS_${VECTTYPE}  (&Scm_${vecttype}Class)

#define SCM_${VECTTYPE}(obj)        ((Scm${vecttype}*)(obj))
#define SCM_${VECTTYPE}P(obj)       SCM_XTYPEP(obj, SCM_CLASS_${VECTTYPE})
#define SCM_${VECTTYPE}_LENGTH(obj) SCM_${VECTTYPE}(obj)->length
#define SCM_${VECTTYPE}_DATA(obj)   SCM_${VECTTYPE}(obj)->data

extern ScmObj Scm_Make${vecttype}(int length, ${itemtype} fill);
extern ScmObj Scm_Make${vecttype}FromArray(int length, ${itemtype} array[]);
extern ScmObj Scm_${vecttype}Fill(Scm${vecttype} *vec, ${itemtype} fill);
extern ScmObj Scm_${vecttype}Ref(Scm${vecttype} *vec, int index);
extern ScmObj Scm_${vecttype}Set(Scm${vecttype} *vec, int index, ScmObj val);
extern ScmObj Scm_${vecttype}ToList(Scm${vecttype} *vec);
extern ScmObj Scm_ListTo${vecttype}(ScmObj list);
extern ScmObj Scm_${vecttype}Copy(Scm${vecttype} *vec);
extern ScmObj Scm_${vecttype}CopyX(Scm${vecttype} *dst, Scm${vecttype} *src);
extern ScmObj Scm_${vecttype}ToVector(Scm${vecttype} *vec);
extern ScmObj Scm_VectorTo${vecttype}(ScmVector *vec);

EOF
    if [ "$extrafns" = 1 ]; then
        cat <<EOF
extern ScmObj Scm_${vecttype}Scale(Scm${vecttype} *vec, ${itemtype} factor);
extern ScmObj Scm_${vecttype}ScaleX(Scm${vecttype} *vec, ${itemtype} factor);
extern ScmObj Scm_${vecttype}Add2(Scm${vecttype} *x, Scm${vecttype} *y);
extern ScmObj Scm_${vecttype}AddX2(Scm${vecttype} *x, Scm${vecttype} *y);
extern ScmObj Scm_${vecttype}SubX2(Scm${vecttype} *x, Scm${vecttype} *y);
extern ScmObj Scm_${vecttype}DotProduct(Scm${vecttype} *x, Scm${vecttype} *y);
extern ScmObj Scm_${vecttype}CrossProduct(Scm${vecttype} *x, Scm${vecttype} *y);
EOF
    fi
}


emit S8Vector  "signed char"
emit U8Vector  "unsigned char"

emit S16Vector "signed short"
emit U16Vector "unsigned short"

emit S32Vector "signed long"
emit U32Vector "unsigned long"

# TODO: check 64bit architecture
cat <<EOF
typedef struct { signed long upper;   signed long lower; }   ScmInt64;
typedef struct { unsigned long upper; unsigned long lower; } ScmUInt64;
EOF

emit S64Vector "ScmInt64"
emit U64Vector "ScmUInt64"

emit F32Vector "float"  1
emit F64Vector "double" 1

cat <<EOF

#endif /* GAUCHE_UVECTOR_H */
EOF
