;;;
;;; stdlib.stub - r5rs scheme procedures
;;;  
;;;   Copyright (c) 2000-2004 Shiro Kawai, All rights reserved.
;;;   
;;;   Redistribution and use in source and binary forms, with or without
;;;   modification, are permitted provided that the following conditions
;;;   are met:
;;;   
;;;   1. Redistributions of source code must retain the above copyright
;;;      notice, this list of conditions and the following disclaimer.
;;;  
;;;   2. Redistributions in binary form must reproduce the above copyright
;;;      notice, this list of conditions and the following disclaimer in the
;;;      documentation and/or other materials provided with the distribution.
;;;  
;;;   3. Neither the name of the authors nor the names of its contributors
;;;      may be used to endorse or promote products derived from this
;;;      software without specific prior written permission.
;;;  
;;;   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
;;;   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
;;;   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
;;;   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
;;;   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
;;;   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
;;;   TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
;;;   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
;;;   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
;;;   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
;;;   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;;;  
;;; $Id: stdlib.stub,v 1.108.2.2 2005-01-09 04:28:49 shirok Exp $
;;;


"
#include <gauche/vminsn.h>
#include <stdlib.h>
#include <ctype.h>
#include <math.h>

#ifndef M_PI
#define M_PI 3.1415926535897932384
#endif
"

;;
;; 6.1  Equivalence predicates
;;

(define-cproc eqv? (obj1 obj2)
  (inliner "SCM_VM_EQV")
  (return <boolean> "Scm_EqvP"))

(define-cproc eq? (obj1 obj2)
  (inliner "SCM_VM_EQ")
  (return <boolean> "SCM_EQ"))

(define-cproc equal? (obj1 obj2)
  (return <boolean> "Scm_EqualP"))

;;
;; 6.2  Numbers
;;

(define-cproc number? (obj)   (return <boolean> "SCM_NUMBERP"))
(define-cproc complex? (obj)  (return <boolean> "SCM_NUMBERP"))
(define-cproc real? (obj)     (return <boolean> "SCM_REALP"))
(define-cproc rational? (obj) (return <boolean> "SCM_REALP"))
(define-cproc integer? (obj)
  "  if (!SCM_NUMBERP(obj)) SCM_RETURN(SCM_FALSE);
  else SCM_RETURN(SCM_MAKE_BOOL(Scm_IntegerP(obj)));")

(define-cproc exact? (obj)    (return <boolean> "SCM_EXACTP"))
(define-cproc inexact? (obj)  (return <boolean> "SCM_INEXACTP"))

(define-cproc = (arg0 arg1 &rest args)
  (inliner (case-nargs (2 "SCM_VM_NUMEQ2") (else #f)))
  "  for (;;) {
  if (!Scm_NumEq(arg0, arg1)) return SCM_FALSE;
  if (SCM_NULLP(args)) return SCM_TRUE;
  arg1 = SCM_CAR(args); args = SCM_CDR(args);
  }")

(define-cproc < (arg0 arg1 &rest args)
  (inliner (case-nargs (2 "SCM_VM_NUMLT2") (else #f)))
  "  for (;;) {
  if (Scm_NumCmp(arg0, arg1) >= 0) return SCM_FALSE;
  if (SCM_NULLP(args)) return SCM_TRUE;
  arg0 = arg1;  arg1 = SCM_CAR(args);  args = SCM_CDR(args);
  }")

(define-cproc <= (arg0 arg1 &rest args)
  (inliner (case-nargs (2 "SCM_VM_NUMLE2") (else #f)))
  "  for (;;) {
  if (Scm_NumCmp(arg0, arg1) > 0) return SCM_FALSE;
  if (SCM_NULLP(args)) return SCM_TRUE;
  arg0 = arg1;  arg1 = SCM_CAR(args);  args = SCM_CDR(args);
  }")

(define-cproc > (arg0 arg1 &rest args)
  (inliner (case-nargs (2 "SCM_VM_NUMGT2") (else #f)))
  "  for (;;) {
  if (Scm_NumCmp(arg0, arg1) <= 0) return SCM_FALSE;
  if (SCM_NULLP(args)) return SCM_TRUE;
  arg0 = arg1;  arg1 = SCM_CAR(args);  args = SCM_CDR(args);
  }")

(define-cproc >= (arg0 arg1 &rest args)
  (inliner (case-nargs (2 "SCM_VM_NUMGE2") (else #f)))
  "  for (;;) {
  if (Scm_NumCmp(arg0, arg1) < 0) return SCM_FALSE;
  if (SCM_NULLP(args)) return SCM_TRUE;
  arg0 = arg1;  arg1 = SCM_CAR(args);  args = SCM_CDR(args);
  }")

(define-cproc zero? (obj)
  "if (SCM_COMPLEXP(obj))
       SCM_RETURN(SCM_MAKE_BOOL(SCM_COMPLEX_IMAG(obj) == 0.0));
  else SCM_RETURN(SCM_MAKE_BOOL(Scm_Sign(obj) == 0));")
(define-cproc positive? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_Sign(obj) > 0));")
(define-cproc negative? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_Sign(obj) < 0));")
(define-cproc odd? (obj)   (return <boolean> "Scm_OddP"))
(define-cproc even? (obj)  (return <boolean> "!Scm_OddP"))

(define-cproc max (arg0 &rest args)
  "ScmObj r; Scm_MinMax(arg0, args, NULL, &r); SCM_RETURN(r);")
(define-cproc min (arg0 &rest args)
  "ScmObj r; Scm_MinMax(arg0, args, &r, NULL); SCM_RETURN(r);")

"/* inliner for `+' */
static ScmObj immediate_integer_inliner(long insn, long arg0, ScmObj arg1, ScmObj env)
{
  return Scm_MakeInlineAsmForm(SCM_NIL, SCM_VM_INSN1(insn, arg0), SCM_LIST1(arg1));
}

static ScmObj num2op_inliner(long insn, ScmObj arg0, ScmObj arg1, ScmObj env)
{
  ScmObj args = SCM_LIST2(arg0, arg1);
  return Scm_MakeInlineAsmForm(Scm_Cons(SCM_FALSE, args),
                               SCM_VM_INSN(insn), args);
}

static ScmObj plus_inliner(ScmObj subr, ScmObj form, ScmObj env, void *data)
{
  ScmObj args = SCM_CDR(form), arg0, arg1;
  long imm;
  if (Scm_Length(form) != 3) return SCM_FALSE;
  arg0 = SCM_CAR(args);
  arg1 = SCM_CADR(args);
  if (SCM_INTP(arg0)) {
    if (SCM_INTP(arg1)) {
      return(Scm_MakeInteger(SCM_INT_VALUE(arg0)+SCM_INT_VALUE(arg1)));
    }
    imm = SCM_INT_VALUE(arg0);
    if (SCM_VM_INSN_ARG_FITS(imm))
      return immediate_integer_inliner(SCM_VM_NUMADDI, imm, arg1, env);
  } else if (SCM_INTP(arg1)) {
    imm = SCM_INT_VALUE(arg1);
    if (SCM_VM_INSN_ARG_FITS(imm))
      return immediate_integer_inliner(SCM_VM_NUMADDI, imm, arg0, env);
  }
  return num2op_inliner(SCM_VM_NUMADD2, arg0, arg1, env);
}

static ScmObj minus_inliner(ScmObj subr, ScmObj form, ScmObj env, void *data)
{
  ScmObj args = SCM_CDR(form), arg0, arg1;
  long imm;
  if (Scm_Length(form) != 3) return SCM_FALSE;
  arg0 = SCM_CAR(args);
  arg1 = SCM_CADR(args);
  if (SCM_INTP(arg0)) {
    if (SCM_INTP(arg1)) {
      return(Scm_MakeInteger(SCM_INT_VALUE(arg0)-SCM_INT_VALUE(arg1)));
    }
    imm = SCM_INT_VALUE(arg0);
    if (SCM_VM_INSN_ARG_FITS(imm))
      return immediate_integer_inliner(SCM_VM_NUMSUBI, imm, arg1, env);
  } else if (SCM_INTP(arg1)) {
    imm = SCM_INT_VALUE(arg1);
    if (SCM_VM_INSN_ARG_FITS(imm))
      return immediate_integer_inliner(SCM_VM_NUMADDI, -imm, arg0, env);
  }
  return num2op_inliner(SCM_VM_NUMSUB2, arg0, arg1, env);
}

"

(define-cproc + (&rest args)
;  (inliner (case-nargs (2 "SCM_VM_NUMADD2") (else #f)))
  (inliner (proc "plus_inliner"))
  "  if (SCM_NULLP(args)) SCM_RETURN(SCM_MAKE_INT(0));
  if (!SCM_PAIRP(SCM_CDR(args))) {
    if (!SCM_NUMBERP(SCM_CAR(args)))
      Scm_Error(\"number required, but got %S\", SCM_CAR(args));
    SCM_RETURN(SCM_CAR(args));
  } else {
    SCM_RETURN(Scm_Add(SCM_CAR(args), SCM_CADR(args), SCM_CDDR(args)));
  }")

(define-cproc * (&rest args)
  "  if (!SCM_PAIRP(args)) return SCM_MAKE_INT(1);
  if (!SCM_PAIRP(SCM_CDR(args))) {
    if (!SCM_NUMBERP(SCM_CAR(args)))
      Scm_Error(\"number required, but got %S\", SCM_CAR(args));
      return SCM_CAR(args);
    }
  SCM_RETURN(Scm_Multiply(SCM_CAR(args), SCM_CADR(args), SCM_CDDR(args)));")

(define-cproc - (arg1 &rest args)
;  (inliner (case-nargs (2 "SCM_VM_NUMSUB2") (else #f)))
  (inliner (proc "minus_inliner"))
  "  ScmObj r;
  if (SCM_NULLP(args)) r = Scm_Negate(arg1);
  else r = Scm_Subtract(arg1, SCM_CAR(args), SCM_CDR(args));
  SCM_RETURN(r);")

(define-cproc / (arg1 &rest args)
  "  ScmObj r;
  if (SCM_NULLP(args)) r = Scm_Reciprocal(arg1);
  else r = Scm_Divide(arg1, SCM_CAR(args), SCM_CDR(args));
  SCM_RETURN(r);")

(define-cproc abs (obj) (return "Scm_Abs"))

(define-cproc quotient (n1 n2)
  "  SCM_RETURN(Scm_Quotient(n1, n2, NULL));")
(define-cproc remainder (n1 n2)
  "  SCM_RETURN(Scm_Modulo(n1, n2, TRUE));")
(define-cproc modulo (n1 n2)
  "  SCM_RETURN(Scm_Modulo(n1, n2, FALSE));")

;; gcd, lcd, numerator, denominator - in gauche/numeric.scm

(define-cproc floor (v)
  "  SCM_RETURN(Scm_Round(v, SCM_ROUND_FLOOR));")
(define-cproc ceiling (v)
  "  SCM_RETURN(Scm_Round(v, SCM_ROUND_CEIL));")
(define-cproc truncate (v)
  "  SCM_RETURN(Scm_Round(v, SCM_ROUND_TRUNC));")
(define-cproc round (v)
  "  SCM_RETURN(Scm_Round(v, SCM_ROUND_ROUND));")

;; rationalize - not implemented


;; Transcedental functions.  Complex numbers are handled in Scheme.

(define-cproc %exp (x::<real>) (return <real> "exp"))

(define-cproc %log (x)
  "  int sign;
  if (!SCM_REALP(x)) Scm_Error(\"real number required, but got %S\", x);
  sign = Scm_Sign(x);
  if (sign < 0)
    SCM_RETURN(Scm_MakeComplex(log(-Scm_GetDouble(x)), M_PI));
  else
    /* NB: I intentionally delegate handling of the case x==0.0 to the
       system log() function.  Most systems should yield NaN or Inf. */
    SCM_RETURN(Scm_MakeFlonum(log(Scm_GetDouble(x))));")

(define-cproc %sin (x::<real>) (return <real> "sin"))
(define-cproc %cos (x::<real>) (return <real> "cos"))
(define-cproc %tan (x::<real>) (return <real> "tan"))
(define-cproc %asin (x::<real>)
  "if (x > 1.0) {
    SCM_RETURN(Scm_MakeComplex(M_PI/2.0, -log(x + sqrt(x*x-1.0))));
  } else if (x < -1.0) {
    SCM_RETURN(Scm_MakeComplex(-M_PI/2.0, -log(-x - sqrt(x*x-1.0))));
  } else {
    SCM_RETURN(Scm_MakeFlonum(asin(x)));
  }")
(define-cproc %acos (x::<real>)
  "if (x > 1.0) {
    SCM_RETURN(Scm_MakeComplex(0, log(x + sqrt(x*x-1.0))));
  } else if (x < -1.0) {
    SCM_RETURN(Scm_MakeComplex(M_PI, log(-x - sqrt(x*x-1.0))));
  } else {
    SCM_RETURN(Scm_MakeFlonum(acos(x)));
  }")

(define-cproc %atan (z::<real> &optional x)
  "if (x == SCM_UNBOUND) {
     SCM_RETURN(Scm_MakeFlonum(atan(z)));
  } else {
     if (!SCM_REALP(x)) Scm_Error(\"real number required for x, but got %S\", x);
     SCM_RETURN(Scm_MakeFlonum(atan2(z, Scm_GetDouble(x))));
  }")

(define-cproc %sinh (x::<real>) (return <real> "sinh"))
(define-cproc %cosh (x::<real>) (return <real> "cosh"))
(define-cproc %tanh (x::<real>) (return <real> "tanh"))
;; NB: asinh and acosh are not in POSIX.

(define-cproc %sqrt (x::<real>)
  "if (x < 0) SCM_RETURN(Scm_MakeComplex(0.0, sqrt(-x)));
  else        SCM_RETURN(Scm_MakeFlonum(sqrt(x)));")

(define-cproc %expt (x y) (return "Scm_Expt"))

(define-cproc make-rectangular (a::<real> b::<real>)
  "if (b == 0.0) SCM_RETURN(Scm_MakeFlonum(a));
  else SCM_RETURN(Scm_MakeComplex(a, b));")

(define-cproc make-polar (r::<real> t::<real>)
  (return "Scm_MakeComplexPolar"))

(define-cproc %complex->real/imag (z)
  "  if (SCM_EXACTP(z)) { SCM_RETURN(Scm_Values2(z, SCM_MAKE_INT(0))); }
  else if (SCM_FLONUMP(z)) { SCM_RETURN(Scm_Values2(z, Scm_MakeFlonum(0.0))); }
  else if (!SCM_COMPLEXP(z)) {
    Scm_Error(\"number required, but got %S\", z);
    SCM_RETURN(SCM_UNDEFINED);
  } else { SCM_RETURN(Scm_Values2(Scm_MakeFlonum(SCM_COMPLEX_REAL(z)), Scm_MakeFlonum(SCM_COMPLEX_IMAG(z))));}")
    
;; real-part, imag-part - defined in gauche/numeric.scm

(define-cproc magnitude (z)  (return "Scm_Magnitude"))
(define-cproc angle (z)      (return "Scm_Angle"))

(define-cproc exact->inexact (obj) (return "Scm_ExactToInexact"))
(define-cproc inexact->exact (obj) (return "Scm_InexactToExact"))

(define-cproc number->string (obj
                              &optional (radix::<fixnum> 10) (use-upper? #f))
  "  SCM_RETURN(Scm_NumberToString(obj, radix, !SCM_FALSEP(use_upperP)));")

(define-cproc string->number (obj::<string> &optional (radix::<fixnum> 10))
  "  SCM_RETURN(Scm_StringToNumber(obj, radix, FALSE));")

;;
;; 6.3.1  Booleans
;;

(define-cproc not (obj)
  (inliner "SCM_VM_NOT")
  (return <boolean> "SCM_FALSEP"))

(define-cproc boolean? (obj)
  (return <boolean> "SCM_BOOLP"))

;;
;; 6.3.2  Pairs and lists
;;

(define-cproc pair? (obj)
  (inliner "SCM_VM_PAIRP")
  (return <boolean> "SCM_PAIRP"))

(define-cproc cons (obj1 obj2)
  (inliner "SCM_VM_CONS")
  (return "Scm_Cons"))

(define-cproc car (obj::<pair>)
  (inliner "SCM_VM_CAR")
  (return "SCM_CAR")
  (setter set-car!))

(define-cproc cdr (obj::<pair>)
  (inliner "SCM_VM_CDR")
  (return "SCM_CDR")
  (setter set-cdr!))

(define-cproc set-car! (obj::<pair> value)
  (return void "SCM_SET_CAR"))

(define-cproc set-cdr! (obj::<pair> value)
  (return void "SCM_SET_CDR"))

"#define CXR_SETTER(PRE, pre, tail) \\
  ScmObj cell = Scm_C##tail##r(obj); \\
  if (!SCM_PAIRP(cell)) Scm_Error(\"can't set c\" #pre #tail \"r of %S\", obj); \\
  SCM_SET_C##PRE##R(cell, value); SCM_RETURN(SCM_UNDEFINED);
"

"static ScmObj cxxr_inliner(ScmObj form, ScmObj env,
                            const char *name, int insn1, int insn2)
 {
   ScmObj step1;
   if (Scm_Length(form) != 2)
     Scm_Error(\"%s requires exactly one argument\", name);
   step1 = Scm_MakeInlineAsmForm(form, SCM_VM_INSN(insn1), SCM_CDR(form));
   return Scm_MakeInlineAsmForm(form, SCM_VM_INSN(insn2), SCM_LIST1(step1));
 }
 static ScmObj caar_inliner(ScmObj subr, ScmObj form, ScmObj env, void *data)
 { return cxxr_inliner(form, env, \"caar\", SCM_VM_CAR, SCM_VM_CAR); }
 static ScmObj cadr_inliner(ScmObj subr, ScmObj form, ScmObj env, void *data)
 { return cxxr_inliner(form, env, \"cadr\", SCM_VM_CDR, SCM_VM_CAR); }
 static ScmObj cdar_inliner(ScmObj subr, ScmObj form, ScmObj env, void *data)
 { return cxxr_inliner(form, env, \"cdar\", SCM_VM_CAR, SCM_VM_CDR); }
 static ScmObj cddr_inliner(ScmObj subr, ScmObj form, ScmObj env, void *data)
 { return cxxr_inliner(form, env, \"cddr\", SCM_VM_CDR, SCM_VM_CDR); }
"

(define-cproc caar (obj)
  (inliner (proc "caar_inliner")) "SCM_RETURN(Scm_Caar(obj));"
  (setter (obj value) "CXR_SETTER(A, a, a);"))
(define-cproc cadr (obj)
  (inliner (proc "cadr_inliner")) "SCM_RETURN(Scm_Cadr(obj));"
  (setter (obj value) "CXR_SETTER(A, a, d);"))
(define-cproc cdar (obj)
  (inliner (proc "cdar_inliner")) "SCM_RETURN(Scm_Cdar(obj));"
  (setter (obj value) "CXR_SETTER(D, d, a);"))
(define-cproc cddr (obj)
  (inliner (proc "cddr_inliner")) "SCM_RETURN(Scm_Cddr(obj));"
  (setter (obj value) "CXR_SETTER(D, d, d);"))
;; NB: caaar ... cddddr are in autoloaded Scheme file now.

(define-cproc null? (obj)
  (inliner "SCM_VM_NULLP")
  (return <boolean> "SCM_NULLP"))

(define-cproc list? (obj)
  (return <boolean> "SCM_PROPER_LIST_P"))

(define-cproc list (&rest args)
  (inliner "SCM_VM_LIST")
  "  SCM_RETURN(args);")

(define-cproc length (list)
  "  int i = Scm_Length(list);
  if (i < 0) Scm_Error(\"bad list: %S\", list);
  SCM_RETURN(Scm_MakeInteger(i));")

(define-cproc append (&rest lists)
  (inliner "SCM_VM_APPEND")
  (return "Scm_Append"))

(define-cproc reverse (list::<list>)
  (inliner "SCM_VM_REVERSE")
  (return "Scm_Reverse"))

(define-cproc list-tail (list k::<fixnum>)
  (return "Scm_ListTail"))

(define-cproc list-ref (list k::<fixnum> &optional fallback)
  (return "Scm_ListRef"))

(define-cproc memq (obj list::<list>)
  (inliner "SCM_VM_MEMQ")
  (return "Scm_Memq"))

(define-cproc memv (obj list::<list>)
  (inliner "SCM_VM_MEMV")
  (return "Scm_Memv"))

(define-cproc member (obj list::<list>)
  "  SCM_RETURN(Scm_Member(obj, list, SCM_CMP_EQUAL));")

(define-cproc assq (obj alist::<list>)
  (inliner "SCM_VM_ASSQ")
  (return "Scm_Assq"))

(define-cproc assv (obj alist::<list>)
  (inliner "SCM_VM_ASSV")
  (return "Scm_Assv"))

(define-cproc assoc (obj alist::<list>)
  "  SCM_RETURN(Scm_Assoc(obj, alist, SCM_CMP_EQUAL));")

;;
;; 6.3.3  Symbols
;;

(define-cproc symbol? (obj)
  (inliner "SCM_VM_SYMBOLP")
  (return <boolean> "SCM_SYMBOLP"))

(define-cproc symbol->string (obj::<symbol>)
  "  SCM_RETURN(SCM_OBJ(SCM_SYMBOL_NAME(obj)));")

(define-cproc string->symbol (obj::<string>)
  (return "Scm_Intern"))

;;
;; 6.3.4  Characters
;;

(define-cproc char? (obj)
  (inliner "SCM_VM_CHARP")
  (return <boolean> "SCM_CHARP"))

(define-cproc char=? (c1::<char> c2::<char>) (return <boolean> "SCM_EQ"))
(define-cproc char<? (c1::<char> c2::<char>)
  "  SCM_RETURN(SCM_MAKE_BOOL(c1 < c2));")
(define-cproc char>? (c1::<char> c2::<char>)
  "  SCM_RETURN(SCM_MAKE_BOOL(c1 > c2));")
(define-cproc char<=? (c1::<char> c2::<char>)
  "  SCM_RETURN(SCM_MAKE_BOOL(c1 <= c2));")
(define-cproc char>=? (c1::<char> c2::<char>)
  "  SCM_RETURN(SCM_MAKE_BOOL(c1 >= c2));")

(define-cproc char-ci=? (c1::<char> c2::<char>)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_EQ(SCM_CHAR_UPCASE(c1),SCM_CHAR_UPCASE(c2))));")
(define-cproc char-ci<? (c1::<char> c2::<char>)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_CHAR_UPCASE(c1)<SCM_CHAR_UPCASE(c2)));")
(define-cproc char-ci<=? (c1::<char> c2::<char>)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_CHAR_UPCASE(c1)<=SCM_CHAR_UPCASE(c2)));")
(define-cproc char-ci>? (c1::<char> c2::<char>)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_CHAR_UPCASE(c1)>SCM_CHAR_UPCASE(c2)));")
(define-cproc char-ci>=? (c1::<char> c2::<char>)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_CHAR_UPCASE(c1)>=SCM_CHAR_UPCASE(c2)));")

(define-cproc char-alphabetic? (c::<char>)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_CHAR_ASCII_P(c)&&isalpha(c)));")
(define-cproc char-numeric? (c::<char>)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_CHAR_ASCII_P(c)&&isdigit(c)));")
(define-cproc char-whitespace? (c::<char>)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_CHAR_ASCII_P(c)&&isspace(c)));")
(define-cproc char-upper-case? (c::<char>)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_CHAR_UPPER_P(c)));")
(define-cproc char-lower-case? (c::<char>)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_CHAR_LOWER_P(c)));")

(define-cproc char->integer (c::<char>)
  "  SCM_RETURN(SCM_MAKE_INT((signed long)c));")

(define-cproc integer->char (c::<int>)
  "  SCM_RETURN(SCM_MAKE_CHAR((ScmChar)c));")

(define-cproc char-upcase (c::<char>)
  "  SCM_RETURN(SCM_MAKE_CHAR(SCM_CHAR_UPCASE(c)));")

(define-cproc char-downcase (c::<char>)
  "  SCM_RETURN(SCM_MAKE_CHAR(SCM_CHAR_DOWNCASE(c)));")

;;
;; 6.3.5 Strings
;;

(define-cproc string? (obj)
  (inliner "SCM_VM_STRINGP")
  (return <boolean> "SCM_STRINGP"))

(define-cproc make-string (len::<fixnum> &optional (c::<char> #\ ))
  (return "Scm_MakeFillString"))

(define-cproc string (&rest chars)
  (return "Scm_ListToString"))

(define-cproc string-length (str::<string>)
  (return <fixnum> "SCM_STRING_LENGTH"))

(define-cproc string-ref (str::<string> k::<fixnum> &optional fallback)
  (setter string-set!)
  "if (k < 0 || k >= SCM_STRING_LENGTH(str)) {
    if (SCM_UNBOUNDP(fallback)) {
      Scm_Error(\"index out of bounds: %d\", k);
    } else {
      SCM_RETURN(fallback);
    }
  }
  SCM_RETURN(SCM_MAKE_CHAR(Scm_StringRef(str, k)));")

(define-cproc string-set! (str::<string> k::<fixnum> c::<char>)
  "  ScmObj r = Scm_StringSet(str, k, c);
  if (r == SCM_FALSE) Scm_Error(\"argument out of range: %d\", k);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc string=? (s1::<string> s2::<string>)
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_StringEqual(s1, s2)));")
(define-cproc string<? (s1::<string> s2::<string>)
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_StringCmp(s1, s2) < 0));")
(define-cproc string<=? (s1::<string> s2::<string>)
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_StringCmp(s1, s2) <= 0));")
(define-cproc string>? (s1::<string> s2::<string>)
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_StringCmp(s1, s2) > 0));")
(define-cproc string>=? (s1::<string> s2::<string>)
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_StringCmp(s1, s2) >= 0));")

(define-cproc string-ci=? (s1::<string> s2::<string>)
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_StringCiCmp(s1, s2) == 0));")
(define-cproc string-ci<? (s1::<string> s2::<string>)
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_StringCiCmp(s1, s2) < 0));")
(define-cproc string-ci<=? (s1::<string> s2::<string>)
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_StringCiCmp(s1, s2) <= 0));")
(define-cproc string-ci>? (s1::<string> s2::<string>)
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_StringCiCmp(s1, s2) > 0));")
(define-cproc string-ci>=? (s1::<string> s2::<string>)
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_StringCiCmp(s1, s2) >= 0));")

(define-cproc substring (str::<string> start::<fixnum> end::<fixnum>)
  (return "Scm_Substring"))

(define-cproc string-append (&rest args)
  (return "Scm_StringAppend"))

(define-cproc string->list (str::<string> &optional start end)
  "  ScmObj xstr = Scm_MaybeSubstring(str, start, end);
  SCM_RETURN(Scm_StringToList(SCM_STRING(xstr)));")

(define-cproc list->string (list::<list>)
  (return "Scm_ListToString"))

(define-cproc string-copy (str::<string> &optional start end)
  "  ScmObj xstr = Scm_MaybeSubstring(str, start, end);
  SCM_RETURN(Scm_CopyString(SCM_STRING(xstr)));")

(define-cproc string-fill! (str::<string> c::<char> &optional start end)
  (return "Scm_StringFill"))

;;
;; 6.3.6  Vectors
;;

(define-cproc vector? (obj) (return <boolean> "SCM_VECTORP"))

(define-cproc make-vector (k::<fixnum> &optional fill)
  (return "Scm_MakeVector"))

(define-cproc vector (&rest args)
  (inliner "SCM_VM_VEC")
  (return "Scm_ListToVector"))

(define-cproc vector-length (vec::<vector>)
  (inliner "SCM_VM_VEC_LEN")
  (return <fixnum> "SCM_VECTOR_SIZE"))

(define-cproc vector-ref (vec::<vector> k::<fixnum> &optional fallback)
  (inliner (case-nargs (2 "SCM_VM_VEC_REF") (else #f)))
  (return "Scm_VectorRef")
  (setter vector-set!))

(define-cproc vector-set! (vec::<vector> k::<fixnum> obj)
  (inliner "SCM_VM_VEC_SET")
  (return <void> "Scm_VectorSet"))

(define-cproc vector->list (vec::<vector>
                            &optional (start::<fixnum> 0) (end::<fixnum> -1))
  (return "Scm_VectorToList"))

(define-cproc list->vector (list::<list>)
  (return "Scm_ListToVector"))

(define-cproc vector-fill! (vec::<vector> fill
                            &optional (start::<fixnum> 0) (end::<fixnum> -1))
  (return void "Scm_VectorFill"))

;;
;; 6.4  Control Features
;;

(define-cproc procedure? (obj) (return <boolean> "SCM_PROCEDUREP"))

(define-cproc apply (proc arg1 &rest args)
  (inliner "SCM_VM_APPLY")
  "  ScmObj head, tail, cp;
  if (SCM_NULLP(args)) return Scm_VMApply(proc, arg1);
  else {
    head = tail = Scm_Cons(arg1, SCM_NIL);
    SCM_FOR_EACH(cp, args) {
      if (SCM_NULLP(SCM_CDR(cp))) {
        SCM_APPEND(head, tail, SCM_CAR(cp));
        break;
      }
      if (!SCM_PAIRP(SCM_CDR(cp))) {
        Scm_Error(\"improper list not allowed: %S\", SCM_CDR(cp));
      }
      SCM_APPEND1(head, tail, SCM_CAR(cp));
    }
  }
  return Scm_VMApply(proc, head);")

(define-cproc map (proc args::<list> &rest moreargs)
  (return "Scm_Map"))

(define-cproc for-each (proc args::<list> &rest moreargs)
  (return "Scm_ForEach"))
          
(define-cproc force (p)
  (return "Scm_Force"))

(define-cproc call-with-current-continuation (proc)
  (return "Scm_VMCallCC"))

(define-cproc values (&rest args)
  (inliner "SCM_VM_VALUES")
  (return "Scm_Values"))

;; call-with-values - defined in gauche-init.scm

(define-cproc dynamic-wind (pre body post)
  (return "Scm_VMDynamicWind"))

(define-cproc eval (expr env)
  (return "Scm_VMEval"))

;; for now, just return a module.
(define-cproc null-environment (version::<fixnum>)
  "  if (version != 5) Scm_Error(\"unknown rNrs version: %d\", version);
  SCM_RETURN(SCM_OBJ(Scm_NullModule()));")
(define-cproc scheme-report-environment (version::<fixnum>)
  "  if (version != 5) Scm_Error(\"unknown rNrs version: %d\", version);
  SCM_RETURN(SCM_OBJ(Scm_SchemeModule()));")
(define-cproc interaction-environment ()
  "  SCM_RETURN(SCM_OBJ(Scm_UserModule()));")

;;
;; 6.6.1  Ports
;;
  
;; open-input-file, open-output-file, and various call-with-* and
;; with-* are defined in lib/gauche/with.scm and autoloaded.

(define-cproc input-port? (obj)  (return <boolean> "SCM_IPORTP"))
(define-cproc output-port? (obj) (return <boolean> "SCM_OPORTP"))
(define-cproc port? (obj)        (return <boolean> "SCM_PORTP"))

(define-cproc current-input-port ()
  "  SCM_RETURN(SCM_OBJ(SCM_CURIN));")

(define-cproc current-output-port ()
  "  SCM_RETURN(SCM_OBJ(SCM_CUROUT));")

(define-cproc close-input-port (port::<port>)
  (return <void> "Scm_ClosePort"))

(define-cproc close-output-port (port::<port>)
  (return <void> "Scm_ClosePort"))

;;
;; 6.6.2  Input
;;

(define-cproc read (&optional (port::<input-port> (current-input-port)))
  "  SCM_RETURN(Scm_Read(SCM_OBJ(port)));")

(define-cproc read-char (&optional (port::<input-port> (current-input-port)))
  (inliner "SCM_VM_READ_CHAR")
  "  int ch = EOF;
  SCM_GETC(ch, port);
  if (ch == EOF) SCM_RETURN(SCM_EOF);
  else SCM_RETURN(SCM_MAKE_CHAR(ch));")

(define-cproc peek-char (&optional (port::<input-port> (current-input-port)))
  "  ScmChar ch = Scm_Peekc(port);
  ScmObj r = (ch == SCM_CHAR_INVALID)? SCM_EOF : SCM_MAKE_CHAR(ch);
  SCM_RETURN(r);")

(define-cproc eof-object? (obj)
  (inliner "SCM_VM_EOFP")
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_EOFP(obj)));")

(define-cproc char-ready? (&optional (port::<input-port> (current-input-port)))
  (return <boolean> "Scm_CharReady"))

;;
;; 6.6.3  Output
;;

(define-cproc write (obj &optional (port::<output-port> (current-output-port)))
  "Scm_Write(obj, SCM_OBJ(port), SCM_WRITE_WRITE);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc display (obj &optional (port::<output-port> (current-output-port)))
  "Scm_Write(obj, SCM_OBJ(port), SCM_WRITE_DISPLAY);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc newline (&optional (port::<output-port> (current-output-port)))
  "  SCM_PUTC('\\n', port); SCM_RETURN(SCM_UNDEFINED);")

(define-cproc write-char (ch::<char>
                          &optional (port::<output-port> (current-output-port)))
  (inliner "SCM_VM_WRITE_CHAR")
  "  SCM_PUTC(ch, port); SCM_RETURN(SCM_UNDEFINED);")

;;
;; 6.6.4  System Interface
;;

; load : defined in load.c
; transcript-on
; transcript-off

;; Local variables:
;; mode: scheme
;; end:
