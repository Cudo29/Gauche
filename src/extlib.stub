;;;
;;; extlib.stub - extra built-ins
;;;  
;;;   Copyright (c) 2000-2004 Shiro Kawai, All rights reserved.
;;;   
;;;   Redistribution and use in source and binary forms, with or without
;;;   modification, are permitted provided that the following conditions
;;;   are met:
;;;   
;;;   1. Redistributions of source code must retain the above copyright
;;;      notice, this list of conditions and the following disclaimer.
;;;  
;;;   2. Redistributions in binary form must reproduce the above copyright
;;;      notice, this list of conditions and the following disclaimer in the
;;;      documentation and/or other materials provided with the distribution.
;;;  
;;;   3. Neither the name of the authors nor the names of its contributors
;;;      may be used to endorse or promote products derived from this
;;;      software without specific prior written permission.
;;;  
;;;   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
;;;   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
;;;   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
;;;   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
;;;   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
;;;   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
;;;   TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
;;;   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
;;;   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
;;;   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
;;;   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;;;  
;;; $Id: extlib.stub,v 1.230.2.6 2004-12-30 09:28:54 shirok Exp $
;;;

"
#include <fcntl.h>
#include <gauche/arch.h>
#include <gauche/class.h>
#include <gauche/vminsn.h>
"

;;
;; Macros
;;

(define-cproc macroexpand (form)
  "SCM_RETURN(Scm_MacroExpand(form, SCM_NIL, FALSE));")
(define-cproc macroexpand-1 (form)
  "SCM_RETURN(Scm_MacroExpand(form, SCM_NIL, TRUE));")

;;
;; 6.1  Equivalence predicates
;;

;; to pass the cmpmode argument
(define-symbol eq?    "sym_eq")
(define-symbol eqv?   "sym_eqv")
(define-symbol equal? "sym_equal")

(define-symbol string=? "sym_string_eq") ; used for make-hash-table

"static int getcmpmode(ScmObj opt)
 { if (SCM_UNBOUNDP(opt) || opt == sym_equal) return SCM_CMP_EQUAL;
   if (opt == sym_eq) return SCM_CMP_EQ;
   if (opt == sym_eqv) return SCM_CMP_EQV;
   Scm_Error(\"unrecognized compare mode: %S\", opt);
   return 0; /* dummy */ }"

(define-cproc compare (x y) (return <fixnum> "Scm_Compare"))

;;
;; 6.2  Numbers
;;

(define-cproc ash (num cnt::<fixnum>)
  (return "Scm_Ash"))

(define-cproc lognot (x) (return "Scm_LogNot"))
(define-cproc logand (x y &rest args)
  "  ScmObj cp, r = Scm_LogAnd(x, y);
  SCM_FOR_EACH(cp, args) {
    r = Scm_LogAnd(r, SCM_CAR(cp));
  }
  SCM_RETURN(r);")
(define-cproc logior (x y &rest args)
  "  ScmObj cp, r = Scm_LogIor(x, y);
  SCM_FOR_EACH(cp, args) {
    r = Scm_LogIor(r, SCM_CAR(cp));
  }
  SCM_RETURN(r);")
(define-cproc logxor (x y &rest args)
  "  ScmObj cp, r = Scm_LogXor(x, y);
  SCM_FOR_EACH(cp, args) {
    r = Scm_LogXor(r, SCM_CAR(cp));
  }
  SCM_RETURN(r);")

(define-cproc fixnum? (x)
  (return <boolean> "SCM_INTP"))
(define-cproc bignum? (x)
  (return <boolean> "SCM_BIGNUMP"))

(define-cproc clamp (x &optional (min #f) (max #f))
  " ScmObj r = x;  int maybe_exact = FALSE;
  if (SCM_EXACTP(x)) maybe_exact = TRUE;
  else if (!SCM_FLONUMP(x)) {
    Scm_Error(\"real number required for x, but got %S\", x);
  }
  if (SCM_EXACTP(min)) {
    if (Scm_NumCmp(x, min) < 0) r = min;
  } else if (SCM_FLONUMP(min)) {
    maybe_exact = FALSE;
    if (Scm_NumCmp(x, min) < 0) r = min;
  } else if (!SCM_FALSEP(min)) {
    Scm_Error(\"real number or #f required for min, but got %S\", min);
  }
  if (SCM_EXACTP(max)) {
    if (Scm_NumCmp(x, max) > 0) r = max;
  } else if (SCM_FLONUMP(max)) {
     maybe_exact = FALSE;
    if (Scm_NumCmp(x, max) > 0) r = max;
  } else if (!SCM_FALSEP(max)) {
    Scm_Error(\"real number or #f required for max, but got %S\", max);
  }
  if (!maybe_exact && SCM_EXACTP(r)) SCM_RETURN(Scm_ExactToInexact(r));
  else SCM_RETURN(r);")

(define-cproc decode-float (num)        ;from ChezScheme
  "if (SCM_FLONUMP(num)) {
     int exp, sign;
     ScmObj f = Scm_DecodeFlonum(SCM_FLONUM_VALUE(num), &exp, &sign);
     ScmObj v = Scm_MakeVector(3, SCM_FALSE);
     SCM_VECTOR_ELEMENT(v, 0) = f;
     SCM_VECTOR_ELEMENT(v, 1) = Scm_MakeInteger(exp);
     SCM_VECTOR_ELEMENT(v, 2) = Scm_MakeInteger(sign);
     SCM_RETURN(v);
  } else if (SCM_INTP(num)) {
     ScmObj v = Scm_MakeVector(3, SCM_FALSE);
     SCM_VECTOR_ELEMENT(v, 0) = Scm_Abs(num);
     SCM_VECTOR_ELEMENT(v, 1) = Scm_MakeInteger(0);
     SCM_VECTOR_ELEMENT(v, 2) = Scm_MakeInteger(Scm_Sign(num));
     SCM_RETURN(v);
  } else {
     Scm_Error(\"real number required, but got %S\", num);
     SCM_RETURN(SCM_UNDEFINED);
  }")

;; just for debug...
(if "SCM_DEBUG_HELPER"
(define-cproc %bignum-dump (obj)
  "  if (SCM_BIGNUMP(obj)) Scm_DumpBignum(SCM_BIGNUM(obj), SCM_CUROUT);
  SCM_RETURN(SCM_UNDEFINED);")
)

(define-cproc min&max (arg0 &rest args)
  "ScmObj min, max;
   Scm_MinMax(arg0, args, &min, &max);
   SCM_RETURN(Scm_Values2(min, max));")

(define-cproc quotient&remainder (n1 n2)
  "ScmObj q, r;
   q = Scm_Quotient(n1, n2, &r);
   SCM_RETURN(Scm_Values2(q, r));")

;;
;; 6.3.1  Booleans
;;

;;
;; 6.3.2  Pairs and lists
;;

(define-cproc make-list (len::<fixnum> &optional (fill #f)) ; SRFI-1
  (return "Scm_MakeList"))

(define-cproc acons (caa cda cd)
  (return "Scm_Acons"))

(define-cproc last-pair (list)          ; SRFI-1
  (return "Scm_LastPair"))

(define-cproc list-copy (list)          ; SRFI-1
  (return "Scm_CopyList"))

(define-cproc list* (&rest args)
  (inliner "SCM_VM_LIST_STAR")
  "  ScmObj head = SCM_NIL, tail = SCM_NIL, cp;
  if (SCM_PAIRP(args)) {
    SCM_FOR_EACH(cp, args) {
      if (!SCM_PAIRP(SCM_CDR(cp))) {
        if (SCM_NULLP(head)) head = SCM_CAR(cp);
        else SCM_SET_CDR(tail, SCM_CAR(cp));
        break;
      }
      SCM_APPEND1(head, tail, SCM_CAR(cp));
    }
  }
  SCM_RETURN(head);")

(define-cproc %delete (obj list::<list> &optional cmpmode)
  "  SCM_RETURN(Scm_Delete(obj, list, getcmpmode(cmpmode)));")

(define-cproc %delete! (obj list::<list> &optional cmpmode)
  "  SCM_RETURN(Scm_DeleteX(obj, list, getcmpmode(cmpmode)));")

(define-cproc %delete-duplicates (list::<list> &optional cmpmode)
  "  SCM_RETURN(Scm_DeleteDuplicates(list, getcmpmode(cmpmode)));")

(define-cproc %delete-duplicates! (list::<list> &optional cmpmode)
  "  SCM_RETURN(Scm_DeleteDuplicatesX(list, getcmpmode(cmpmode)));")

(define-cproc %alist-delete (elt list::<list> &optional cmpmode)
  "  SCM_RETURN(Scm_AssocDelete(elt, list, getcmpmode(cmpmode)));")

(define-cproc %alist-delete! (elt list::<list> &optional cmpmode)
  "  SCM_RETURN(Scm_AssocDeleteX(elt, list, getcmpmode(cmpmode)));")

(define-cproc append! (&rest list)
  "  ScmObj cp, h = SCM_NIL, t = SCM_NIL;
  SCM_FOR_EACH(cp, list) SCM_APPEND(h, t, SCM_CAR(cp));
  SCM_RETURN(h);")

(define-cproc reverse! (list)
  (return "Scm_ReverseX"))

;; Scheme version of 'sort' handles the case when comparison function
;; is given.
(define-cproc %sort (seq)
  "if (SCM_VECTORP(seq)) {
    ScmObj r = Scm_VectorCopy(SCM_VECTOR(seq), 0, -1);
    Scm_SortArray(SCM_VECTOR_ELEMENTS(r), SCM_VECTOR_SIZE(r), SCM_FALSE);
    SCM_RETURN(r);
  } else if (Scm_Length(seq) >= 0) {
    SCM_RETURN(Scm_SortList(seq, SCM_FALSE));
  } else {
    Scm_Error(\"proper list or vector required, but got %S\", seq);
    SCM_RETURN(SCM_UNDEFINED);
  }")

(define-cproc %sort! (seq)
  "if (SCM_VECTORP(seq)) {
    Scm_SortArray(SCM_VECTOR_ELEMENTS(seq), SCM_VECTOR_SIZE(seq), SCM_FALSE);
    SCM_RETURN(seq);
  } else if (Scm_Length(seq) >= 0) {
    SCM_RETURN(Scm_SortListX(seq, SCM_FALSE));
  } else {
    Scm_Error(\"proper list or vector required, but got %S\", seq);
    SCM_RETURN(SCM_UNDEFINED);
  }")

(define-cproc monotonic-merge (start sequences::<list>)
  (return "Scm_MonotonicMerge"))

(define-cproc pair-attributes (pair::<pair>)
  (return "Scm_PairAttr"))

(define-cproc pair-attribute-get (pair::<pair> key &optional fallback)
  "  SCM_RETURN(Scm_PairAttrGet(SCM_PAIR(pair), key, fallback));")

(define-cproc pair-attribute-set! (pair::<pair> key value)
  "  SCM_RETURN(Scm_PairAttrSet(SCM_PAIR(pair), key, value));")

;;
;; 6.3.3  Symbols
;;

(define-cproc symbol-bound? (symbol::<symbol> &optional module)
  "  
  if (module == SCM_UNBOUND) {
     module = SCM_OBJ(SCM_CURRENT_MODULE());
  } else if (!SCM_MODULEP(module)) {
     Scm_Error(\"module required, but got %S\", module);
  }
  if (Scm_SymbolValue(SCM_MODULE(module), symbol) == SCM_UNBOUND)
     SCM_RETURN(SCM_FALSE);
  else
     SCM_RETURN(SCM_TRUE);")

(define-cproc gensym (&optional prefix)
  "  ScmString *p = NULL;
  if (prefix != SCM_UNBOUND) {
    if (!SCM_STRINGP(prefix))
      Scm_Error(\"string expected, but got %S\", prefix);
    p = SCM_STRING(prefix);
  }
  SCM_RETURN(Scm_Gensym(p));")

;; keywords
(define-cproc keyword? (obj) (return <boolean> "SCM_KEYWORDP"))

(define-cproc make-keyword (name)
  "   ScmString *sname = NULL;
  if (SCM_STRINGP(name)) sname = SCM_STRING(name);
  else if (SCM_SYMBOLP(name)) sname = SCM_SYMBOL_NAME(name);
  else Scm_Error(\"string or symbol required, but got %S\", name);
  SCM_RETURN(Scm_MakeKeyword(sname));")

(define-cproc get-keyword (key list &optional fallback)
  (return "Scm_GetKeyword"))

(define-cproc delete-keyword (key list)
  (return "Scm_DeleteKeyword"))

(define-cproc delete-keyword! (key list)
  (return "Scm_DeleteKeywordX"))

(define-cproc keyword->string (key::<keyword>)
  "SCM_RETURN(SCM_OBJ(SCM_KEYWORD_NAME(key)));")

;; identifiers
(define-cproc identifier? (obj) (return <boolean> "SCM_IDENTIFIERP"))

(define-cproc identifier->symbol (obj::<identifier>)
  "  SCM_RETURN(SCM_OBJ(SCM_IDENTIFIER(obj)->name));")

;;
;; 6.3.4  Characters
;;

(define-cproc digit->integer (ch::<char> &optional (radix::<fixnum> 10))
  "  int r;
  if (radix < 2 || radix > 36)
     Scm_Error(\"radix must be between 2 and 36, but got %d\", radix);
  r = Scm_DigitToInt(ch, radix);
  return (r >= 0 ? SCM_MAKE_INT(r) : SCM_FALSE);")

(define-cproc integer->digit (n::<fixnum> &optional (radix::<fixnum> 10))
  "  ScmChar r;
  if (radix < 2 || radix > 36)
     Scm_Error(\"radix must be between 2 and 36, but got %d\", radix);
  r = Scm_IntToDigit(n, radix);
  return (r == SCM_CHAR_INVALID? SCM_FALSE : SCM_MAKE_CHAR(r));")

(define-cproc ucs->char (n::<int>)
  "ScmChar ch = Scm_UcsToChar(n);
  if (ch == SCM_CHAR_INVALID) SCM_RETURN(SCM_FALSE);
  else SCM_RETURN(SCM_MAKE_CHAR(ch));")

(define-cproc char->ucs (c::<char>)
  "int ucs = Scm_CharToUcs(c);
  if (ucs < 0) SCM_RETURN(SCM_FALSE);
  else SCM_RETURN(Scm_MakeInteger(ucs));")

(define-cproc gauche-character-encoding ()
  (return "Scm_CharEncodingName"))

(define-cproc supported-character-encodings ()
  "  SCM_RETURN(Scm_ConstCStringArrayToList(Scm_SupportedCharacterEncodings(), -1));")

(define-cproc supported-character-encoding? (encoding::<string>)
  "  SCM_RETURN(SCM_MAKE_BOOL(Scm_SupportedCharacterEncodingP(Scm_GetStringConst(encoding))));")

;; character sets (SRFI-14)
;;   not all of srfi-14 functions are defined in C.  you need to load
;;   srfi-14.scm to get a full set of functions.

(define-constant *char-code-max* (c "Scm_MakeInteger(SCM_CHAR_MAX)"))

(define-cproc char-set? (obj) (return <boolean> "SCM_CHARSETP"))

"static void char_set_add(ScmCharSet *cs, ScmObj chars)
 {  ScmObj cp; ScmChar ch;
  SCM_FOR_EACH(cp, chars) {
    if (!SCM_CHARP(SCM_CAR(cp)))
      Scm_Error(\"character required, but got %S\", SCM_CAR(cp));
    ch = SCM_CHAR_VALUE(SCM_CAR(cp));
    Scm_CharSetAddRange(cs, ch, ch);
  }
 }"

(define-cproc %char-set-equal? (x::<char-set> y::<char-set>)
  (return <boolean> "Scm_CharSetEq"))

(define-cproc %char-set<=? (x::<char-set> y::<char-set>)
  (return <boolean> "Scm_CharSetLE"))

(define-cproc char-set (&rest chars)
  "  ScmCharSet *cs = SCM_CHARSET(Scm_MakeEmptyCharSet());
  char_set_add(cs, chars);
  SCM_RETURN(SCM_OBJ(cs));")

(define-cproc char-set-copy (cs::<char-set>)
  (return "Scm_CopyCharSet"))

(define-cproc %char-set-add-chars! (cs::<char-set> chars::<list>)
  "  char_set_add(cs, chars); SCM_RETURN(SCM_OBJ(cs));")

(define-cproc %char-set-add-range! (cs::<char-set> from to)
  "  long fromc = -1, toc = -1;
  if (SCM_EXACTP(from)) fromc = Scm_GetInteger(from);
  else if (SCM_CHARP(from)) fromc = SCM_CHAR_VALUE(from);
  if (fromc < 0) Scm_Error(\"character or positive integer required, but got %S\", from);
  if (fromc > SCM_CHAR_MAX) Scm_Error(\"argument out of range: %S\", from);
  if (SCM_EXACTP(to)) toc = Scm_GetInteger(to);
  else if (SCM_CHARP(to)) toc = SCM_CHAR_VALUE(to);
  if (toc < 0) Scm_Error(\"character or positive integer required, but got %S\", to);
  if (toc > SCM_CHAR_MAX) Scm_Error(\"argument out of range: %S\", to);
  SCM_RETURN(Scm_CharSetAddRange(cs, (ScmChar)fromc, (ScmChar)toc));")

(define-cproc %char-set-add! (dst::<char-set> src::<char-set>)
  (return "Scm_CharSetAdd"))

(define-cproc char-set-contains? (cs::<char-set> ch::<char>)
  (return <boolean> "Scm_CharSetContains"))

(define-cproc %char-set-complement! (cs::<char-set>)
  (return "Scm_CharSetComplement"))

(define-cproc %char-set-ranges (cs::<char-set>)
  (return "Scm_CharSetRanges"))

(define-cproc %char-set-predefined (num::<fixnum>)
  (return "Scm_GetStandardCharSet"))

;; for debug
(if "SCM_DEBUG_HELPER"
(define-cproc %char-set-dump (cs::<char-set>)
  "Scm_CharSetDump(cs, SCM_CUROUT); SCM_RETURN(SCM_UNDEFINED);")
)

;;
;; 6.3.5 Strings
;;

(define-cproc string-incomplete? (obj)    ;gauche specific
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_STRINGP(obj)&&SCM_STRING_INCOMPLETE_P(obj)));")
(define-cproc string-immutable? (obj)   ;gauche specific
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_STRINGP(obj)&&SCM_STRING_IMMUTABLE_P(obj)));")

(define-cproc string-complete->incomplete! (str::<string>) ;gauche specific
  (return "Scm_StringCompleteToIncompleteX"))
(define-cproc string-incomplete->complete! (str::<string>) ;gauche specific
  (return "Scm_StringIncompleteToCompleteX"))
(define-cproc string-complete->incomplete (str::<string>) ;gauche specific
  (return "Scm_StringCompleteToIncomplete"))
(define-cproc string-incomplete->complete (str::<string>) ;gauche specific
  (return "Scm_StringIncompleteToComplete"))

(define-cproc string-size (str::<string>)
  (return <fixnum> "SCM_STRING_SIZE"))

(define-cproc make-byte-string (size::<fixnum> &optional (byte::<fixnum> 0))
  "char *s;
  if (size < 0) Scm_Error(\"size out of bound: %d\", size);
  s = SCM_NEW_ATOMIC2(char *, size);
  memset(s, byte, size);
  SCM_RETURN(Scm_MakeString(s, size, size, SCM_MAKSTR_INCOMPLETE));")

(define-cproc string-byte-ref (str::<string> k::<fixnum> &optional fallback)
  "  int r;
  if (!SCM_UNBOUNDP(fallback) && (k < 0 || k >= SCM_STRING_SIZE(str))) {
    SCM_RETURN(fallback);
  } else {
    r = Scm_StringByteRef(str, k);
    SCM_RETURN(SCM_MAKE_INT(r));
  }")

(define-cproc string-byte-set! (str::<string> k::<fixnum> b::<fixnum>)
  (return "Scm_StringByteSet"))

(define-cproc string-substitute! (target::<string> start::<fixnum> str::<string>)
  "  ScmObj r = Scm_StringSubstitute(target, start, str);
  if (!SCM_STRINGP(r)) Scm_Error(\"argument out of range: (%d %S)\", start, str);
  SCM_RETURN(r);")

(define-cproc %maybe-substring (str::<string> &optional start end)
  (return "Scm_MaybeSubstring"))

(define-symbol infix "sym_infix")
(define-symbol strict-infix "sym_strict_infix")
(define-symbol suffix "sym_suffix")
(define-symbol prefix "sym_prefix")

(define-cproc string-join (strs::<list>
                           &optional (delim::<string> " ") grammer)
  "  int gm = 0;
  if (SCM_UNBOUNDP(grammer) || SCM_UNDEFINEDP(grammer) || grammer == sym_infix)
    gm = SCM_STRING_JOIN_INFIX;
  else if (grammer == sym_strict_infix)
    gm = SCM_STRING_JOIN_STRICT_INFIX;
  else if (grammer == sym_suffix)
    gm = SCM_STRING_JOIN_SUFFIX;
  else if (grammer == sym_prefix)
    gm = SCM_STRING_JOIN_PREFIX;
  else Scm_Error(\"invalid grammer specification: %S\", grammer);
  SCM_RETURN(Scm_StringJoin(strs, delim, gm));")

(define-cproc %hash-string (str::<string> bound) ; for SRFI-13
  "  unsigned long modulo = 0;
  if (SCM_UNDEFINEDP(bound)) modulo = SCM_SMALL_INT_MAX;
  else if (SCM_INTP(bound)) modulo = SCM_INT_VALUE(bound);
  else if (SCM_BIGNUMP(bound)) modulo = Scm_BignumToUI(SCM_BIGNUM(bound), SCM_CLAMP_BOTH, NULL);
  if (modulo == 0) Scm_Error(\"argument out of domain: %S\", bound);
  SCM_RETURN(Scm_MakeInteger(Scm_HashString(str, modulo)));")

;; see lib/gauche/string for generic string-split
(define-cproc %string-split-by-char (s::<string> ch::<char>)
  (return "Scm_StringSplitByChar"))

;; primitive scanner
(define-symbol index   "sym_index")
(define-symbol before  "sym_before")
(define-symbol after   "sym_after")
(define-symbol before* "sym_before2")
(define-symbol after*  "sym_after2")
(define-symbol both    "sym_both")

(define-cproc string-scan (s1::<string> s2 &optional (mode (c "sym_index")))
  "  int retmode = 0;
  if (mode == sym_index)         retmode = SCM_STRING_SCAN_INDEX;
  else if (mode == sym_before)   retmode = SCM_STRING_SCAN_BEFORE;
  else if (mode == sym_after)    retmode = SCM_STRING_SCAN_AFTER;
  else if (mode == sym_before2)  retmode = SCM_STRING_SCAN_BEFORE2;
  else if (mode == sym_after2)   retmode = SCM_STRING_SCAN_AFTER2;
  else if (mode == sym_both)     retmode = SCM_STRING_SCAN_BOTH;
  else {
    Scm_Error(\"bad value in mode argumet: %S, must be one of 'index, 'before, 'after, 'before*, 'after* or 'both.\", mode);
  }
  if (SCM_STRINGP(s2)) {
     SCM_RETURN(Scm_StringScan(s1, SCM_STRING(s2), retmode));
  } else if (SCM_CHARP(s2)) {
     SCM_RETURN(Scm_StringScanChar(s1, SCM_CHAR_VALUE(s2), retmode));
  } else {
     Scm_Error(\"bad type of argument for s2: %S, must be either string or character\", s2);
     SCM_RETURN(SCM_UNDEFINED); /* dummy */
  }")
  

;; string pointer
(define-type <string-pointer> "ScmStringPointer*" "string pointer"
  "SCM_STRING_POINTERP" "SCM_STRING_POINTER")

(define-cproc make-string-pointer (str::<string>
                                   &optional (index::<fixnum> 0)
                                             (start::<fixnum> 0)
                                             (end::<fixnum> -1))
  (return "Scm_MakeStringPointer"))
(define-cproc string-pointer? (obj)
  (return <boolean> "SCM_STRING_POINTERP"))

(define-cproc string-pointer-ref (sp::<string-pointer>)
  (return "Scm_StringPointerRef"))
(define-cproc string-pointer-next! (sp::<string-pointer>)
  (return "Scm_StringPointerNext"))
(define-cproc string-pointer-prev! (sp::<string-pointer>)
  (return "Scm_StringPointerPrev"))
(define-cproc string-pointer-set! (sp::<string-pointer> index::<fixnum>)
  (return "Scm_StringPointerSet"))
(define-cproc string-pointer-substring (sp::<string-pointer>
                                        &keyword (after #f))
  "  SCM_RETURN(Scm_StringPointerSubstring(sp, !SCM_FALSEP(after)));")
(define-cproc string-pointer-index (sp::<string-pointer>)
  "  SCM_RETURN(Scm_MakeInteger(sp->index));")
(define-cproc string-pointer-copy (sp::<string-pointer>)
  (return "Scm_StringPointerCopy"))
(define-cproc string-pointer-byte-index (sp::<string-pointer>)
  "  SCM_RETURN(Scm_MakeInteger(sp->current - sp->start));")

(if "SCM_DEBUG_HELPER"
    (define-cproc %string-pointer-dump (sp::<string-pointer>)
      (return <void> "Scm_StringPointerDump"))
    )

;; Regexp
(define-cproc regexp? (obj)    (return <boolean> "SCM_REGEXPP"))
(define-cproc regmatch? (obj)  (return <boolean> "SCM_REGMATCHP"))

(define-cproc string->regexp (str::<string> &keyword (case-fold #f))
  "int flags = SCM_BOOL_VALUE(case_fold)? SCM_REGEXP_CASE_FOLD : 0;
  SCM_RETURN(Scm_RegComp(str, flags));")
(define-cproc regexp->string (regexp::<regexp>)
  "SCM_RETURN(regexp->pattern?SCM_OBJ(regexp->pattern):SCM_FALSE);")

(define-cproc regexp-parse (str::<string> &keyword (case-fold #f))
  "int flags = SCM_BOOL_VALUE(case_fold)? SCM_REGEXP_CASE_FOLD : 0;
  SCM_RETURN(Scm_RegComp(str, flags|SCM_REGEXP_PARSE_ONLY));")
(define-cproc regexp-compile (ast)
  (return "Scm_RegCompFromAST"))
(define-cproc regexp-optimize (ast)
  (return "Scm_RegOptimizeAST"))

(define-cproc rxmatch (regexp str::<string>)
  "  ScmRegexp *rx = NULL;
  if (SCM_STRINGP(regexp)) rx = SCM_REGEXP(Scm_RegComp(SCM_STRING(regexp), 0));
  else if (SCM_REGEXPP(regexp)) rx = SCM_REGEXP(regexp);
  else Scm_Error(\"regexp required, but got %S\", regexp);
  SCM_RETURN(Scm_RegExec(rx, str));")

(define-cproc rxmatch-substring (match &optional (i::<fixnum> 0))
  "  if (SCM_FALSEP(match)) SCM_RETURN(SCM_FALSE);
  if (!SCM_REGMATCHP(match))
    Scm_Error(\"regexp match object required, but got %S\", match);
  SCM_RETURN(Scm_RegMatchSubstr(SCM_REGMATCH(match), i));")

(define-cproc rxmatch-start (match &optional (i::<fixnum> 0))
  "  if (SCM_FALSEP(match)) SCM_RETURN(SCM_FALSE);
  if (!SCM_REGMATCHP(match))
    Scm_Error(\"regexp match object required, but got %S\", match);
  SCM_RETURN(Scm_RegMatchStart(SCM_REGMATCH(match), i));")

(define-cproc rxmatch-end (match &optional (i::<fixnum> 0))
  "  if (SCM_FALSEP(match)) SCM_RETURN(SCM_FALSE);
  if (!SCM_REGMATCHP(match))
    Scm_Error(\"regexp match object required, but got %S\", match);
  SCM_RETURN(Scm_RegMatchEnd(SCM_REGMATCH(match), i));")

(define-cproc rxmatch-before (match &optional (i::<fixnum> 0))
  "  if (SCM_FALSEP(match)) SCM_RETURN(SCM_FALSE);
  if (!SCM_REGMATCHP(match))
    Scm_Error(\"regexp match object required, but got %S\", match);
  SCM_RETURN(Scm_RegMatchBefore(SCM_REGMATCH(match), i));")

(define-cproc rxmatch-after (match &optional (i::<fixnum> 0))
  "  if (SCM_FALSEP(match)) SCM_RETURN(SCM_FALSE);
  if (!SCM_REGMATCHP(match))
    Scm_Error(\"regexp match object required, but got %S\", match);
  SCM_RETURN(Scm_RegMatchAfter(SCM_REGMATCH(match), i));")

(define-cproc rxmatch-num-matches (match)
  "  if (SCM_FALSEP(match)) SCM_RETURN(SCM_MAKE_INT(0));
  if (!SCM_REGMATCHP(match))
    Scm_Error(\"regexp match object required, but got %S\", match);
  SCM_RETURN(SCM_MAKE_INT(SCM_REGMATCH(match)->numMatches));")

;; for debug
(if "SCM_DEBUG_HELPER"
(define-cproc %regexp-dump (rx)
  "  if (!SCM_REGEXPP(rx)) Scm_Error(\"regexp required, but got %S\", rx);
  Scm_RegDump(SCM_REGEXP(rx));  SCM_RETURN(SCM_UNDEFINED);")
)

(if "SCM_DEBUG_HELPER"
(define-cproc %regmatch-dump (rm)
  "  if (!SCM_REGMATCHP(rm)) Scm_Error(\"regmatch required, but got %S\", rm);
  Scm_RegMatchDump(SCM_REGMATCH(rm));  SCM_RETURN(SCM_UNDEFINED);")
)

;;
;; 6.3.6  Vectors
;;

(define-cproc vector-copy (v::<vector>
                           &optional (start::<fixnum> 0) (end::<fixnum> -1))
  (return "Scm_VectorCopy"))

;; weak vector
(define-cproc make-weak-vector (size::<fixnum>)
  (return "Scm_MakeWeakVector"))

(define-cproc weak-vector-length (wv::<weak-vector>)
  "SCM_RETURN(Scm_MakeInteger(wv->size));")

(define-cproc weak-vector-ref (wv::<weak-vector> index::<fixnum>
                               &optional fallback)
  (return "Scm_WeakVectorRef"))
  
(define-cproc weak-vector-set! (wv::<weak-vector> index::<fixnum> val)
  (return "Scm_WeakVectorSet"))

;;
;; 6.4  Control Features
;;

(define-cproc setter (proc) ;SRFI-17
  (inliner "SCM_VM_SETTER")
  (return "Scm_Setter")
  (setter (proc::<procedure> setter::<procedure>)
    "  Scm_SetterSet(proc, setter, FALSE); SCM_RETURN(SCM_UNDEFINED);"))

(define-cproc has-setter? (proc)
  (return <boolean> "Scm_HasSetter"))

(define-cproc identity (val)            ;sometimes useful
  "SCM_RETURN(val);")

(define-cproc promise? (obj)
  "SCM_RETURN(SCM_MAKE_BOOL(SCM_XTYPEP(obj, SCM_CLASS_PROMISE)));")

;;
;; 6.6.1  Ports
;;

;; open-input-file and open-output-file are defined in Scheme.
;; these are core procedures

;; valid keywords for open-*-file options
(define-keyword error "key_error")
(define-keyword create "key_create")
(define-keyword append "key_append")
(define-keyword supersede "key_supersede")
(define-keyword overwrite "key_overwrite")
(define-keyword character "key_character")
(define-keyword binary "key_binary")

(define-cproc %open-input-file (path::<string>
                                &keyword
                                (if-does-not-exist (c "key_error"))
                                (buffering #f)
                                (element-type (c "key_character"))
                                )
  "  ScmObj o; int ignerr = FALSE, bufmode;
  if (SCM_FALSEP(if_does_not_exist)) ignerr = TRUE;
  else if (!SCM_EQ(if_does_not_exist, key_error)) {
    Scm_Error(\"argument for :if-does-not-exist must be either :error or #f, but got %S\", if_does_not_exist);
  }
  bufmode = Scm_BufferingMode(buffering, SCM_PORT_INPUT, SCM_PORT_BUFFER_FULL);
  o = Scm_OpenFilePort(Scm_GetStringConst(path), O_RDONLY, bufmode, 0);
  if (o == SCM_FALSE && !ignerr) {
     Scm_Error(\"couldn't open input file: %S\", path_scm);
  }
  SCM_RETURN(o);")

(define-cproc %open-output-file (path::<string>
                                 &keyword
                                 (if-exists (c "key_supersede"))
                                 (if-does-not-exist (c "key_create"))
                                 (mode::<fixnum> #o666)
                                 (buffering #f)
                                 (element-type (c "key_character"))
                                 )
  "  ScmObj o;
  int ignerr = FALSE, bufmode, flags = O_WRONLY;

  if (SCM_EQ(if_exists, key_append)) flags |= O_APPEND;
  else if (SCM_EQ(if_exists, key_error)) {
    flags |= O_EXCL;
    if (SCM_EQ(if_does_not_exist, key_error)) {
      Scm_Error(\"bad flag combination: :if-exists and :if-does-not-exist can't be :error the same time.\");
    }
  }
  else if (SCM_EQ(if_exists, key_supersede)) flags |= O_TRUNC;
  else if (SCM_EQ(if_exists, key_overwrite)) /*no need to add flags*/;
  else if (SCM_FALSEP(if_exists)) { flags |= O_EXCL; ignerr = TRUE; }
  else {
    Scm_Error(\"argument for :if-exists must be either :supersede, :overwrite, :append, :error or #f, but got %S\", if_exists);
  }

  if (SCM_EQ(if_does_not_exist, key_create)) flags |= O_CREAT;
  else if (SCM_FALSEP(if_does_not_exist)) ignerr = TRUE;
  else if (!SCM_EQ(if_does_not_exist, key_error)) {
    Scm_Error(\"argument for :if-does-not-exist must be either :error, :create or #f, but got %S\", if_does_not_exist);
  }

  bufmode = Scm_BufferingMode(buffering, SCM_PORT_OUTPUT, SCM_PORT_BUFFER_FULL);
  o = Scm_OpenFilePort(Scm_GetStringConst(path), flags, bufmode, mode);
  if (!ignerr && o == SCM_FALSE) {
     Scm_Error(\"couldn't open output file: %S\", path_scm);
  }
  SCM_RETURN(o);")

;; String port (srfi-6)
(define-cproc open-input-string (string::<string>
                                 &keyword (private?::<boolean> #f))
  "SCM_RETURN(Scm_MakeInputStringPort(string, privateP));")

(define-cproc open-output-string (&keyword (private?::<boolean> #f))
  "SCM_RETURN(Scm_MakeOutputStringPort(privateP));")

(define-cproc get-output-string (oport::<output-port>) ;SRFI-6
  (return "Scm_GetOutputString"))

(define-cproc get-remaining-input-string (iport::<input-port>)
  (return "Scm_GetRemainingInputString"))

(define-cproc open-coding-aware-port (iport::<input-port>)
  (return "Scm_MakeCodingAwarePort"))

;; Buffered port
;; NB: the interface may be changed soon!!
"static void bufport_closer(ScmPort *p)
 {
    if (SCM_PORT_DIR(p) == SCM_PORT_OUTPUT) {
       ScmObj scmflusher = SCM_OBJ(p->src.buf.data);
       int siz = (int)(p->src.buf.current - p->src.buf.buffer);
       if (siz > 0) Scm_Apply(scmflusher, SCM_LIST1(Scm_MakeString(p->src.buf.buffer, siz, siz, SCM_MAKSTR_INCOMPLETE|SCM_MAKSTR_COPYING)));
       Scm_Apply(scmflusher, SCM_LIST1(SCM_FALSE));
    }
 }"

"static int bufport_filler(ScmPort *p, int cnt)
 {
    ScmObj scmfiller, r;  int siz;
    scmfiller = SCM_OBJ(p->src.buf.data);
    /* no need to use VMApply; we're in the C callback */
    r = Scm_Apply(scmfiller, SCM_LIST1(Scm_MakeInteger(cnt)));
    if (SCM_EOFP(r) || SCM_FALSEP(r)) {
       return 0;
    } else if (!SCM_STRINGP(r)) {
       Scm_Error(\"buffered port callback procedure returned non-string: %S\", r);
    }
    siz = SCM_STRING_SIZE(r);
    if (siz > cnt) siz = cnt; /* for safety */
    memcpy(p->src.buf.end, SCM_STRING_START(r), siz);
    return SCM_STRING_SIZE(r);
 }"

(define-cproc open-input-buffered-port (filler::<procedure>
                                        buffer-size::<fixnum>)
  "  ScmPortBuffer bufrec;
  bufrec.size = buffer_size;
  bufrec.buffer = NULL;
  bufrec.mode = SCM_PORT_BUFFER_FULL;
  bufrec.filler = bufport_filler;
  bufrec.flusher = NULL;
  bufrec.closer = bufport_closer;
  bufrec.ready = NULL;
  bufrec.filenum = NULL;
  bufrec.data = (void*)filler;
  SCM_RETURN(Scm_MakeBufferedPort(SCM_CLASS_PORT, SCM_FALSE, SCM_PORT_INPUT, TRUE, &bufrec));
  ")

"static int bufport_flusher(ScmPort *p, int cnt, int forcep)
 {
     ScmObj scmflusher, s;
     scmflusher = SCM_OBJ(p->src.buf.data);
     s = Scm_MakeString(p->src.buf.buffer, cnt, cnt, SCM_MAKSTR_INCOMPLETE|SCM_MAKSTR_COPYING);
     Scm_Apply(scmflusher, SCM_LIST1(s));
     return cnt;
 }"

(define-cproc open-output-buffered-port (flusher::<procedure>
                                         buffer-size::<fixnum>)
  "  ScmPortBuffer bufrec;
  bufrec.size = buffer_size;
  bufrec.buffer = NULL;
  bufrec.mode = SCM_PORT_BUFFER_FULL;
  bufrec.filler = NULL;
  bufrec.flusher = bufport_flusher;
  bufrec.closer = bufport_closer;
  bufrec.ready = NULL;
  bufrec.filenum = NULL;
  bufrec.data = (void*)flusher;
  SCM_RETURN(Scm_MakeBufferedPort(SCM_CLASS_PORT, SCM_FALSE, SCM_PORT_OUTPUT, TRUE, &bufrec));
  ")

(define-cproc flush (&optional (oport::<output-port> (current-output-port)))
  (return <void> "Scm_Flush"))

(define-cproc flush-all-ports ()
  "  Scm_FlushAllPorts(FALSE); SCM_RETURN(SCM_UNDEFINED);")

(define-cproc port-closed? (obj::<port>)
  (return <boolean> "SCM_PORT_CLOSED_P"))

(define-cproc current-error-port ()     ;gauche extention
  "  SCM_RETURN(SCM_OBJ(SCM_CURERR));")

(define-cproc standard-input-port ()
  (return "Scm_Stdin"))

(define-cproc standard-output-port ()
  (return "Scm_Stdout"))

(define-cproc standard-error-port ()
  (return "Scm_Stderr"))

(define-cproc with-input-from-port (port::<input-port> thunk)
  "  SCM_RETURN(Scm_WithPort(&port, thunk, SCM_PORT_CURIN, FALSE));")

(define-cproc with-output-to-port (port::<output-port> thunk)
  "  SCM_RETURN(Scm_WithPort(&port, thunk, SCM_PORT_CUROUT, FALSE));")

(define-cproc with-error-to-port (port::<output-port> thunk)
  "  SCM_RETURN(Scm_WithPort(&port, thunk, SCM_PORT_CURERR, FALSE));")

(define-cproc port-name (port::<port>)
  (return "Scm_PortName"))

(define-cproc port-current-line (port::<port>)
  (return <fixnum> "Scm_PortLine"))

(define-cproc port-file-number (port::<port>)
  "  int i = Scm_PortFileNo(port);
  SCM_RETURN((i < 0)? SCM_FALSE : Scm_MakeInteger(i));")

(define-enum SEEK_SET)
(define-enum SEEK_CUR)
(define-enum SEEK_END)

(define-cproc port-seek (port::<port> offset::<integer>
                         &optional (whence::<fixnum> (c "SCM_MAKE_INT(SEEK_SET)")))
  (return "Scm_PortSeek"))

(define-symbol file "sym_file")
(define-symbol string "sym_string")
(define-symbol proc "sym_proc")
(define-cproc port-type (port::<port>)
  "ScmObj type = SCM_FALSE;
   switch (SCM_PORT_TYPE(port)) {
     case SCM_PORT_FILE: type = sym_file; break;
     case SCM_PORT_PROC: type = sym_proc; break;
     case SCM_PORT_OSTR:;
     case SCM_PORT_ISTR: type = sym_string; break;
   }
   SCM_RETURN(type);")

(define-cproc port-buffering (port::<port>)
  (return "Scm_GetBufferingMode")
  (setter (port::<port> mode)
    "if (SCM_PORT_TYPE(port) != SCM_PORT_FILE) {
       Scm_Error(\"can't set buffering mode to non-buffered port: %S\", port);
     }
     port->src.buf.mode = Scm_BufferingMode(mode, port->direction, -1);
     SCM_RETURN(SCM_UNDEFINED);")
  )

;; Open port from fd
(define-cproc open-input-fd-port (fd::<fixnum>
                                  &keyword (buffering #f)
                                           (owner?::<boolean> #f)
                                           (name #f))
  "int bufmode = Scm_BufferingMode(buffering, SCM_PORT_INPUT, SCM_PORT_BUFFER_FULL);
   if (fd < 0) Scm_Error(\"bad file descriptor: %d\", fd);
   return Scm_MakePortWithFd(name, SCM_PORT_INPUT, fd, bufmode, ownerP);")

(define-cproc open-output-fd-port (fd::<fixnum>
                                   &keyword (buffering #f)
                                            (owner?::<boolean> #f)
                                            (name #f))
  "int bufmode = Scm_BufferingMode(buffering, SCM_PORT_OUTPUT, SCM_PORT_BUFFER_FULL);
   if (fd < 0) Scm_Error(\"bad file descriptor: %d\", fd);
   return Scm_MakePortWithFd(name, SCM_PORT_OUTPUT, fd, bufmode, ownerP);")

;; Unsafe port operations
(define-cproc with-port-locking (port::<port> proc)
  (return "Scm_VMWithPortLocking"))

(define-cproc port->byte-string (port::<input-port>)
  ;; TODO: use chunked I/O if appropriate
  " int b; ScmPort *out = SCM_PORT(Scm_MakeOutputStringPort(TRUE));
  for (;;) {
    SCM_GETB(b, port);
    if (b == EOF) break;
    Scm_PutbUnsafe(b, out);
  }
  SCM_RETURN(Scm_GetOutputString(out));")

;;
;; 6.6.2  Input
;;

(define-cproc byte-ready? (port::<input-port>)
  (return <boolean> "Scm_ByteReady"))

(define-cproc read-byte (&optional (port::<input-port> (current-input-port)))
  "  int b; SCM_GETB(b, port);
  SCM_RETURN((b < 0)? SCM_EOF : SCM_MAKE_INT(b));")

(define-cproc peek-byte (&optional (port::<input-port> (current-input-port)))
  "  int b = Scm_Peekb(port);
  SCM_RETURN((b < 0)? SCM_EOF : SCM_MAKE_INT(b));")

(define-cproc read-line (&optional (port::<input-port> (current-input-port))
                                   (allowbytestr #f))
  "ScmObj r = Scm_ReadLine(port);
  if (SCM_FALSEP(allowbytestr)&&SCM_STRINGP(r)&&SCM_STRING_INCOMPLETE_P(r)) {
    Scm_ReadError(port, \"read-line: encountered illegal byte sequence: %S\", r);
  }
  SCM_RETURN(r);")

(define-cproc read-block (bytes::<fixnum>
                          &optional (port::<input-port> (current-input-port)))
  "  char *buf; int nread;
  if (bytes < 0) Scm_Error(\"bytes must be non-negative integer: %d\", bytes);
  if (bytes == 0) SCM_RETURN(Scm_MakeString(\"\", 0, 0, 0));
  buf = SCM_NEW_ATOMIC2(char*, bytes);
  nread = Scm_Getz(buf, bytes, port);
  if (nread <= 0) {
    SCM_RETURN(SCM_EOF);
  } else {
    SCM_RETURN(Scm_MakeString(buf, nread, nread, SCM_MAKSTR_INCOMPLETE));
  }")

(define-cproc read-list (closer::<char>
                         &optional (port (current-input-port)))
  "SCM_RETURN(Scm_ReadList(port, closer));")

(define-cproc define-reader-ctor (symbol proc &optional (finisher #f))
  (return "Scm_DefineReaderCtor"))

(define-type <read-reference> "ScmReadReference*" "read reference"
  "SCM_READ_REFERENCE_P" "SCM_READ_REFERENCE" "")

(define-cproc read-reference? (obj)
  "SCM_RETURN(SCM_MAKE_BOOL(SCM_READ_REFERENCE_P(obj)));")

(define-cproc read-reference-has-value? (ref::<read-reference>)
  "SCM_RETURN(SCM_MAKE_BOOL(!SCM_UNBOUNDP(ref->value)));")

(define-cproc read-reference-value (ref::<read-reference>)
  "if (SCM_UNBOUNDP(ref->value))
    Scm_Error(\"read reference hasn't been resolved\");
  SCM_RETURN(ref->value);")

;;
;; 6.6.3  Output
;;

(define-cproc write-byte (byte::<fixnum>
                          &optional (port::<output-port> (current-output-port)))
  "  if (byte < 0 || byte > 255) Scm_Error(\"argument out of range: %d\", byte);
  SCM_PUTB(byte, port);
  SCM_RETURN(SCM_MAKE_INT(1));")

(define-cproc write-limited (obj limit::<fixnum>
                             &optional (port (current-output-port)))
  "  int n = Scm_WriteLimited(obj, port, SCM_WRITE_WRITE, limit);
  SCM_RETURN(SCM_MAKE_INT(n));")

(define-cproc write* (obj &optional (port (current-output-port)))
  "  int n = Scm_WriteCircular(obj, port, SCM_WRITE_WRITE, 0);
  SCM_RETURN(SCM_MAKE_INT(n));")

;;
;; 6.6.4  System Interface
;;

(define-cproc %add-load-path (path::<string> &optional (afterp #f))
  "  const char *cpath = Scm_GetStringConst(path);
  SCM_RETURN(Scm_AddLoadPath(cpath, !SCM_FALSEP(afterp)));")

(define-cproc dynamic-load (file::<string>
                            &keyword (init-function #f)
                                     (export-symbols #f))
  "  SCM_RETURN(Scm_DynLoad(file, init_function, !SCM_FALSEP(export_symbols)));")

(define-cproc %require (feature)  (return "Scm_Require"))
(define-cproc provide (feature)   (return "Scm_Provide"))
(define-cproc provided? (feature) (return <boolean> "Scm_ProvidedP"))

;(define-cproc %make-autoload (sym::<symbol> path::<string>
;                              &optional import-from)
;  "ScmSymbol *from = SCM_SYMBOLP(import_from)? SCM_SYMBOL(import_from) : NULL;
;   SCM_RETURN(Scm_MakeAutoload(sym, path, from));")

(define-cproc %autoload (mod::<module> file-or-module entries)
  (return <void> "Scm_DefineAutoload"))

(define-cproc undefined ()
  "  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc undefined? (obj)    (return <boolean> "SCM_UNDEFINEDP"))

(define-cproc warn (fmt::<string> &rest args)
  (return void "Scm_FWarn"))

;;
;; Hashtable
;;

(define-cproc eq-hash (obj)
  (return <ulong> "Scm_EqHash"))

(define-cproc eqv-hash (obj)
  (return <ulong> "Scm_EqvHash"))

(define-cproc hash (obj)
  (return <ulong> "Scm_Hash"))

(define-cproc make-hash-table (&optional (type::<symbol> (c "sym_eq")))
  "  ScmHashProc htype = 0;
  if (SCM_OBJ(type) == sym_eq)             htype = (ScmHashProc)SCM_HASH_ADDRESS;
  else if (SCM_OBJ(type) == sym_eqv)       htype = (ScmHashProc)SCM_HASH_EQV;
  else if (SCM_OBJ(type) == sym_equal)     htype = (ScmHashProc)SCM_HASH_EQUAL;
  else if (SCM_OBJ(type) == sym_string_eq) htype = (ScmHashProc)SCM_HASH_STRING;
  else {
    Scm_Error(\"unsupported hash type: %S\", type);
  }
  SCM_RETURN(Scm_MakeHashTable(htype, NULL, 0));")

(define-cproc hash-table? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_HASHTABLEP(obj)));")

(define-cproc hash-table-type (hash::<hash-table>)
  "switch (hash->type) {
   case SCM_HASH_ADDRESS: SCM_RETURN(sym_eq);
   case SCM_HASH_EQV:     SCM_RETURN(sym_eqv);
   case SCM_HASH_EQUAL:   SCM_RETURN(sym_equal);
   case SCM_HASH_STRING:  SCM_RETURN(sym_string_eq);
   default: SCM_RETURN(SCM_FALSE);  /* TODO: need to think over */
  }")

(define-cproc hash-table-num-entries (hash::<hash-table>)
  "SCM_RETURN(Scm_MakeInteger(hash->numEntries));")

(define-cproc hash-table-get (hash::<hash-table> key &optional defval)
  "  ScmHashEntry *e = Scm_HashTableGet(hash, key);
  if (!e || e->value == SCM_UNBOUND) {
    if (defval != SCM_UNBOUND) SCM_RETURN(defval);
    else Scm_Error(\"hash table doesn't have an entry for key %S\", key);
  }
  SCM_RETURN(e->value);")

(define-cproc hash-table-put! (hash::<hash-table> key value)
  "  Scm_HashTablePut(hash, key, value);
  SCM_RETURN(SCM_UNDEFINED);")

;; this is hash-table-remove! in STk.  I use `delete' for
;; it's consistent with SRFI-1 and dbm-delete!.
(define-cproc hash-table-delete! (hash::<hash-table> key)
  "ScmHashEntry *e = Scm_HashTableDelete(hash, key);
  SCM_RETURN(SCM_MAKE_BOOL(e != NULL));")

(define-cproc hash-table-exists? (hash::<hash-table> key)
  " if (Scm_HashTableGet(hash, key) != NULL) 
    SCM_RETURN(SCM_TRUE);
  else
    SCM_RETURN(SCM_FALSE);")

(define-cproc hash-table-push! (hash::<hash-table> key value)
  "ScmHashEntry *e = Scm_HashTableAdd(hash, key, SCM_UNBOUND);
  if (SCM_UNBOUNDP(e->value)) e->value = SCM_LIST1(value);
  else                        e->value = Scm_Cons(value, e->value);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc hash-table-pop! (hash::<hash-table> key &optional fallback)
  "ScmHashEntry *e = Scm_HashTableGet(hash, key); ScmObj r;
  if (e == NULL) {
    if (SCM_UNBOUNDP(fallback)) {
      Scm_Error(\"hash table doesn't have an entry for key %S\", key);
    }
    r = fallback;
  } else if (!SCM_PAIRP(e->value)) {
    if (SCM_UNBOUNDP(fallback)) {
      Scm_Error(\"hash table value for key %S is not a pair: %S\", key, e->value);
    }
    r = fallback;
  } else {
    r = SCM_CAR(e->value); e->value = SCM_CDR(e->value);
  }
  SCM_RETURN(r);")

"static ScmObj hash_table_iter(ScmObj *args, int nargs, void *data)
 {
   ScmHashIter *iter = (ScmHashIter*)data;
   ScmHashEntry *e = Scm_HashIterNext(iter);
   ScmObj eofval = args[0];
   if (e == NULL) SCM_RETURN(Scm_Values2(eofval, eofval));
   else SCM_RETURN(Scm_Values2(e->key, e->value));
 }"

(define-cproc %hash-table-iter (hash::<hash-table>)
  "ScmHashIter *iter = SCM_NEW(ScmHashIter);
  Scm_HashIterInit(hash, iter);
  SCM_RETURN(Scm_MakeSubr(hash_table_iter, iter, 1, 0, SCM_MAKE_STR(\"hash-table-iterator\")));")

(define-cproc hash-table-keys (hash::<hash-table>)
  (return "Scm_HashTableKeys"))

(define-cproc hash-table-values (hash::<hash-table>)
  (return "Scm_HashTableValues"))

(define-cproc hash-table-stat (hash::<hash-table>)
  (return "Scm_HashTableStat"))

;;
;; Modules
;;

(define-cproc module? (obj) (return <boolean> "SCM_MODULEP"))

(define-cproc module-name (mod::<module>)
  "  SCM_RETURN(SCM_OBJ(SCM_MODULE(mod)->name));")

(define-cproc module-parents (mod::<module>)
  "  SCM_RETURN(mod->parents);")

(define-cproc module-precedence-list (mod::<module>)
  "  SCM_RETURN(mod->mpl);")

(define-cproc module-imports (mod::<module>)
  "  SCM_RETURN(mod->imported);")

(define-cproc module-exports (mod::<module>)
  "  SCM_RETURN(mod->exported);")

(define-cproc module-table (mod::<module>)
  "  SCM_RETURN(SCM_OBJ(mod->table));")

(define-cproc find-module (name::<symbol>)
  "  SCM_RETURN(Scm_FindModule(name, FALSE));")

(define-cproc all-modules ()
  (return "Scm_AllModules"))

(define-keyword error "key_error") ; this is also in stdlib.stub.  should I
                                   ; consolidate these?
(define-cproc make-module (name
                           &keyword (if-exists (c "key_error")))
  "int error_if_exists = TRUE;
  if (SCM_EQ(if_exists, key_error)) {
    error_if_exists = TRUE;
  } else if (SCM_FALSEP(if_exists)) {
    error_if_exists = FALSE;
  } else {
    Scm_Error(\"argument for :if-exists must be either :error or #f, but got %S\", if_exists);
  }
  if (!SCM_FALSEP(name) && !SCM_SYMBOLP(name)) {
    Scm_Error(\"module name must be a symbol or #f, but got %S\", name);
  }
  SCM_RETURN(Scm_MakeModule((SCM_FALSEP(name)?NULL:SCM_SYMBOL(name)),
                            error_if_exists));")

(define-cproc module-name->path (name)
  "  ScmSymbol *s = NULL;
  if (SCM_SYMBOLP(name)) s = SCM_SYMBOL(name);
  else if (SCM_IDENTIFIERP(name)) s = SCM_IDENTIFIER(name)->name;
  else Scm_Error(\"symbol or identifier required, but got %S\", name);
  SCM_RETURN(Scm_ModuleNameToPath(s));")

(define-cproc path->module-name (path::<string>)
  (return "Scm_PathToModuleName"))

(define-cproc %export-all ()
  "  SCM_RETURN(Scm_ExportAll(SCM_CURRENT_MODULE()));")

(define-cproc %extend (modules::<list>)
  "  SCM_RETURN(Scm_ExtendModule(SCM_CURRENT_MODULE(), modules));")

;; Returns two values
;; If found:      the value and #t
;; If not found:  #<undef>  and #f
(define-cproc module-find-binding (mod::<module> name::<symbol>
                                                 stay-in-module::<boolean>)
  "ScmGloc *g = Scm_FindBinding(mod, name, stay_in_module);
   if (g) {
     ScmObj val = SCM_GLOC_GET(g);
     SCM_RETURN(Scm_Values2(val, SCM_TRUE));
   } else {
     SCM_RETURN(Scm_Values2(SCM_UNDEFINED, SCM_FALSE));
   }")

;;
;; Gauche extentions
;;

;; Utility procedure

(define-cproc %format (port::<output-port> fmt::<string>
                       args shared::<boolean>)
  (return <void> "Scm_Format"))

(define-cproc exit (&optional (code::<fixnum> 0))
  (return <void> "Scm_Exit"))

;;
;; External view of VM.
;;

(define-cclass <thread> "ScmVM" "Scm_VMClass"
  ()
  ((name)
   (specific)
   )
  (printer
   "ScmVM *vm = SCM_VM(obj);
    const char *state;
    switch (vm->state) {
    case SCM_VM_NEW:        state = \"new\"; break;
    case SCM_VM_RUNNABLE:   state = \"runnable\"; break;
    case SCM_VM_BLOCKED:    state = \"blocked\"; break;
    case SCM_VM_TERMINATED: state = \"terminated\"; break;
    default: state = \"(unknown state)\";
    }
    Scm_Printf(port, \"#<thread %S %s %p>\", vm->name, state, vm);")
  )

(define-cproc vm-dump (&optional vm)
  " if (vm == SCM_UNBOUND) vm = SCM_OBJ(Scm_VM());
  else if (!SCM_VMP(vm)) Scm_Error(\"VM object required, got %S\", vm);
  Scm_VMDump(SCM_VM(vm));
  SCM_RETURN(SCM_UNDEFINED); ")

(define-cproc vm-get-stack-trace (&optional vm)
  " if (vm == SCM_UNBOUND) vm = SCM_OBJ(Scm_VM());
  else if (!SCM_VMP(vm)) Scm_Error(\"VM object required, got %S\", vm);
  SCM_RETURN(Scm_VMGetStack(SCM_VM(vm)));")

(define-cproc vm-get-stack-trace-lite (&optional vm)
  " if (vm == SCM_UNBOUND) vm = SCM_OBJ(Scm_VM());
  else if (!SCM_VMP(vm)) Scm_Error(\"VM object required, got %S\", vm);
  SCM_RETURN(Scm_VMGetStackLite(SCM_VM(vm)));")

(define-cproc vm-set-default-exception-handler (vm handler)
  "  if (!SCM_VMP(vm)) Scm_Error(\"VM object required, got %S\", vm);
  if (!SCM_FALSEP(handler) && !SCM_PROCEDUREP(handler)) {
    Scm_Error(\"a procedure or #f required, but got %S\", handler);
  }
  SCM_VM(vm)->defaultEscapeHandler = handler;
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc vm-instruction? (obj)
  "  SCM_RETURN(SCM_MAKE_BOOL(SCM_VM_INSNP(obj)));")

(define-cproc vm-insn-inspect (obj)
  "  SCM_RETURN(Scm_VMInsnInspect(obj));")

;; temporary
(define-cproc vm-pack-code (code)
  (return "Scm_PackCode"))
(define-cproc vm-dump-code (code::<compiled-code>)
  (return <void> "Scm_CompiledCodeDump"))
(define-cproc vm-code->list (code::<compiled-code>)
  (return "Scm_CompiledCodeToList"))
(define-cproc vm-compile (program &optional env)
  (return "Scm_Compile"))
(define-cproc vm-insn-build (insn)
  (return <ulong> "Scm_VMInsnBuild"))

(define-cproc make-identifier (name::<symbol> env::<list>)
  (return "Scm_MakeIdentifier"))

(define-cproc current-load-history ()
  "  SCM_RETURN(Scm_VM()->load_history);")
(define-cproc current-load-next ()
  "  SCM_RETURN(Scm_VM()->load_next);")
(define-cproc current-load-port ()
  "  SCM_RETURN(Scm_VM()->load_port);")

;; parameter
(define-cproc %vm-make-parameter-slot ()
  "int newid, num;
   num = Scm_MakeParameterSlot(Scm_VM(), &newid);
   SCM_RETURN(Scm_Values2(SCM_MAKE_INT(num), SCM_MAKE_INT(newid)));")
(define-cproc %vm-parameter-ref (index::<int> id::<int>)
  "  SCM_RETURN(Scm_ParameterRef(Scm_VM(), index, id));")
(define-cproc %vm-parameter-set! (index::<int> id::<int> value)
  "  SCM_RETURN(Scm_ParameterSet(Scm_VM(), index, id, value));")

;;
;; Inspecting feature
;;

;; Obtain info about gauche itself
(define-cproc gauche-version ()
  "  SCM_RETURN(SCM_MAKE_STR(GAUCHE_VERSION));")
(define-cproc gauche-architecture ()
  "  SCM_RETURN(SCM_MAKE_STR(GAUCHE_ARCH));")
(define-cproc gauche-library-directory ()
  (return "Scm_LibraryDirectory"))
(define-cproc gauche-architecture-directory ()
  (return "Scm_ArchitectureDirectory"))
(define-cproc gauche-site-library-directory ()
  (return "Scm_SiteLibraryDirectory"))
(define-cproc gauche-site-architecture-directory ()
  (return "Scm_SiteArchitectureDirectory"))
(define-cproc gauche-dso-suffix ()
  "  SCM_RETURN(SCM_MAKE_STR(SHLIB_SO_SUFFIX));")

;; Other thread stuff is in ext/threads/thrlib.stub
(define-cproc current-thread ()
  "SCM_RETURN(SCM_OBJ(Scm_VM()));")

(define-cproc unwrap-syntax (form)
  (return "Scm_UnwrapSyntax"))

;; GC stuff
(define-cproc gc () (return <void> "GC_gcollect"))

(define-keyword total-heap-size "key_total_heap_size")
(define-keyword free-bytes      "key_free_bytes")
(define-keyword bytes-since-gc  "key_bytes_since_gc")
(define-keyword total-bytes     "key_total_bytes")

(define-cproc gc-stat ()
  "  ScmObj h = SCM_NIL, t = SCM_NIL;
  SCM_APPEND(h, t, SCM_LIST2(key_total_heap_size,
                             Scm_MakeIntegerFromUI(GC_get_heap_size())));
  SCM_APPEND(h, t, SCM_LIST2(key_free_bytes,
                             Scm_MakeIntegerFromUI(GC_get_free_bytes())));
  SCM_APPEND(h, t, SCM_LIST2(key_bytes_since_gc,
                             Scm_MakeIntegerFromUI(GC_get_bytes_since_gc())));
  SCM_APPEND(h, t, SCM_LIST2(key_total_bytes,
                             Scm_MakeIntegerFromUI(GC_get_total_bytes())));
  SCM_RETURN(h);")

;; Misc.  WARNING: API may change
(define-cproc subr? (clo::<procedure>)
  (return <boolean> "SCM_SUBRP"))
(define-cproc closure? (clo::<procedure>)
  (return <boolean> "SCM_CLOSUREP"))

(define-cproc closure-code (clo::<closure>)
  "  SCM_RETURN(clo->code);")

(define-cproc procedure-info (proc::<procedure>)
  "  SCM_RETURN(SCM_PROCEDURE_INFO(proc));")


;; Local variables:
;; mode: scheme
;; end:
